## Java面向对象详解

### 面向对象概述

面向对象（Object Oriented）的基本思想就是在软件系统中模拟现实世界中客观存在的事物（即对象）及其之间的关系，并且在软件系统的构造时尽可能运用人类的思维方式。

面向对象思想使用**对象**来代表现实世界中某个具体的事物，使用对象之间关系来模拟事物之间的关系，并将具有相同特征的事物抽象为一个类的概念。比如，学生是某一类人的总称，而小明、小华、小红和小美是具体的某个学生**对象**，他们都具有学生的某些特征（如每天到学校上学、听老师讲课），他们都属于学生这个**类**，但彼此的共同特征又有些不同（比如可能学校不同、学习内容不同）。

面向对象思想的一些基本概念有抽象、封装、继承和多态：

1. 抽象。**抽象**（abstract）就是将客观的事物抽象成各种对象的组合，将一个复杂的系统分解成多个简单的部件进行处理。抽象时忽略掉那些与当前目标无关的因素，以便更充分地注意到那些与当前目标有关的因素。抽象并不打算了解全部问题，而是选择其中有用的部分。抽象包括两个方面：过程抽象（编程中使用**方法**来模拟某个过程）和数据抽象（编程中使用某种类型的变量或值来模拟现实数据）；
2. 继承。**继承**（extend，叫扩展更恰当，习惯上称为继承）是描述两个类之间的关系。**继承**允许一个类继承某些已有类的行为和状态，然后在持有已有类行为和状态的基础上进行扩展和修改。被继承或扩展的类叫父类（或基类），继承或扩展了的类叫做父类的子类（或派生类）。继承有单继承和多继承两种：单继承只允许从一个类继承，即只能有一个直接父类，但可以有多个间接父类；而多继承允许有多个直接父类。在Java中，除Object类（它是所有Java类的父类）以外，其它类都有父类。Java语言中只支持单继承，但可以通过实现接口来弥补单继承的不足。继承大大提高了代码的可重用性；
3. 封装。封装是将对象的状态和行为隐藏在对象内部，不允许外部对象直接访问封装对象的内部信息，外部对象必须通过封装对象的类提供方法来间接访问封装对象的内部信息。良好的封装可以隐藏实现细节、限制外部的不合理访问、便于修改和维护；
4. 多态。多态（polymorphism）是指允许同一个父类的不同子类的对象对同一消息做出不同的响应。Java中实现多态主要是方法的重载和方法的覆盖。利用动物这个类中定义发出叫声的功能，而动物的子类对象如猫和狗都可以发出叫声，但猫会“喵~喵~喵”，狗会“汪汪汪”。多态增强了代码的可替换性、可拓展性和灵活性。

### 类和对象

作为面向对象的一门语言，类和对象是Java中重要内容。**类**是某一类对象的抽象，是一种类别概念；而**对象**是某一**类**事物的具体个体。如小明这个对象，属于是学生这个类，也可以说小明是学生这个类的一个**实例**。

#### 类的定义

Java中类定义的语法如下：

```java
[修饰符] class ClassName {
  零到多个构造器定义...
  零到多个成员变量...
  零到多个方法...
}
```

**修饰符**：可以是public、protected、private”三者之一（或省略）加上staic（可省略）、final（可省略），此外还有transient和volatile。初学者先不用了解后面两个修饰符，前面的几个修饰符后续会逐渐介绍；

**类名**：Java语法要求类名只要是合法的标识符即可，但是编程规范建议一般类名采用**大驼峰命名法**（即采用多个连续的有意义的单词，每个单词首字母大写，单词之间没有任何分隔符）；

**类成员**：类名后的一对花括号（也叫大括号）之间的部分称为类体，类体中包含了类成员。上面的语法格式中的列出了常见的三种类成员：构造器、成员变量和方法。各类成员的顺序没有要求。如果一个类中没有任何类成员，那么它就是一个没有实际意义的空类；

**成员变量**用于定义该类或该类的实例所包含的状态数据，**方法**则定义了该类或该类实例行为或功能，而**构造器**用于创建该类的实例。没有构造器的类也就无法创建实例，所以，如果程序员没有为一个类定义构造器，则系统会创建一个默认的构造器，如果程序员定义了构造器，系统就不会提供默认的构造器。

定义成员变量的语法格式如下：

```java
[修饰符] 类型 成员变量名 [= 默认值]; 
```

其中：

- 修饰符：可以是public、protected、private”三者之一（或省略）加上staic（可省略）、final（可省略）。此外还有native和synchronized。初学者可以先不用了解后面两个；
- 类型：可以是任何基本数据类型和引用类型（通过类名、接口名来指定）；
- 成员变量名：Java语法要求成员变量只要是合法的标识符即可，但是编程规范建议成员变量名采用**小驼峰命名法**（即采用多个连续的有意义的单词，第一个单词首字母小写，其余单词首字母大写，单词之间没有任何分隔符）。编程规范建议**采用描述状态数据的英文名词**；
- 默认值：可以选择是否为一个成员变量添加具体默认值。

定义方法的语法格式如下：

```java
[修饰符] 返回值类型 方法名(形参列表) {
	零到多个可执行语句...
}
```

其中：

- 修饰符：可以是public、protected、private”三者之一（或省略）加上staic（可省略）、final（可省略）；
- 返回值类型：如果该方法执行完毕后需要得到一个返回值（通过return语句返回），那么就可以为该方法的返回值指定一个类型。返回值类型可以是任何Java允许的数据类型，包括基本数据类型和引用类型。如果该方法执行完毕后不需要返回任何数据，那么该方法的返回值类型应该指定为void；
- 方法名：Java语法要求方法名只要是合法的标识符即可，但是编程规范建议成员变量名采用**小驼峰命名法**（即采用多个连续的有意义的单词，第一个单词首字母小写，其余单词首字母大写，单词之间没有任何分隔符）。编程规范建议**以描述某种行为或功能的英文动词开头**；
- 形参列表：定义了该方法执行需要的参数。有零到多个形如“（形参）类型 形参名”形式的形参组成，多个形参之间使用英文逗号分隔。一旦指定了为一个方法指定了形参类表，就必须在调用该方法时传入具体的参数值，谁调用该方法谁负责传入实际参数值；
- 方法体：圆括号后面的一对花括号之间的部分是方法体，方法体内包含了实现具体的行为或功能的语句。

构造器可以看成是一种特殊的方法，专门用来创建类对象。定义构造器的语法格式与方法相似：

```java
[修饰符] 构造器名(形参列表) {
	零到多个初始化该类对象的语句...
}
```

其中：

- 修饰符：可以是public、protected、private”三者之一（或省略）；
- 构造器名：必须为当前类名；
- 形参列表：定义了该构造器执行需要的参数。格式与方法的形参列表相同。


构造器的定义中不能添加返回值类型，也不能添加void（这并不是说构造器没有返回值，构造器默认会返回当前类的对象，返回值的类型是当前类的类型）。如果在构造器定义时添加了返回值类型，那么Java会把该构造器当成是方法来处理，就失去了创建对象的作用。Java的规定构造器定义时不带返回值类型是为了与普通方法区别开来。

一个简单的类定义实例：

```java
public class Student {
  // 定义一个成员变量并指定默认值
  private String name = "No Name";
  
  // 定义一个有参数的构造器
  public Student(String name) {
    this.name = name;
  }
  
  // 定义一个无参数有返回值的方法
  public String getName() {
    return this.name;
  }
  
  // 定义一个有参数无返回值的方法
  public void setName(String name) {
    this.name = name;
  }
}
```



#### 创建和使用对象

定义了类之后，就可以通过在new关键字后调用该类的构造器（有参构造器需要传入实际的参数）来创建该类的实例了。比如：

```java
// 使用类名来定义两个属于该类类型的变量
Student xiaoMing, xiaoHong;
// 通过无参的默认构造器来创建一个类对象，然后将其赋值给一个变量
xiaoMing = new Student();
// 通过向有参构造器传入实参来创建一个类对象，然后将其赋值给一个变量
xiaoHong = new Student("小红");

// 也可以通过如下方式来创建对象并赋值
// Student xiaoHong = new Student("小红");
```

有了类对象之后就可以通过类对象访问对象的实例变量、调用该对象的实例方法了：

```java
// 根据类对象来访问该对象的实例变量并为其赋值
xiaoMing.name = "李明";
// 调用类对象的实例方法来访问或操作该对象的实例变量
// 将在控制台输出小红的名字
System.out.println(xiaoHong.getName());
// 更改小红的名字，然后输出
xiaoHong.setName("王红");
System.out.println(xiaoHong.name);
```

上面三段代码可以放在一个类中执行：

```java
public class Student {
  // 定义一个成员变量并指定默认值
  private String name = "No Name";
  private int age = "0";
  
  // 定义一个有参数的构造器
  public Student(String name, int age) {
    this.name = name;
    this.age = age;
  }
  
  // 定义无参数有返回值的方法
  public String getName() {
    return this.name;
  }
  
  public int getAge() {
    return this.age;
  }
  
  // 定义有参数无返回值的方法
  public void setName(String name) {
    this.name = name;
  }
  
  public void setAge(int age) {
    this.age = age;
  }
  
  public static void main(Sting[] args) {
    // 使用类名来定义两个属于该类类型的变量
	Student xiaoMing, xiaoHong;
	// 通过无参的默认构造器来创建一个类对象，然后将其赋值给一个变量
	xiaoMing = new Student();
	// 通过向有参构造器传入实参来创建一个类对象，然后将其赋值给一个变量
	xiaoHong = new Student("小红", 8);
	// 也可以通过如下方式来创建对象并赋值
	// Student xiaoHong = new Student("小红", 8);
    
    // 根据类对象来访问该对象的实例变量并为其赋值
	xiaoMing.name = "李明";
    xiaoMing.age = 9;
	// 调用类对象的实例方法来访问或操作该对象的实例变量
	// 将在控制台输出小红的名字
	System.out.println("学生姓名：" + xiaoHong.getName());
	// 更改小明的年龄，然后输出
	xiaoMing.setAge(7);
	System.out.println("学生年龄：" + String.valueOf(xiaoHong.age));
  }
}
```

> **注意**：上面的Student类必须定义在一个名为Student.java文件中，Java规定一个.java文件中只能定义一个public修饰的类（或接口），且.java的文件名必须与该类的类名相同。

#### 引用和指针

Java需要为变量开辟内存来存储该变量，比如上面的Student类变量xiaoHong在内存中的存储情况如下图所示：

![引用和指针](C:\Users\Administrator\Desktop\studynotes\JavaSE\appendix\引用和指针.png)

实际上Student类变量xiaoHong在内存中只是封装了一个指向Student类对象的引用，存放在栈内存中，而被引用的Student类对象存储在堆内存中，该Student类对象中不同类型的数据存储存储形式也不相同（String类对象是引用类型，故name变量也是一个指向“小红”字符串的引用，基本类型变量age则直接存储为int型8）。

当创建了一个类对象之后，必须通过该对象的引用才能访问该对象，同理，数组也需要通过指向其实际存储位置的引用变量来访问。使用类引用变量访问成员时，实际上是访问该引用变量所指对象的成员。

Java中的引用变量类似于C/C++中的指针，只是Java将指针封装了起来，从而避免了指针的烦琐操作，这是Java相对于C/C++易学的主要地方之一。



#### this引用

Java使用this关键字来

















#### 封装

封装性就是尽可能的隐藏对象内部的细节，对外形成一道边界，只保留有限的接口和方法与外界进行交互。封装的原则是使对象以外的部分不能随意的访问和操作对象的内部属性，从而避免了外界对对象内部属性的破坏。

可以通过对类的成员设置一定的访问权限，实现类中成员的信息隐蔽。

- private：类中限定为private的成员，只能被这个类的本身访问。如果一个类的构造方法声明为private，则其他类不能生成该类的一个实例。
- default：类中不加任何的访问权限限定成员属于缺省的（default）访问状态，可以被这个类的本身和同一个包里的类所访问。
- protected：类中限定为protected的成员，可以被这个类的本身、它的子类（包括同一个包中以及不同包中的子类）和同一个包中的所有其他的类访问。
- public：类中限定为public的成员，可以被所有的类访问。

下图“*”表示可以访问：

|      | private | default | protected | public |
| ---- | ------- | ------- | --------- | ------ |
| 同一类中 | *       | *       | *         | *      |
| 同一包中 |         | *       | *         | *      |
| 子类   |         |         | *         | *      |
| 全局范围 |         |         |           | *      |

#### 继承

子类的对象拥有父类的全部属性与方法，称作子类对父类的继承。

- Java中父类可以拥有多个子类，但是子类只能继承一个父类，称为单继承。
- 继承实现了代码的复用。
- Java中所有类都是通过直接或者间接地继承了java.lang.Object类得到的。换言之Object是Java中所有类的父类或者超类。
- 子类不能继承父类中访问权限是private的成员变量和成员方法。
- 子类可以重写父类的方法，以及命名与父类同名的成员变量。

Java中通过**super**来实现对父类成员的访问，super用来引用当前对象的父类。super的使用有三种情况：

- 访问父类被隐藏的成员变量，如：super.variable;
- 调用父类中被重写的方法，如：super.Method([paramlist])；。
- 调用父类的构造方法，如：super([paramlist]);。

#### 多态

对象的多态性是指在父类定义的属性或者方法被子类继承之后，可以具有不同的数据类型或表现出不同行为。这使得同一个属性或者方法在父类及其各个子类中具有不同的语义。例如：“几何图形”的“绘图”方法，“椭圆”和“多边形”都是“几何图形”的子类，其“绘图”的方法不一样。

Java的多态性体现在两个方面：由方法重载实现的静态多态性（编译时多态）和方法重写实现的动态多态性（运行时多态）。

- 编译时多态：在编译阶段，具体调用哪个被重载的方法，编译器会根据参数的不同静态（参数的类型、参数的顺序、参数的个数）确定其相应的方法。（比如在构造方法和一般方法里面）；子类重写父类的方法。

- 运行时多态：由于子类继承了父类的所有的属性（私有属性除外），所有的子类对象可以作为父类对象使用。程序中凡是使用父类对象的地方，都可以用子类对象来代替。一个对象可以通过引用子类的实例来调用子类的方法。（比如Dog类和Cat类是Animal的子类，我们定义一个方法void letSleep(Animal animal){animal.sleep();}，然后sleep这个父类中的方法，分别被子类重写。那么我们向letSleep这个方法分别传入dog（Dog类的实例）或者cat（Cat类的实例），那么该方法就会分别调用dog中的sleep()方法和cat中的sleep()方法）。

  #### 重载 (overload)

- 方法重载是让类以统一的方式处理不同数据类型的手段。

- 一个类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法。

- 返回值类型可以相同也可以不同，无法以返回值类型作为重载方法的区分标准。

#### 重写 (override)

- 子类对父类的方法进行重新编写。如果在子类中的方法与其父类有相同的方法名、返回类型和参数表，我们说该方法被重写。
- 如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。
- 子类函数的访问修饰权限不能低于父类的。







### 抽象类

如果一个类只是描述某一类对象具有某一功能，但是却没有具体定义该功能如何实现，那么该类就是一个抽象类。比如描述人类的Human类，该Human类可能描述了人类具有工作的能力，却没有定义具体的某类人如何工作（可能是厨师做饭、作家写作、程序员编程等）。抽象类中这种描述某种功能的方法称为抽象方法。

抽象类和抽象方法特点如下：

- 抽象类的定义比普通类的定义增加了abstract 关键字修饰。抽象方法也使用abstract关键字来定义。抽象方法没有方法体；
- 抽象类不一定有抽象方法，有抽象方法的类一定是抽象类；
- 抽象类不能被实例化（即使抽象类没有抽象方法），因为它不是具体的，所以无法通过new关键字来创建抽象类的实例。抽象类只能通过多态的方式，由其具体的子类来实例化。抽象方法的声明是一条**带英文分号**的语句，没有方法体；
- 抽象类的成员包括**成员变量**（既可以是变量，也可以是常量）、**构造器** （抽象类构造器主要用来被子类构造器调用来进行父类中数据的初始化）、**抽象方法**（也可以没有抽象方法）、**非抽象方法**（用于被子类继承达到代码复用的目的）、**初始化块**、**内部类**（接口、枚举）**5种成员**；
- 含有抽象方法的类（直接定义一个含有抽象方法的抽象类，或继承了一个抽象类但没有实现抽象父类的所有抽象方法，或实现一个接口但没有实现接口的所有抽象方法）只能被定义成抽象类。

如果说类是某些具有相同特征对象的抽象，那么抽象类则是对某些具有相同特征的类（不同的类对这些相同特征具有不同的实现）的抽象。抽象类体现了一种模板模式的设计思想，这种模板的存在避免了子类实现的随意性，子类在保留抽象父类数据的基础上进行扩展和改造。

**注意**：抽象方法和空方法是不同的概念：抽象方法没有方法体，如“public abstract void work();”是一个抽象方法定义，它是一条带分号的语句；而空方法有方法体，只是方法体为空，什么都不做。如“public void work() {}”是一个空方法。

下面定义一个抽象类：

```java
public abstract class Shape {
	{
		System.out.println("执行Shape的初始化块...");
	}
	private String color;

	// 定义一个计算周长的抽象方法
	public abstract double calPerimeter();

	// 定义一个返回形状的抽象方法
	public abstract String getType();

	// 定义Shape的构造器，该构造器并不是用于创建Shape对象，
	// 而是用于被子类调用
	public Shape() {
	}

	public Shape(String color) {
		System.out.println("执行Shape的构造器...");
		this.color = color;
	}

	// 省略color的setter和getter方法
	public void setColor(String color) {
		this.color = color;
	}

	public String getColor() {
		return this.color;
	}
}
```

抽象类不能创建实例，只能当做父类被子类继承。

继承抽象类的实例：

```java
public class Triangle extends Shape {
	// 定义三角形的三边
	private double a;
	private double b;
	private double c;

	public Triangle(String color, double a, double b, double c) {
		super(color);
		this.setSides(a, b, c);
	}

	public void setSides(double a, double b, double c) {
		if (a >= b + c || b >= a + c || c >= a + b) {
			System.out.println("三角形两边之和必须大于第三边");
			return;
		}
		this.a = a;
		this.b = b;
		this.c = c;
	}

	// 重写Shape类的的计算周长的抽象方法
	public double calPerimeter() {
		return a + b + c;
	}

	// 重写Shape类的的返回形状的抽象方法
	public String getType() {
		return "三角形";
	}
}
```

关于abstract关键注意以下几点：

- final修饰的类不能被继承，final修饰的方法不能被重写，故抽象类和抽象方法不能用final修饰；
- abstract只能用于抽象类和抽象方法，不能用于修饰成员变量、局部变量和构造器；
- static不能用于修饰抽象方法，即没有所谓的类抽象方法。如果static能用于修饰抽象方法，那么通过类调用该方法时会出现错误（无法调用一个没有方法体的方法）。虽然abstract和static不能同时修饰抽象方法，但abstract和static可以用来共同修饰内部类；
- abstract修饰的抽象方法被子类重写才有意义，故abstract不能使用和private一起用来修饰方法，应该使用protected修饰。











