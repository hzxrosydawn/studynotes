## Java面向对象详解

### 面向对象概述

面向对象（Object Oriented）的基本思想就是在软件系统中模拟现实世界中客观存在的事物（即对象）及其之间的关系，并且在软件系统的构造时尽可能运用人类的思维方式。

面向对象思想使用**对象**来代表现实世界中某个具体的事物，使用对象之间关系来模拟事物之间的关系，并将具有相同特征的事物抽象为一个类的概念。比如，学生是某一类人的总称，而小明、小华、小红和小美是具体的某个学生**对象**，他们都具有学生的某些特征（如每天到学校上学、听老师讲课），他们都属于学生这个**类**，但彼此的共同特征又有些不同（比如可能学校不同、学习内容不同）。

面向对象思想的一些基本概念有抽象、封装、继承和多态：

1. 抽象。**抽象**（abstract）就是将客观的事物抽象成各种对象的组合，将一个复杂的系统分解成多个简单的部件进行处理。抽象时忽略掉那些与当前目标无关的因素，以便更充分地注意到那些与当前目标有关的因素。抽象并不打算了解全部问题，而是选择其中有用的部分。抽象包括两个方面：过程抽象（编程中使用**方法**来模拟某个过程）和数据抽象（编程中使用某种类型的变量或值来模拟现实数据）；
2. 继承。**继承**（extend，叫扩展更恰当，习惯上称为继承）是描述两个类之间的关系。**继承**允许一个类继承某些已有类的行为和状态，然后在持有已有类行为和状态的基础上进行扩展和修改。被继承或扩展的类叫父类（或基类），继承或扩展了的类叫做父类的子类（或派生类）。继承有单继承和多继承两种：单继承只允许从一个类继承，即只能有一个直接父类，但可以有多个间接父类；而多继承允许有多个直接父类。在Java中，除Object类（它是所有Java类的父类）以外，其它类都有父类。Java语言中只支持单继承，但可以通过实现接口来弥补单继承的不足。继承大大提高了代码的可重用性；
3. 封装。**封装** （Encapsulation）是将对象的状态和行为隐藏在对象内部，不允许外部对象直接访问封装对象的内部信息，外部对象必须通过封装对象的类提供方法来间接访问封装对象的内部信息。良好的封装可以隐藏实现细节、限制外部的不合理访问、便于修改和维护；
4. 多态。**多态**（polymorphism）是指允许同一个父类的不同子类的对象对同一消息做出不同的响应。Java中实现多态主要是方法的重载和方法的覆盖。利用动物这个类中定义发出叫声的功能，而动物的子类对象如猫和狗都可以发出叫声，但猫会“喵~喵~喵”，狗会“汪汪汪”。多态增强了代码的可替换性、可拓展性和灵活性。

### 类和对象

作为面向对象的一门语言，类和对象是Java中重要内容。**类**是某一类对象的抽象，是一种类别概念；而**对象**是某一**类**事物的具体个体。如小明这个对象，属于是学生这个类，也可以说小明是学生这个类的一个**实例**。

#### 类的定义

Java中类定义的语法如下（初学者暂时先掌握下面基本的格式）：

```java
[修饰符] class ClassName {
  零到多个构造器定义...
  零到多个成员变量...
  零到多个方法...
}
```

**修饰符**：可以是public、protected、private”三者之一（或省略）加上staic（可省略）、final（可省略），此外还有transient和volatile。初学者先不用了解**后面两个**修饰符，前面的几个修饰符后续会逐渐介绍；

**类名**：Java语法要求类名只要是合法的标识符即可，但是编程规范建议一般类名采用**大驼峰命名法**（即采用多个连续的有意义的单词，每个单词首字母大写，单词之间没有任何分隔符）；

**类成员**：类名后的一对花括号（也叫大括号）之间的部分称为类体，类体中包含了类成员。上面的语法格式中的列出了常见的三种类成员：构造器、成员变量和方法。各类成员的顺序没有要求。如果一个类中没有任何类成员，那么它就是一个没有实际意义的空类；

**成员变量**用于定义该类或该类的实例所包含的状态数据，**方法**则定义了该类或该类实例行为或功能，而**构造器**用于创建该类的实例。没有构造器的类也就无法创建实例，所以，如果程序员没有为一个类定义构造器，则系统会创建一个默认的构造器，如果程序员定义了构造器，系统就不会提供默认的构造器。

**定义成员变量的语法格式**如下：

```java
[修饰符] 类型 成员变量名 [= 默认值]; 
```

其中：

- 修饰符：可以是public、protected、private”三者之一（或省略）加上staic（可省略）、final（可省略）。此外还有native和synchronized。初学者可以先不用了解后面两个；
- 类型：可以是任何基本数据类型和引用类型（通过类名、接口名来指定）；
- 成员变量名：Java语法要求成员变量只要是合法的标识符即可，但是编程规范建议成员变量名采用**小驼峰命名法**（即采用多个连续的有意义的单词，第一个单词首字母小写，其余单词首字母大写，单词之间没有任何分隔符）。编程规范建议**采用描述状态数据的英文名词**；
- 默认值：可以选择是否为一个成员变量添加具体默认值。

**定义方法的语法格式**如下：

```java
[修饰符] 返回值类型 方法名(形参列表) {
	零到多个可执行语句...
}
```

其中：

- 修饰符：可以是public、protected、private”三者之一（或省略）加上staic（可省略）、final（可省略）；
- 返回值类型：如果该方法执行完毕后需要得到一个返回值（通过return语句返回），那么就可以为该方法的返回值指定一个类型。返回值类型可以是任何Java允许的数据类型，包括基本数据类型和引用类型。如果该方法执行完毕后不需要返回任何数据，那么该方法的返回值类型应该指定为void；
- 方法名：Java语法要求方法名只要是合法的标识符即可，但是编程规范建议成员变量名采用**小驼峰命名法**（即采用多个连续的有意义的单词，第一个单词首字母小写，其余单词首字母大写，单词之间没有任何分隔符）。编程规范建议**以描述某种行为或功能的英文动词开头**；
- 形参列表：定义了该方法执行需要的参数。有零到多个形如“（形参）类型 形参名”形式的形参组成，多个形参之间使用英文逗号分隔。一旦指定了为一个方法指定了形参类表，就必须在调用该方法时传入具体的参数值，谁调用该方法谁负责传入实际参数值；
- 方法体：圆括号后面的一对花括号之间的部分是方法体，方法体内包含了实现具体的行为或功能的语句。

**构造器**可以看成是一种特殊的方法，专门用来创建类对象。定义构造器的语法格式与方法相似：

```java
[修饰符] 构造器名(形参列表) {
	零到多个初始化该类对象的语句...
}
```

其中：

- 修饰符：可以是public、protected、private”三者之一（或省略）；
- 构造器名：必须为当前类名；
- 形参列表：定义了该构造器执行需要的参数。格式与方法的形参列表相同。


构造器的定义中不能添加返回值类型，也不能添加void（这并不是说构造器没有返回值，构造器默认会返回当前类的对象，返回值的类型是当前类的类型）。如果在构造器定义时添加了返回值类型，那么Java会把该构造器当成是方法来处理，就失去了创建对象的作用。Java的规定构造器定义时不带返回值类型是为了与普通方法区别开来。

一个简单的类定义实例：

```java
public class Student {
  // 定义一个成员变量并指定默认值
  private String name = "No Name";
  
  // 定义一个有参数的构造器
  public Student(String name) {
    this.name = name;
  }
  
  // 定义一个无参数有返回值的方法
  public String getName() {
    return this.name;
  }
  
  // 定义一个有参数无返回值的方法
  public void setName(String name) {
    this.name = name;
  }
}
```

#### 创建和使用对象

定义了类之后，就可以通过在new关键字后调用该类的构造器（有参构造器需要传入实际的参数）来创建该类的实例了。比如：

```java
// 使用类名来定义两个Student类类型的变量
Student xiaoMing, xiaoHong;
// 通过无参的默认构造器来创建一个类对象，然后将其赋值给一个变量
xiaoMing = new Student();
// 通过向有参构造器传入实参来创建一个类对象，然后将其赋值给一个变量
xiaoHong = new Student("小红");

// 也可以通过如下方式（声明变量、创建对象和赋值全部通过一条语句完成）来创建对象并赋值
// Student xiaoHong = new Student("小红");
```

有了类对象之后就可以通过类对象访问对象的实例变量、调用该对象的实例方法了：

```java
// 根据类对象来访问该对象的实例变量并为其赋值
xiaoMing.name = "李明";
// 调用类对象的实例方法来访问或操作该对象的实例变量
// 将在控制台输出小红的名字
System.out.println(xiaoHong.getName());
// 更改小红的名字，然后输出
xiaoHong.setName("王红");
System.out.println(xiaoHong.name);
```

上面三段代码可以放在一个类中执行：

```java
public class Student {
  // 定义一个成员变量并指定默认值
  private String name = "No Name";
  private int age = "0";
  
  // 定义一个有参数的构造器
  public Student(String name, int age) {
    this.name = name;
    this.age = age;
  }
  
  // 定义无参数有返回值的方法
  public String getName() {
    return this.name;
  }
  
  public int getAge() {
    return this.age;
  }
  
  // 定义有参数无返回值的方法
  public void setName(String name) {
    this.name = name;
  }
  
  public void setAge(int age) {
    this.age = age;
  }
  
  public static void main(Sting[] args) {
    // 使用类名来定义两个属于该类类型的变量
	Student xiaoMing, xiaoHong;
	// 通过无参的默认构造器来创建一个类对象，然后将其赋值给一个变量
	xiaoMing = new Student();
	// 通过向有参构造器传入实参来创建一个类对象，然后将其赋值给一个变量
	xiaoHong = new Student("小红", 8);
	// 也可以通过如下方式来创建对象并赋值
	// Student xiaoHong = new Student("小红", 8);
    
    // 根据类对象来访问该对象的实例变量并为其赋值
	xiaoMing.name = "李明";
    xiaoMing.age = 9;
	// 调用类对象的实例方法来访问或操作该对象的实例变量
	// 将在控制台输出小红的名字
	System.out.println("学生姓名：" + xiaoHong.getName());
	// 更改小明的年龄，然后输出
	xiaoMing.setAge(7);
	System.out.println("学生年龄：" + String.valueOf(xiaoHong.age));
  }
}
```

> **注意**：上面的Student类必须定义在一个名为Student.java文件中，Java规定一个.java文件中只能定义一个public修饰的类（或接口），且.java的文件名必须与该类的类名相同。

#### static关键字

static关键用于修饰方法、成员变量、内部类和内部接口等，表示这些成员属于类本身，而不属于该类的单个实例。因此，static修饰的方法、成员变量也称为类变量（也称静态变量）、类方法（也称静态方法）。

不使用static修饰的普通方法、普通成员变量则属于该类的单个实例，而不是该类。通常把不使用static修饰的方法、成员变量称为实例变量（也称非静态变量）、实例方法（也称非静态方法）。

**类成员只能访问该类的类成员，不能访问实例成员，实例成员也只能访问该类的实例成员，不能访问类成员**。**访问类成员的语法格式为“类名.类成员”**（或“对象名.实例成员”，这种方式底层还是使用类名作为调用者的。不过不推荐使用这种方式，易混淆），**访问实例成员的语法格式为“对象名.实例成员”**。

#### 引用和指针

Java需要为变量开辟内存来存储该变量，比如上面的Student类变量xiaoHong在内存中的存储情况如下图所示：

![引用和指针](appendix/引用和指针.png)

实际上Student类变量xiaoHong在内存中只是封装了一个指向Student类对象的引用，存放在栈内存中，而被引用的Student类对象存储在堆内存中，该Student类对象中不同类型的数据存储存储形式也不相同（String类对象是引用类型，故name变量也是一个指向“小红”字符串的引用，基本类型变量age则直接存储为int型8）。

当创建了一个类对象之后，必须通过该对象的引用才能访问该对象，同理，数组也需要通过指向其实际存储位置的引用变量来访问。使用类引用变量访问成员时，实际上是访问该引用变量所指对象的成员。

如果堆内存中的对象没有任何引用指向它，那么就无法访问该对象，这个对象就变成了垃圾，Java垃圾回收机制会在合适的时候释放该对象所占的内存。

Java中的引用变量类似于C/C++中的指针，只是Java将指针封装了起来，从而避免了指针的烦琐操作，这是Java相对于C/C++易学的主要地方之一。

#### this引用

Java通过使用**this关键字指向调用this所在方法的对象**。this作为对象的默认引用有以下两种情况：

- 在方法中引用调用该方法的对象；
- 在构造器中引用构造器正在初始化的对象。

this最大的作用就是在类的一个方法中，访问该类中另一个方法或实例变量。如

```java
public class Dog {
	// 定义一个jump()方法
	public void jump() {
		System.out.println("正在执行jump方法");
	}
	// 定义一个run()方法，run()方法需要借助jump()方法
	public void run() {
		// 使用this引用调用run()方法的对象
		this.jump();
		System.out.println("正在执行run方法");
	}
}
```

this可以引用任何对象。当this出现在某个方法中时，它所代表的对象是不确定的，但该被引用的对象的类型是确定的，this只能引用当前类的对象。只有当方法被调用时，该方法中this所引用的对象才会确定下来。谁调用this所在的方法，this就代表谁。

Java允许对象的一个成员调用另一个成员时省略this，但实际上这个this是存在的（毕竟不能缺少调用者）。上面的run()方法可以修改成如下所示：

```java
public void run() {
      	// Java允许对象的一个成员调用另一个成员时省略this
      	jump();
		System.out.println("正在执行run方法");
}
```

**static修饰的方法中不能使用this**。因为this是指向实例对象的，而static修饰的方法属于类。例如，下面的代码将编译出误：

```java
public class StaticAccessNonStatic {
	public void info() {
		System.out.println("简单的info方法");
	}
	public static void main(String[] args) {
		// 因为main()方法是静态方法，而info()是非静态方法，
		// 调用main()方法的是该类本身，而不是该类的实例，
		// 因此省略的this无法指向有效的对象
		info();
	}
}
```

此外，this也可以在构造器作为当前正在被初始化对象的默认引用。

```java
public class ThisInConstructor {
	// 定义一个名为foo的成员变量
	public int foo;
	public ThisInConstructor() {
		// 在构造器里定义一个名为foo的局部变量
		int foo = 0;
		// 使用this代表该构造器正在初始化的对象
		// 下面的代码将会把该构造器正在初始化的对象的foo成员变量设为6，而不是上面的局部变量foo
		this.foo = 6;
	}
	public static void main(String[] args) {
		// 所有使用ThisInConstructor创建的对象的foo成员变量
		// 都将被设为6，所以下面代码将输出6
		System.out.println(new ThisInConstructor().foo);
	}
}
```

this作为对象的默认引用时，可以将this当成普通引用变量使用，甚至可以将this作为返回值。如下面的代码所示：

```java
public class ReturnThis {
	public int num;
	public ReturnThis increase() {
		num++;
		// return this返回调用该方法的对象
		return this;
	}
    	
  	public ReturnThis decrease() {
     	num--;
		// return this返回调用该方法的对象
		return this;
  	}
  
  	public void showNumber() {
      System.out.println("rt的num成员变量值是:" + rt.num);
  	}
  
	public static void main(String[] args) {
		ReturnThis rt = new ReturnThis();
		// 可以连续调用同一个方法
		rt.increase()
			.decrease()
			.showNumber();
	}
}
```

可以连续调用将this作为返回值的方法，从而使代码更加简洁。

### 方法详解

#### 方法的参数传递

Java中的**方法不能独立存在，必须定义在类里，必须通过类或类的对象来调用**。如果被调用方法含有形参，则必须在调用该方法时传入实际的参数（称为实参）。Java里方法参数的传递是按值传递的，所谓**值传递，就是将实参的副本传入方法，而原有实参没有变化**。

使用**基本类型进行参数传递时，直接传入基本类型实参的值（副本）**：

```java
public class PrimitiveTransferTest {
	public static void swap(int a , int b) {
		// 下面三行代码实现a、b变量的值交换。
		// 定义一个临时变量来保存a变量的值
		int tmp = a;
		// 把b的值赋给a
		a = b;
		// 把临时变量tmp的值赋给a
		b = tmp;
		System.out.println("交换结束后：\nswap方法里，变量a的值是"
			+ a + "，变量b的值是" + b);
	}
	public static void main(String[] args) {
		int a = 6;
		int b = 9;
		swap(a , b);
		System.out.println("在main方法里，变量a的值是"
			+ a + "，变量b的值是" + b);
	}
}
```

运行结果如下：

```powershell
交换结束后：
swap方法里，变量a的值是9，变量b的值是6
main方法里，变量a的值是9，变量b的值是6
```

在上面代码的main()方法中调用swap()方法时，main()方法还未结束，因此，系统会分别为这两个方法开辟两块栈区，用于保存main()方法和swap()方法的局部变量a、b。main()方法中的a、b变量作为实参传入swap()方法，实际上是在swap()方法的栈区又产生了两个变量a、b，并将main()方法栈区中a、b变量的值分别赋值给swap()方法栈区的a、b参数（传入的是副本），即对a、b形参进行了初始化。此时，系统存在两个a变量、两个b变量，只是存在于不同的方法栈区而已。

![ParameterTransfer](C:\Users\Administrator\Desktop\studynotes\JavaSE\appendix\ParameterTransfer.png)

上图中main()方法栈区中a、b的值并未有任何改变，改变的只有swap()方法栈区中的a、b值。

接下来看**引用类型的参数传递**。**引用类型的参数传递也是按值传递，只是传入的是引用变量的地址副本**（是一个指向被引用对象的地址），**而不是对象本身**。

```java
class DataWrap {
	int a;
	int b;
}

public class ReferenceTransferTest {
	public static void swap(DataWrap dw) {
		// 下面三行代码实现dw的a、b两个成员变量的值交换。
		// 定义一个临时变量来保存dw对象的a成员变量的值
		int tmp = dw.a;
		// 把dw对象的b成员变量值赋给a成员变量
		dw.a = dw.b;
		// 把临时变量tmp的值赋给dw对象的b成员变量
		dw.b = tmp;
		System.out.println("交换结束后：\nswap方法里，变量a的值是"
			+ dw.a + ",变量b的值是" + dw.b);
		// 把dw直接赋为null，让它不再指向任何有效地址。
		dw = null;
	}
	public static void main(String[] args) {
		DataWrap dw = new DataWrap();
		dw.a = 6;
		dw.b = 9;
		swap(dw);
		System.out.println("变量a的值是"
			+ dw.a + "，变量b的值是" + dw.b);
	}
}
```

运行结果如下：

```powershell
交换结束后：
swap方法里，变量a的值是9，变量b的值是6
main方法里，变量a的值是6，变量b的值是9
```

我们发现运行结果中，变量a、b的值发生了改变。

![ParameterTransfer2](C:\Users\Administrator\Desktop\studynotes\JavaSE\appendix\ParameterTransfer2.png)

这是因为在main()方法中虽然传给swap()方法的是dw引用变量的副本（指向DataWrap类对象的引用的副本），但是副本和原引用指向的是同一个对象，操作的是同一个对象的成员变量，所以结果发生了改变。

#### 形参个数可变的方法

从JDK 1.5开始，Java允许使用形参个数可变的方法。格式为**在形参列表中最后一个形参的类型后面加三个英文句号（...），则该形参就可以接受多个该类型参数值，传入的多个参数值被当成数组**。例如：

```java
public class Varargs {
	// 定义了形参个数可变的方法
	public static void test(int a , String... books) {
		// books被当成数组处理
		for (String tmp : books) {
			System.out.println(tmp);
		}
		// 输出整数变量a的值
		System.out.println(a);
	}
	public static void main(String[] args) {
		// 调用test方法
		test(5 , "Head First Java" , "Head First Android");
	}
}
```

运行结果如下：

```powershell
Head First Java
Head First Android
5
```

形参个数可变的参数本质上是一个数组参数，效果相同。如下面两段代码效果相同：

```java
// 形参个数可变
public static void test(int a , String... books)
```

```java
// 使用数组
public static void test(int a , String[] books)
```

以上两种方法的区别在于**形参个数可变的方法定义在调用方法时更加简洁**，如下面两段代码所示：

```java
test(5 , "Head First Java" , "Head First Android");
```

```java
test(5 , new String[] {"Head First Java" , "Head First Android"});
```

但是**个数可变的形参必须位于参数列表的最后，而且一个方法中只能有一个长度可变的形参**。而**数组形式的参数可以位于形参列表的任意位置，且可以有多个数组形式的参数**。

#### 方法递归

**在一个方法内调用它自身，被称为方法递归**。方法递归隐含了一种循环。已知一个数列：f(0)=1，f(1)=4，f(n+2)=2\*f(n+1)+f(n)。求f(10)。求解代码如下：

```java
public class Recursive {
	public static int fn(int n) {
		if (n == 0) {
			return 1;
		}
		else if (n == 1) {
			return 4;
		}
		else {
			// 方法中调用它自身，就是方法递归
			return 2 * fn(n - 1) + fn(n - 2);
		}
	}
	public static void main(String[] args) {
		// 输出fn(10)的结果
		System.out.println(fn(10));
	}
}
```

上面代码中主要通过

```java
return 2 * fn(n - 1) + fn(n - 2);
```

来实现方法不断调用自身。这种不断调用自身的过程是可以在某个时刻终止的，否则就是一个死循环。因此，**定义递归方法时必须要向已知的方向递归，以保证递归可以终止**。

#### 方法重载

在Java中，如果**一个类中含有两个或两个以上的同名方法，但这些方法的形参不同，那么这就是方法重载（Overload）**。**方法重载不要求重载方法的返回值和修饰符相同**。**根据所调用方法形参的不同来确定调用哪一个重载方法**。比如：

```java
public class Overload {
	// 下面定义了两个test()方法，但方法的形参列表不同
	// 系统可以区分这两个方法，这种被称为方法重载
	public void test() {
		System.out.println("无参数");
	}
	public void test(String msg) {
		System.out.println("重载的test方法: " + msg);
	}
	public static void main(String[] args) {
		Overload ol = new Overload();
		// 调用test()时没有传入参数，因此系统调用上面没有参数的test()方法。
		ol.test();
		// 调用test()时传入了一个字符串参数，
		// 因此系统调用上面带一个字符串参数的test()方法。
		ol.test("hello");
	}
}
```

运行结果如下;

```powershell
无参数
重载的test方法:hello
```

**重载的意义在于增加了同一种行为或功能的灵活性，可以使同一种功能在不同的条件下获得不同的执行效果**。不过并**不建议重载形参个数可变的方法，因为这样没有太大的意义，而且可读性也差**。

#### 成员变量和局部变量

![变量](C:\Users\Administrator\Desktop\studynotes\JavaSE\appendix\变量.png)



##### 成员变量

成员变量指的是在类里定义的变量，包括**类变量**（使用static修饰，**属于类所有，不属于该类的实例**）和**实例变量**（没有static修饰，属于类的实例）。**类变量在类的*准备阶段*（参考[类的加载部分]()）开始初始化（并分配内存）**，直到系统完全销毁该类。而**实例变量从创建类对象时开始初始化**，直到该实例消失。**如果成员变量在定义时显式被指定了一个值，那么系统会在该成员变量初始化时将该值赋值给该成员变量，如果定义时没有为其显式指定值，那么会执行默认初始化**（成员变量的默认初始化规则与数组元素默认初始化规则相同，参考数据[类型和类型转换]()中各种数据类型的默认值）。

**一个类的类变量和实例变量存储在堆内存中的不同区域（因为两者的生命周期不同且分属不同的目标，类变量在类加载后创建对象之前已经存在于内存中了，即使某个对象（也包括该对象的实例变量）消失了类变量可能还没有消失，分开存储便于管理）**。

值得注意的是，**Java允许通过实例来调用类变量（实例.类变量），由于实例并不持有这个类变量，实际上访问的还是该实例所属类的类变量，如果一个实例调用并修改类变量之后，就会导致该类的其他实例访问该类变量时得到的也是修改之后的值**。如下面代码所示：

```java
class Person {
	// 定义一个实例变量
	public String name;
	// 定义一个类变量
	public static int eyeNum;
}
public class PersonTest {
	public static void main(String[] args) {
		// 第一次主动使用Person类，该类自动初始化，则eyeNum变量开始起作用，输出0
		System.out.println("Person的eyeNum类变量值:" + Person.eyeNum);
		// 创建Person对象
		Person p = new Person();
		// 通过Person对象的引用p来访问Person对象name实例变量
		// 并通过实例访问eyeNum类变量
		System.out.println("p变量的name变量值是：" + p.name + "，p对象的eyeNum变量值是：" + p.eyeNum);
		// 直接为name实例变量赋值
		p.name = "孙悟空";
		// 通过p访问eyeNum类变量，依然是访问Person的eyeNum类变量
		p.eyeNum = 2;
		// 再次通过Person对象来访问name实例变量和eyeNum类变量
		System.out.println("p变量的name变量值是：" + p.name + "，p对象的eyeNum变量值是：" + p.eyeNum);
		// 前面通过p修改了Person的eyeNum，此处的Person.eyeNum将输出2
		System.out.println("Person的eyeNum类变量值:" + Person.eyeNum);
		Person p2 = new Person();
		// p2访问的eyeNum类变量依然引用Person类的，因此依然输出2
		System.out.println("p2对象的eyeNum类变量值:" + p2.eyeNum);
	}
}
```

##### 局部变量

局部变量根据定义形式可以分成如下三种：

- 形参：在定义方法签名时定义的变量。形参的作用域在整个方法中有效；
- 方法局部变量：在方法体内定义的局部变量。它的作用域从定义它地方开始，到方法结束时失效；
- 代码块局部变量：在代码块中定义的局部变量。这种局部变量的作用域从定义它地方开始，到代码块结束时失效。


与成员变量不同，局部变量除了形参以外，必须显示初始化。也就是说必须为方法局部变量和代码块局部变量指定初始值才能访问他们。在通过类（或对象）调用类方法（或实例方法）时，系统会在该被调用方法的栈区中为其形参分配内存，并将实参赋值给形参来完成其初始化。这意味着局部变量声明后，如果还没有为其指定一个值，那么系统不会为其分配内存，直到为局部变量显式赋值时，系统才会在其所在方法的栈内存中（与成员变量不同）为其分配内存，并为其执行初始化。

此外，Java允许局部变量名和成员变量名相同。如果局部变量名和成员变量名相同，则局部变量在其作用域中会覆盖成员变量，如果在这种情况下要访问被覆盖的成员变量，可以使用this（用于调用实例变量）或类名（用于调用类变量）来调用成员变量。如下面的代码所示：

```java
public class VariableOverrideTest {
	// 定义一个name实例变量
	private String name = "Java程序员";
	// 定义一个price类变量
	private static double price = 11000.0;
  
	// 主方法，程序的入口
	public static void main(String[] args) {
		// 类方法里的局部变量，局部变量覆盖成员变量
		int price = 6000.0;
		// 直接访问price变量，将输出price局部变量的值：60000.0
		System.out.println(price);
		// 使用类名作为price变量的限定，
		// 将输出price类变量的值：11000.0
		System.out.println(VariableOverrideTest.price);
		// 运行info方法
		new VariableOverrideTest().info();
	}
	public void info() {
		// 实例方法里的局部变量，局部变量覆盖成员变量
		String name = "PHP";
		// 直接访问name变量，将输出name局部变量的值："PHP"
		System.out.println(name);
		// 使用this来作为name变量的限定，
		// 将输出name实例变量的值："Java程序员"
		System.out.println(this.name);
	}
}
```

栈内存中的变量无须系统垃圾回收机制回收，往往随方法或代码块的结束而结束。由于局部变量只保存基本类型的值或对象的引用，因此局部变量所占的内存区域通常比较小。

#### 变量的使用规则

如果优先使用成员变量而不是局部变量，由于成员变量的生命周期比局部变量长，作用域也比局部变量广，就会加大内存的开销，降低程序的内聚性（程序中各模块之间私有数据隔离程度越高越好）。所以，尽量将一个变量定义成局部变量（除非定义为局部变量比定义为成员变量更占内存），同时使局部变量的作用范围尽可能的小。总之，使变量的生存周期越短越好、作用域越小越好。

在以下几种情况下考虑使用成员变量：

- 如果需要定义的变量是用于描述某个类或对象的固有信息的（如人的身高、体重）就应该定义为成员变量。如果这种固有信息对于所有实例都一样（如正常人的眼睛数量）就应该定义为类变量；如果这种固有信息对于每个实例可能都不相同（如人的身高、体重）就应该定义为实例变量；
- 如果某个信息需要在某个类的多个方法之间共享，则这个信息应该使用成员变量来保存。

### 封装

封装是面向对象的三大特征（另外两个是继承和多态）之一。现实世界中一个实体往往将自己内部信息以藏起来，通过自己本身特定的方式来与外界交流（比如，手机就是一种人们用来远距离沟通的工具）。**封装就是将对象的状态信息隐藏在该对象内部，外部程序无法直接访问该对象的内部信息，只能通过该对象提供的对外方法来间接访问和操作该对象的内部状态信息**。

封装时应考虑将对象的成员变量和实现细节隐藏起来而不允许外部直接访问，同时将方法暴露出来控制外部的进行安全合理的访问。良好的封装可以限制外部的不合理访问、可进行数据检查，保障对象的完整性、便于修改提供可维护性。

##### 访问控制符

Java提供了三个访问控制符：private、protected和public，分别代表了三个访问级别。另外还有一个不加任何访问控制符的访问级别，Java一共有四种访问级别，按访问的级别从小到大依次为：

private ---> *default* ---> protected ---> public

详细介绍如下：

- private(当前类访问权限)：如果类里的一个成员（包括成员变量、方法和构造器等）使用private访问控制符来修饰，则这个成员只能在当前类的内部被访问。很显然，这个访问控制符用于修饰成员变量最合适，使用它来修饰成员变量就可以把成员变量隐藏在该类的内部；
- default(包（package）访问权限)：如果类里的一个成员（包括成员变量、方法和构造器等）或者一个外部类不使用任何访问控制修饰，就称它为包访问权限的，default访问控制符修饰的成员或外部类可以被相同包下的其他类访问；
- protected（子类访问权限）：如果一个成员（包括成员变量、方法和构造器等）使用protected访问控制符修饰，那么这个成员既可以被同一个包中的其他类访问，也可以被不同包中的**子类**访问。在通常情况下，如果使用protected来修饰一个方法，通常是希望其子类来重写这个方法；
- public（公共访问权限）：这是一个最宽松的访问控制级别，如果一个成员（包括成员变量、方法和构造器等）或者一个外部类使用public访问控制符修饰，那么这个成员或外部类就可以被所有类访问，不管访问类和被访问类是否处于同一个包中，是否具有父子继承关系。

总结如下表所示：

|       | private | *default* | protected | public |
| ----- | :-----: | :-------: | :-------: | :----: |
| 同一个类中 |    √    |     √     |     √     |   √    |
| 同一个包中 |         |     √     |     √     |   √    |
| 子类中   |         |           |     √     |   √    |
| 全局范围内 |         |           |           |   √    |

通常：

- **局部变量仅在其所在方法体和代码块中有效，不可能被其他类访问，所以局部变量不能使用任何访问控制符修饰**；
- 外部类没有处于任何类的内部，也没有处于其他外部类的内部或其他外部类的子类的内部，故外部类只能使用public或default修饰。

> 注意：如果一个Java源文件中没有public修饰的类，那么该Java源文件的文件名可以是任何合法的文件名。但是如果一个Java源文件中有一个public修饰的类，那么该Java源文件必须与该类同名。

访问控制符的使用原则：

- 类里的绝大多数成员变量都应该考虑使用private修饰，只有一些static修饰的、类似全局变量的成员变量才考虑使用public修饰。除此之外，有些方法如果只是用于辅助其他方法来实现某些功能，这些方法称为工具方法，工具方法也应该使用private修饰；
- 如果某个类主要用作其他类的父类，那么该类里包含的大多数方法可能希望子类进行重写，而不想被外部直接调用，则应该使用protected修饰这些方法；
- 希望暴露出来给其他类调用的方法应该使用public修饰。因此，类的构造器应该使用public修饰，从而使其他类可以通过new关键字来创建该类的实例（单例模式和工厂模式除外）。

##### 包以及导包语句

Java允许使用包（package）将类组织起来，以方便组织代码，并将自己的代码与别人提供的代码库分开管理。 标准的Java 类库分别在多个包中， 如java.lang、java.util 和java.net，所有标准的 java 包都处于java 和 javax 包层次中。 使用包的主要原因是确保类名的唯一性，且为了保证包名的绝对唯一，Oracle 公司建议将公司的因特网域名以逆序的形式作为包名。

如果希望将一个类放在指定的包下，应在该类的源文件的第一个非注释行使用以下格式为该类指定其所在的包名：

```java
package packagename;
```

一个类的全限定类名（即类的全名）因该包含其所在的包名以及类名，比如：java.lang.String。

应该在编译Java源文件时指定生成.class文件的位置。如果有这样一个指定了包名的类：

```java
package rosydawn;
public class {
  public static void main(String[] args) {
    System.out.println("Hello world!");
  }
}
```

使用如下编译命令编译Java源文件：

```powershell
javac -d . HelloWorld.java
```

javac命令的-d选项用于指定生成.class文件的位置，“.”表示当前目录。执行上面的编译命令后发现，当前目录下并没有HelloWorld.class文件，HelloWorld.class文件存放在了当前目录下的rosydawn目录下。其实，**Java规定：位于包中的类，在文件系统中也必须有与包层级相同的目录结构。Java的包机制避免了同一个目录下的同名类发生冲突**。如果编译时不使用-d选项，编译器会在在不管类的包声明的情况下在当前目录下生成.class文件。如果.class文件没有相应的包文件结构，将会导致同名类的冲突。所以，建议手动编译时使用-d选项，即使想在当前目录下生成.class文件也应该通过“javac -d .”指定为当前目录。

虚拟机在装载带包名的类时，会先搜索CLASSPATH环境变量指定的目录，然后在这些目录中按照包层次对应的目录结构去查找.class文件。同一个包中的类不用位于同一个目录下，只要让CLASSPATH环境变量里包含这两个类的.class文件所在的目录即可。不仅如此，也因该将Java源文件放在与包名一直的目录结构中（可以解决源文件的名称冲突）。

另外，为了避免混乱，应该将源文件和.class文件分开存放，但两者都应该有相同的包层次的目录结构。



一个类可以使用所属包中的所有类，以及其他包中的public修饰的类。我们可以采用以下两种方式访问另一个包中public修饰的类：

- 在类名之前添加完整的包名。如：

  ```java
  java.util.Date today = new java.util.Date();
  ```

- 更简单的方式是使用import语句。









#### 继承

子类的对象拥有父类的全部属性与方法，称作子类对父类的继承。

- Java中父类可以拥有多个子类，但是子类只能继承一个父类，称为单继承。
- 继承实现了代码的复用。
- Java中所有类都是通过直接或者间接地继承了java.lang.Object类得到的。换言之Object是Java中所有类的父类或者超类。
- 子类不能继承父类中访问权限是private的成员变量和成员方法。
- 子类可以重写父类的方法，以及命名与父类同名的成员变量。

Java中通过**super**来实现对父类成员的访问，super用来引用当前对象的父类。super的使用有三种情况：

- 访问父类被隐藏的成员变量，如：super.variable;
- 调用父类中被重写的方法，如：super.Method([paramlist])；。
- 调用父类的构造方法，如：super([paramlist]);。

#### 多态

对象的多态性是指在父类定义的属性或者方法被子类继承之后，可以具有不同的数据类型或表现出不同行为。这使得同一个属性或者方法在父类及其各个子类中具有不同的语义。例如：“几何图形”的“绘图”方法，“椭圆”和“多边形”都是“几何图形”的子类，其“绘图”的方法不一样。

Java的多态性体现在两个方面：由方法重载实现的静态多态性（编译时多态）和方法重写实现的动态多态性（运行时多态）。

- 编译时多态：在编译阶段，具体调用哪个被重载的方法，编译器会根据参数的不同静态（参数的类型、参数的顺序、参数的个数）确定其相应的方法。（比如在构造方法和一般方法里面）；子类重写父类的方法。

- 运行时多态：由于子类继承了父类的所有的属性（私有属性除外），所有的子类对象可以作为父类对象使用。程序中凡是使用父类对象的地方，都可以用子类对象来代替。一个对象可以通过引用子类的实例来调用子类的方法。（比如Dog类和Cat类是Animal的子类，我们定义一个方法void letSleep(Animal animal){animal.sleep();}，然后sleep这个父类中的方法，分别被子类重写。那么我们向letSleep这个方法分别传入dog（Dog类的实例）或者cat（Cat类的实例），那么该方法就会分别调用dog中的sleep()方法和cat中的sleep()方法）。

  #### 重载 (overload)

- 方法重载是让类以统一的方式处理不同数据类型的手段。

- 一个类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法。

- 返回值类型可以相同也可以不同，无法以返回值类型作为重载方法的区分标准。

#### 重写 (override)

- 子类对父类的方法进行重新编写。如果在子类中的方法与其父类有相同的方法名、返回类型和参数表，我们说该方法被重写。
- 如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。
- 子类函数的访问修饰权限不能低于父类的。







### 抽象类

如果一个类只是描述某一类对象具有某一功能，但是却没有具体定义该功能如何实现，那么该类就是一个抽象类。比如描述人类的Human类，该Human类可能描述了人类具有工作的能力，却没有定义具体的某类人如何工作（可能是厨师做饭、作家写作、程序员编程等）。抽象类中这种描述某种功能的方法称为抽象方法。

抽象类和抽象方法特点如下：

- 抽象类的定义比普通类的定义增加了abstract 关键字修饰。抽象方法也使用abstract关键字来定义。抽象方法没有方法体；
- 抽象类不一定有抽象方法，有抽象方法的类一定是抽象类；
- 抽象类不能被实例化（即使抽象类没有抽象方法），因为它不是具体的，所以无法通过new关键字来创建抽象类的实例。抽象类只能通过多态的方式，由其具体的子类来实例化。抽象方法的声明是一条**带英文分号**的语句，没有方法体；
- 抽象类的成员包括**成员变量**（既可以是变量，也可以是常量）、**构造器** （抽象类构造器主要用来被子类构造器调用来进行父类中数据的初始化）、**抽象方法**（也可以没有抽象方法）、**非抽象方法**（用于被子类继承达到代码复用的目的）、**初始化块**、**内部类**（接口、枚举）**5种成员**；
- 含有抽象方法的类（直接定义一个含有抽象方法的抽象类，或继承了一个抽象类但没有实现抽象父类的所有抽象方法，或实现一个接口但没有实现接口的所有抽象方法）只能被定义成抽象类。

如果说类是某些具有相同特征对象的抽象，那么抽象类则是对某些具有相同特征的类（不同的类对这些相同特征具有不同的实现）的抽象。抽象类体现了一种模板模式的设计思想，这种模板的存在避免了子类实现的随意性，子类在保留抽象父类数据的基础上进行扩展和改造。

**注意**：抽象方法和空方法是不同的概念：抽象方法没有方法体，如“public abstract void work();”是一个抽象方法定义，它是一条带分号的语句；而空方法有方法体，只是方法体为空，什么都不做。如“public void work() {}”是一个空方法。

下面定义一个抽象类：

```java
public abstract class Shape {
	{
		System.out.println("执行Shape的初始化块...");
	}
	private String color;

	// 定义一个计算周长的抽象方法
	public abstract double calPerimeter();

	// 定义一个返回形状的抽象方法
	public abstract String getType();

	// 定义Shape的构造器，该构造器并不是用于创建Shape对象，
	// 而是用于被子类调用
	public Shape() {
	}

	public Shape(String color) {
		System.out.println("执行Shape的构造器...");
		this.color = color;
	}

	// 省略color的setter和getter方法
	public void setColor(String color) {
		this.color = color;
	}

	public String getColor() {
		return this.color;
	}
}
```

抽象类不能创建实例，只能当做父类被子类继承。

继承抽象类的实例：

```java
public class Triangle extends Shape {
	// 定义三角形的三边
	private double a;
	private double b;
	private double c;

	public Triangle(String color, double a, double b, double c) {
		super(color);
		this.setSides(a, b, c);
	}

	public void setSides(double a, double b, double c) {
		if (a >= b + c || b >= a + c || c >= a + b) {
			System.out.println("三角形两边之和必须大于第三边");
			return;
		}
		this.a = a;
		this.b = b;
		this.c = c;
	}

	// 重写Shape类的的计算周长的抽象方法
	public double calPerimeter() {
		return a + b + c;
	}

	// 重写Shape类的的返回形状的抽象方法
	public String getType() {
		return "三角形";
	}
}
```

关于abstract关键注意以下几点：

- final修饰的类不能被继承，final修饰的方法不能被重写，故抽象类和抽象方法不能用final修饰；
- abstract只能用于抽象类和抽象方法，不能用于修饰成员变量、局部变量和构造器；
- static不能用于修饰抽象方法，即没有所谓的类抽象方法。如果static能用于修饰抽象方法，那么通过类调用该方法时会出现错误（无法调用一个没有方法体的方法）。虽然abstract和static不能同时修饰抽象方法，但abstract和static可以用来共同修饰内部类；
- abstract修饰的抽象方法被子类重写才有意义，故abstract不能使用和private一起用来修饰方法，应该使用protected修饰。











