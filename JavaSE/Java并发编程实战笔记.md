---
typora-copy-images-to: appendix
typora-root-url: appendix
---

## 第一部分 线程安全性
**编写线程安全的代码实质上就是控制对共享的、可变状态的访问**。

通俗地说，一个对象的状态就是它的数据，即存储在表示状态的field（实例的field或静态的field）中，对象的状态还包括其他附属对象的field。一个对象的状态包含了任何会影响它外部可见性的数据；所谓共享，就是一个变量会被多个线程访问；所谓可变，是指变量的值在其生命周期中是可以改变的，而不是final修饰的不可变field（不可变的field因为其是不可变的，所以总是线程安全的）。一个对象是否线程安全取决于它是否会被多个线程访问，且其中某个线程会修改它的状态变量，这就需要使用同步来协调对该变量的访问。

一开始就将一个类设计成线程安全的（利用封装、不可变性、以及明确的不可变约束等面向对象技术），比在后期重新修复它更容易。

### 无状态的一定是线程安全的
无状态的对象不包含任何field，也不包含任何对其他类中field的引用。计算过程中的任何时刻，这种对象的临时状态仅存在于线程栈上的局部变量中，并只能由正在执行的线程访问。多个线程之间并不共享状态（因为没有状态可以共享），它们如同访问不同的实例，互不影响，所以无状态的是线程安全的。

### 竞争条件
当执行的正确性取决于多个线程执行的先后顺序时，就会发生竞争条件。最常见的竞争条件类型就是“先检查后执行”(check-then-act)操作，即使用一个可能过期（检查到结果到执行操作的这段时间里检查的结果可能已经发生了变化）的观测结果来决定下一步的操作。反应在编程上就是数据竞争（data race），比如，多个线程读写同一个变量。

### 原子性操作
原子性操作是指一个单独的、不可分割的操作。可分割的操作都不是原子性操作，比如，自增操作不是原子性地操作，它包含3个独立的操作（比如++count，获取count的当前值，将其加1，再将加1的结果赋给count，这是连续读-改-写的三步操作）。前面提到的先检查后执行操作也不是原子性操作。

原子操作是指一个操作对于所有操作（包括它自己）来说，要么该操作全部执行完毕，要么该操作一点都没有执行，那么，该操作与所有操作互为原子操作。

为了避免竞争条件，必须阻止其他线程访问当前线程正在修改的共享可变变量，确保其他线程查看或修改这个变量时，必须是在该线程开始之前或完成之后，而不能在该线程执行的过程中。这就要求这个**线程对共享可变变量的操作对于其他线程必须是原子性的操作。可以将线程对共享可变变量的复合操作封装成一个原子操作**。

线程安全的定义要求多个线程的交替操作不会破坏不变约束。当一个不变约束涉及多个变量时，变量之间就不是彼此独立的（某个变量的值制约着其他变量的值）。因此更新一个变量的时候，要在同一次的原子操作中更新被该变量约束的其他变量。总之，**为了保护状态的一致性，要在单一的原子操作中更新所有相互关联的状态变量**。

### 内部锁
Java提供了**强制原子性的内置锁机制：synchronized块**。一个synchronized块有两部分：**锁对象的引用，以及这个锁所保护的代码块**。synchronized关键字有两种形式：synchronized修饰的代码块（称为同步代码块）和synchronized修饰的方法（可以为实例方法或静态方法，称为同步方法）。synchronized修饰的实例方法的锁就是调用该方法的对象本身（即this），synchronized修饰的静态方法从该方法所在类的Class对象上获得锁。

每个Java对象都可以隐式地作为一个同步锁，这些内置的锁被称为**内部锁**（intrinsic locks）或**监视器锁**（monitor locks）。执行线程只能通过进入内部锁保护的代码块或方法来获得该内部锁，在进入同步代码时会自动获得锁，退出（正常退出或异常退出）时自动释放锁。用锁来协调访问变量时，每次访问变量都需要用同一个锁。之所以每个对象都有一个内置锁，只是为了免去显示地创建锁对象。

**内部锁是一种互斥锁**（mutual exclusion lock，也称为mutex），即某一个时刻最多只有一个线程可以拥有内部锁。比如，当线程A尝试获取线程B持有的内部锁时，线程A必须等待或阻塞，直到线程B释放了这个内部锁，如果线程B不释放锁，那么A就永远等待下去。

**内置锁是可重入的**，意味着一个线程可以再次获取它已占有的锁。 重进入的实现是为每个锁关联一个**请求计数器**和一个**占有它的线程**。当计数器为0时，认为锁是未被占有的。线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1。同一个线程每次请求该锁时，计数器将会递增，每次占用线程退出同步块时，计数器将会递减，直到计数器为0，锁被释放。重进入方便了锁行为的封装，因此简化了面向对象并发代码的开发。假如需要对一个集合的遍历操作进行同步，可重入性保证了每次遍历时不用重新获取锁而影响性能。如果没有可重入性，那么子类覆写父类中的一个synchronized方法并调用父类的该方法就会发生死锁。

### 使用锁保护共享状态
- 使用synchronized块包装操作共享状态的代码可以保证这些操作是原子性的操作，以避免竞争条件、保证安全。
- 然而，过度使用synchronized封装代码会导致活跃度（liveness）和性能问题，应该在保证共享状态被原子性操作前提下，尽可能地从synchronized块中分离出那些耗时且不影响共享状态的操作。
- 请求与释放锁是需要开销的，所以将synchronized块分解地过于琐碎是不合理的，即使这样做是为了获得更好的原子性。决定synchronized块的大小需要权衡各种设计要求，包括简便性、安全性、以及性能。有时候简便性与性能会有冲突，但通常可以从中找到一个平衡点。有些耗时操作（比如建立网络连接或I/O操作）难以快速完成，执行这些操作期间不要占有锁。
- 同时，仅仅使用synchronized块包装复合操作是不够的，

## 第二部分 共享对象

### 重排序（reordering）
在并发程序中，程序员会特别关注不同进程或线程之间的数据同步，特别是多个线程同时修改同一变量时，必须采取可靠的同步或其它措施保障数据被正确地修改，这里的一条重要原则是：**不要假设指令执行的顺序，你无法预知不同线程之间的指令会以何种顺序执行**。

但是在单线程程序中，通常我们容易假设指令是顺序执行的，否则可以想象程序会发生什么可怕的变化。理想的模型是：各种指令执行的顺序是唯一且有序的，这个顺序就是它们被编写在代码中的顺序，与处理器或其它因素无关，这种模型被称作**顺序一致性模型**，也是**基于冯·诺依曼体系的模型**。当然，这种假设本身是合理的，在实践中也鲜有异常发生，但事实上，**没有哪个现代多处理器架构会采用顺序一致性模型，因为它实在是太低效了。而在编译优化和CPU流水线中，几乎都涉及到指令重排序**。

重排序通常是**在没有同步的情况下，编译器、处理器和运行时**为了**优化程序性能**而采取的**对指令进行重新排序执行**。分为**编译器优化的重排序、处理器指令级的并行重排序、内存系统的重排序**。指令重排序存在的意义在于：JVM能够根据处理器的特性（CPU的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合CPU的执行特点，最大限度的发挥机器的性能。

#### 编译器优化的重排序

编译期重排序的典型就是**通过调整指令顺序，在不改变程序语义的前提下，尽可能减少寄存器的读取和存储次数，充分复用寄存器的存储值**。

假设第一条指令计算一个值赋给变量A并存放在寄存器中，第二条指令与A无关但需要占用寄存器（假设它将占用A所在的那个寄存器），第三条指令使用A的值且与第二条指令无关。那么如果按照顺序一致性模型，A在第一条指令执行过后被放入寄存器，在第二条指令执行时A不再存在，第三条指令执行时A重新被读入寄存器，而这个过程中，A的值没有发生变化。通常编译器都会交换第二和第三条指令的位置，这样第一条指令结束时A存在于寄存器中，接下来可以直接从寄存器中读取A的值，降低了重复读取的开销。

#### 处理器指令级的并行重排序

现代CPU几乎都采用流水线机制（交替执行各线程）加快指令的处理速度，一般来说，一条指令需要若干个CPU时钟周期处理，而通过流水线并行执行，可以在同等的时钟周期内执行若干条指令，具体做法简单地说就是**把指令分为不同的执行周期，例如读取、寻址、解析、执行等步骤，并放在不同的元件中处理**，同时在执行单元EU中，功能单元被分为不同的元件，例如加法元件、乘法元件、加载元件、存储元件等，可以进一步实现不同的计算并行执行。流水线架构决定了指令应该被并行执行，而不是在顺序一致性模型中所认为的那样。重排序有利于充分使用流水线，进而达到超标量的效果。

**确保顺序性**
**尽管指令在执行时并不一定按照我们所编写的顺序执行，但毋庸置疑的是，在单线程环境下，指令执行的最终效果应当与其在顺序执行下的效果一致，否则这种优化便会失去意义**。通常无论是在编译期还是运行期进行的指令重排序，都会满足上面的原则。

**as-if-serial语义**
as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。**为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果**。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。

#### 内存系统重排序

计算机系统中，为了尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能。其模型如下图所示。
![cpu reorder](/cpu reorder.jpg)
在这种模型下会存在一个现象，即**缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步的。这导致在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的**。从程序的视角来看，就是在同一个时间点，各个线程所看到的共享变量的值可能是不一致的。
有的观点会将这种现象也视为重排序的一种，命名为**“内存系统重排序”**。因为这种内存可见性问题造成的结果就好像是内存访问指令发生了重排序一样。

**Java存储模型中的重排序**
在Java存储模型（Java Memory Model, JMM）中，重排序是十分重要的，特别是在并发编程中。JMM通过happens-before法则保证顺序执行语义，如果想要让执行操作B的线程观察到执行操作A的线程的结果，那么A和B就必须满足happens-before原则，否则，JVM可以对它们进行任意排序以提高程序性能。

根据Java内存模型中的规定，可以总结出以下几条happens-before规则<sup>8</sup>。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。

- 程序次序法则：线程中的每个动作A都 happens-before 于该线程中的每一个动作B，其中，在程序中，所有的动作B都出现在A之后。
- 监视器锁法则：对一个监视器锁的解锁 happens-before 于每一个后续对同一监视器锁的加锁。
- volatile变量法则：对volatile域的写入操作 happens-before 于每一个后续对同一个域的读写操作。
- 线程启动法则：在一个线程里，对 Thread.start 的调用会 happens-before 于每一个启动线程中的动作。
- 线程终结法则：线程中的任何动作都 happens-before 于其他线程检测到这个线程已经终结、或者从Thread.join 调用中成功返回，或 Thread.isAlive 返回 false。
- 中断法则：一个线程调用另一个线程的 interrupt happens-before 于被中断的线程发现中断（通过抛出 InterruptionException 、或者调用 isInterrupted 和 interrupted）。
- 终结法则：一个对象的构造函数的结束 happens-before 于这个对象 finalizer 的开始。
- 传递性：如果 A happens-before 于 B，且 B happens-before 于 C，则 A happens-before 于 C。

Happens-before关系只是对Java内存模型的一种近似性的描述，它并不够严谨，但便于日常程序开发参考使用，关于更严谨的Java内存模型的定义和描述，请阅读JSR-133原文或Java语言规范章节17.4。

### Java内存模型（JMM）
Java的目标是成为一门平台无关性的语言，即Write once, run anywhere. 但是不同硬件环境下指令重排序的规则不尽相同。例如，x86下运行正常的Java程序在IA64下就可能得到非预期的运行结果。为此，JSR-133规范制定了**Java内存模型（Java Memory Model, JMM)**，旨在提供一个统一的可参考的规范，屏蔽不同平台的差异性。从Java 5开始，Java内存模型成为Java语言规范的一部分。

Java内存模型如下图所示：

![jmm](/jmm.jpg)

Java内存模型的主要目标：定义在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

>注意：上边的变量指的是共享变量（实例字段、静态字段、数组对象元素），不包括线程私有变量（局部变量、方法参数），因为私有变量不会存在竞争关系。

说明：
- **所有共享变量存于主内存（main memory）**。
- **每一条线程都有自己的工作内存（working memory）**。
- **工作内存中保存了被该线程使用到的变量的主内存副本**。
- **线程对变量的操作都要在工作内存中进行，不能直接操作主内存**。
- **不同的线程之间无法直接访问对方的工作内存中的变量**。
- **不同线程之间的变量的传递必须通过主内存**。

主内存对应于Java堆中的对象实例数据部分，工作内存对应于栈中的部分区域（注意：主内存与工作内存只是一个概念，与堆栈内存没有关系，这里的类比只是帮助理解）。

**共享变量**：一个变量在多个线程的工作内存都存在副本，这个变量就是共享变量。
**可见性**：多线程环境下，一个线程修改共享变量，能够及时真正地被其他线程所感知。可见性的实现依赖于原子性操作；反之，如果修改共享变量的复合操作不具备原子性，由于共享变量的值没有及时在主内存中更新，其他线程不能及时获取主内存中已更新的值，就会导致内存不可见性。
**共享变量的可见性实现原理**：一个线程修改共享变量后，立刻更新主内存，然后其他线程立刻从主内存把值更新到该线程的工作内存中。

### synchronized实现可见性
获取锁后，清空工作内存中共享变量的值，从主内存读取最新的值，执行完代码后，在解锁前将工作内存中共享变量的值更新到主内存中，不管这个变量是否被声明为volatile。

### volatile实现可见性
**最低限度的安全性**（out-of-thin-air safety）：当一个线程在未同步时可能读取到一个过期的变量值，但可以最低限度地保证该变量值是某个线程产生的值，而不是凭空产生的。最低限度的安全性应用于所有变量，除了没有声明为volatile的64位数值变量（long和double）。

**非原子的64位操作**：Java存储模型要求获取和存储操作都必须是原子的，但是对于非volatile修饰的64为数值变量，JVM允许将64位的读写划分成两次32位操作（这针对的是32位处理器，JVM规法完成时，许多主流处理器架构还不能有效的支持64位原子操作）。如果对共享、可变的long和double类型的数据的读写发生在不同的线程，就可能会发生安全问题。

volatile关键字可以确保对其所修饰的变量的更新以可预见的方式告知其他的线程。当一个field声明为volatile类型后，编译器和运行时会监视这个变量：它是共享在主内存中，没有缓存在寄存器或者缓存在对其他处理器隐藏的地方（也牺牲了性能）。由于主内存是被所有线程所共享的，所以读取一个volatile类型的变量时总会返回一个某一线程所写入的最新值。

访问volatile变量的操作不会加锁，也就不会引起执行线程的阻塞，说明volatile变量相对于synchronized而言，只是轻量级的同步机制。从内存可见性角度来看，写入volatile变量就像退出同步块，读取volatile变量就像进入同步块。

volatile实现可见性是通过加入**内存屏障和防止局部指令重排序**来实现。对volatile变量执行写操作时，会在写操作后加一条**store屏障指令**，会把CPU中将要写入缓存的数据强制刷新到主内存，还能防止处理器把volatile前的变量重排序到volatile之后。对volatile变量执行读操作时，会在读操作前加一条**load屏障指令**。在读取时强制从主内存中读取，而不是从工作内存的缓存中；当该值发生变化时，强制线程把最新的值刷新到主内存中。

**内存屏障**

内存屏障（Memory Barrier，有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。对于一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：

- lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
- unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
- write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

- 不允许read和load、store和write操作之一单独出现
- 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

Java编译器也会根据内存屏障的规则禁止重排序。内存屏障可以被分为以下几种类型：

- LoadLoad屏障：对于这样的语句`Load1; LoadLoad; Load2`，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
- StoreStore屏障：对于这样的语句`Store1; StoreStore; Store2`，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
- LoadStore屏障：对于这样的语句`Load1; LoadStore; Store2`，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
- StoreLoad屏障：对于这样的语句`Store1; StoreLoad; Load2`，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。

有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。

但是我们并不推荐过度依赖volatile变量所提供的可见性，因为依赖volatile变量来控制可见性的代码比使用锁的代码更加脆弱，也更加难以理解。只有当volatile变量能够简化实现和同步策略的验证时，才使用它们。当在验证数据正确性之前必须推断其可见性时，应该避免使用volatile变量。**正确使用volatile变量的方式包括：用于确保它们所引用的对象的可见性，或者用于标识重要声明的周期事件的发生（比如用作初始化、完成、中断、关闭或状态等事件的标记）**。一个典型的应用就是检查循环状态标记，以确定是否退出一个循环。

只有满足了下面所有的标准后，才可以使用volatile类型的变量：
- 写入该变量时并不条件性地依赖该变量的当前值，或者能够确保只有单一的线程修改该变量的值。
- 该变量不需要与其他状态变量共同组成不变约束。
- 而且访问该变量时没必要再加锁。

### synchronized和volatile比较
- synchronized需要加锁，volatile不需要加锁，volatile不会阻塞线程执行效率高。对于当今大多数处理器架构而言，读取volatile变量的开销只比读取非volatile变量略高一些。
- synchronized保证可见性和原子操作，volatile保证可见性而不保证原子操作（比如不能使自增操作原子化）。volatile也不能用来修饰final类型的变量。

在保证可见性方面，锁（包括显式锁、对象锁）以及对原子变量的读写都可以确保变量的可见性。但是实现方式略有不同，例如同步锁保证得到锁时从主内存中重新读取数据并刷新工作内存中的缓存，释放锁时将数据写回主内存中以保证数据可见，而volatile变量干脆是直接读写主内存中的数据。

总之，不管采用哪种同步方式，都必须对多线程操作共享变量进行同步操作。如果读取共享变量时没有使用同步，但该值可能已经被其他线程修改过而过期（即**脏读，DirtyRead**），这样就无法保证可见性了。就有可能产生。

### 发布和逸出
发布（publishing）一个对象的意思是使它能够被当前范围之外的代码所使用。比如：

- 将一个引用存储到其他代码可以访问的地方。
- 在一个非私有的方法中返回引用。
- 也可以把一个引用传递到其他类的方法中。

多数情况下，我们需要确保一个对象及其内部状态不被暴露（publish），而有时候我们又的确需要发布一个对象（如果该发布对象含有其他对象的引用，可能还会发布其他对象），但是：

- 在多线程访问该对象时可能需要同步。
- 如果变量发布了内部状态又会危及封装性，使程序难以稳定。
- 如果发布对象时它还未完成初始化，同样会危及线程安全。一个对象尚未准备好就发布，这种现象称为**逸出（escape）**。

### 安全发布

#### 线程封闭

#### 不可变性
**不可变对象永远是线程安装的，因为它的状态不可变**。可以放心地共享和发布不可变对象。不可变对象并不是简单地将对象的所有field都声明为final类型，**所有field都是final类型的对象也不一定是不可变对象，因为final修饰的field可能是指向可变对象的引用**。只有满足了以下状态的对象才是不可变的：

- 该对象的状态不能在创建后再被修改。
- 所有的field都是final修饰的。
- 该对象被正确创建（在创建完成之前没有出现this逸出）。

不可变对象可以在没有额外同步的情况下安全地用于任意线程，甚至发布它们时也不需要同步，因为即使没有额外的同步，final修饰的field也可以被安全的访问。然而，如果final修饰的field指向可变对象，那么访问这些对象的状态仍然需要同步。

#### 安全发布模式
如果一个对象是可变的，它就必须安全地发布，通常发布线程与消费线程都必须同步化。该可变对象的引用以及该可变对象的状态必须同时对其他线程可见。一个正确创建的可变对象可以通过以下条件安全地发布：

- 通过静态初始化器初始化该对象的引用。
- 将它的引用存储到volatile类型的field或AtomicReference。
- 将它的引用存储到正确创建的对象的final类型的filed中。
- 或者将它的引用存储到由锁正确保护的field中。

线程安全的集合的内部同步，意味着将对象置入这些集合（如Hashtable、synchronizedList、ConcurrentHashMap等）的操作遵守了上面最后一条要求。其他交互机制（比如Future和Exchanger）同样创建了安全发布。
通常，以最简单和最安全的方式发布一个被静态创建的对象，就是使用静态初始化器：
```java
public static Holder holder = new Holder(20);
```
静态初始化器由JVM在类的初始化阶段执行，由于JVM内在的同步，该机制确保了以这种方式初始化的对象可以被安全地发布。

#### 高效不可变对象
如果一个可变对象发布后不会被修改，这样的对象称为**高效不可变对象**。这些对象发布后程序只需简单地把它们当作不可变对象，用高效不可变对象可以简化开发，并且减少同步的使用，还会提高性能。任何线程都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象。比如，如果Date值在置入同步的synchronizedMap中就不会改变，那么，访问这些Date值就不再