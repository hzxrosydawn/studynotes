---
typora-copy-images-to: ..\..\graphs\photos
typora-root-url: ..\..\graphs\photos
---

### 文件系统概述

**文件系统（File System）**是操作系统中负责管理和存储文件信息的软件机构，用于向用户提供底层数据访问。它将设备中的空间划分为特定大小的块（或称为簇），一般每块 512 字节，一个块可能由多个扇区组成。数据存储在这些块中，大小被修正为占用整数个块，由文件系统软件来负责将这些块组织为文件和树形目录，并记录哪些块被分配给了哪个文件，以及哪些块没有被使用。文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备实际使用数据块的概念，用户使用文件系统来保存数据时不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。

文件系统是数据的组织者和提供者，并不一定只在特定存储设备上出现，实际上文件系统可能仅仅是一种访问数据的界面而已，实际的数据是通过网络协议（如 NFS、SMB、9P 等）提供的或者在内存上，甚至可能根本没有对应的文件（如 PROC 文件系统）。严格地说，文件系统是一套实现了数据的存储、分级组织、访问和获取等操作的抽象数据类型（Abstract data type）。

分区建立后，在将数据存储到分区之前，你必须用某种文件系统对其进行格式化，这样操作系统才能使用它。创建文件系统的操作就是平时我们所说的格式化。格式化是指对磁盘或磁盘中的分区（partition）进行初始化的一种操作，这种操作通常会导致现有的磁盘或分区中所有的文件被清除。

> 格式化通常分为**低格（低级格式化）和高格（高级格式化）**。
>
> - 低级格式化（Low-Level Formatting）又称低层格式化或物理格式化（Physical Format），对于部分硬盘制造厂商，它也被称为初始化（initialization）。大多数的硬盘制造商将低级格式化（Low-Level Formatting）定义为**创建硬盘扇区使硬盘具备存储能力的操作**。
> - 高级格式化又称逻辑格式化，即**创建文件系统的过程**。高格是根据用户选定的文件系统在磁盘的特定区域写入特定数据，以初始化磁盘或磁盘分区、清除原磁盘或磁盘分区中所有文件的一个操作。高级格式化包括对主引导记录（MBR）中分区表相应区域的重写，根据用户选定的文件系统在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间以便用户使用该分区管理文件。
> - **低格在硬盘出厂时已经完成。如果没有特别指明，对硬盘的格式化通常是指高格**。

下图为一个全新的、未使用的磁盘驱动器的一种形象表示。

![unused-drive](G:/graphs/photos/unused-drive.png)

要在磁盘驱动器中保存数据，则首先需要格式化该磁盘驱动器。格式化（通常称“ 生成文件系统” ）是向驱动器
中写入信息，在未格式化驱动器中为空白空间建立顺序。下图表示一个有文件系统的磁盘驱动器。

![formatted-drive](G:/graphs/photos/formatted-drive.png)

如上图所示，文件系统所指派的顺序涉及了一些折衷方案：

- 驱动器中的一**小部分可用空间被用来存储与文件系统有关的数据**，这可以被视作额外部分。
- **文件系统将剩余的空间分成小的一定大小的片段。在 Linux 中，这些片段就是块**。

> 注：没有单一、通用的文件系统。不同的文件系统会彼此不兼容，也就是说，支持某一文件系统（或者相关的文件系统类型）的操作系统可能不支持另外一种文件系统。比如 Windows 不支持 ext4 等日志文件系统，而 Red Hat Enterprise Linux 就支持很多文件系统（包括许多被其他操作系统使用的文件系统），这就使得在不同文件系统之间的数据交换变得容易了。

在磁盘中写入文件系统只是第一步。这个进程的目的实际上是要保存和检索数据。下图显示了写入数据后的磁盘驱动器：

![used-formatted-drive](G:/graphs/photos/used-formatted-drive.png)

某些之前的空数据块现在也存放着数据。然而，只看这个框图，我们不能确认这个磁盘中有多少个文件系统。这有可能是一个，也有可能是多个，因为所有的文件都使用至少一个数据块，而有些文件则使用多个块。另外一个值得注意的地方是，已经被使用的块不一定组成连续的空间；未使用的和已使用的块可以散布排列。这被称作碎片。当尝试调整现存分区的大小时，碎片会对其产生影响。

和大多数与计算机相关的技术一样，与磁盘驱动器刚发明时相比，文件系统已经有了很大的变化。特别是保存信息的容量变得越来越大。同时额外的容量让使用磁盘驱动器的方法发生了根本改变。

生活中我们所说的磁盘格式就是指文件系统。不同的操作系统所使用的文件系统也不同。

### Windows 系统支持的文件系统

| Windows                                                      | FAT12/FAT16 | FAT32/VFAT | FAT64/exFAT | NTFS      |
| ------------------------------------------------------------ | ----------- | ---------- | ----------- | --------- |
| Windows 3.x 或更早、（MS-DOS 6.22）、（PC-DOS 7.0）          | 可读/可写   | 不支持     | 不支持      | 不支持    |
| Windows 95                                                   | 可读/可写   | 不支持     | 不支持      | 不支持    |
| Windows 95（OSR2以后）、Windows 98（含SE）、ME               | 可读/可写   | 可读/可写  | 不支持      | 不支持    |
| Windows NT                                                   | 可读/可写   | 不支持     | 不支持      | 可读/可写 |
| 2000、Windows XP、Windows Vista、Server 2003、Server 2008 (R2)、Windows 7、Windows 8、Server 2012 (R2)、Windows 8.1、Windows 10 | 可读/可写   | 可读/可写  | 可读/可写   | 可读/可写 |

> 注意：除非 NT 安装了 FAT32 For Windows NT 4.0，否则 NT 是不支持 FAT32。

#### FAT16

对电脑老手而言，对这种硬盘分区格式是最熟悉不过了它**采用 16 位的文件分配表，能支持的最大分区为 2 GB**，是曾经应用最为广泛和获得操作系统支持最多的一种磁盘分区格式，几乎所有的操作系统都支持这一种格式，从 DOS、Win 3.x、Win 95、Win 97 到 Win 98、Windows NT、Windows 2000、Windows XP 以及 Windows Vista 和 Windows 7 的非系统分区，**一些流行的 Linux 都支持这种分区格式**。

但是 FAT16 分区格式有一个最大的缺点，那就是硬盘的实际利用效率低。因为在 DOS 和 Windows 系统中，磁盘文件的分配是以簇为单位的，一个簇只分配给一个文件使用，不管这个文件占用整个簇容量的多少。而且每簇的大小由硬盘分区的大小来决定，分区越大，簇就越大。例如 1GB 的硬盘若只分一个区，那么簇的大小是 32 KB，也就是说，即使一个文件只有 1 字节长，存储时也要占 32 KB 的硬盘空间，剩余的空间便全部闲置在那里，这样就导致了磁盘空间的极大浪费。FAT16 支持的分区越大，磁盘上每个簇的容量也越大，造成的浪费也越大。所以随着当前主流硬盘的容量越来越大，这种缺点变得越来越突出。为了克服 FAT16 的这个弱点，微软公司在 Windows 97 操作系统中推出了一种全新的磁盘分区格式 FAT32。

#### FAT32

这种格式采用 32 位的文件分配表，使其对磁盘的管理能力大大增强，突破了 FAT16 对每一个分区的容量只有 2GB 的限制，**可以支持的磁盘大小达到 32 GB，但是不能支持小于 512 MB 的分区**。运用 FAT32 的分区格式后，用户可以将一个大硬盘定义成一个分区，而不必分为几个分区使用，大大方便了对硬盘的管理工作。而且，FAT32 还具有一个最大的优点是：在一个不超过 8GB 的分区中，FAT32 分区格式的每个簇容量都固定为 4KB，与 FAT16 相比，可以大大地减少硬盘空间的浪费，提高了硬盘利用效率，但是，**FAT32 的单个文件不能超过 4G**。

**有时候我们往优盘（或内存卡）中复制的文件大小明明小于优盘的可用空间大小，系统却提示存储空间不足，这个时候突然发现我们的优盘是 FAT32 格式，而我们所传的单个文件也超过了 4 GB。这个时候可以将优盘格式化为 NTFS 格式即可。使用 Windows 系统格式化时可以选择“快速格式化’”，前提是磁盘没有损坏。**

**多数 Android 系统手机仅支持 FAT32 格式的存储设备。有时候给手机插上 OTG 优盘（或内存卡）后提示格式化为便携式存储设备，可能并不我们的优盘损坏了，而是其格式不是 FAT32。但如果我们不想将优盘格式化为 FAT32 怎么办呢？手机上安装一个 ES 文件浏览器打开 OTG 优盘即可。其实，某些国产 Android  定制系统中，像 Flyme 和 EMUI 这些系统已经解决了这个问题 ，系统完全支持除 FAST32 外的 NTFS 和 exFAT 等格式**。

支持这一磁盘分区格式的桌面操作系统有 Windows 97/98/2000/XP/Vista/7/8 等。但是，这种分区格式也有它的缺点，首先是采用 FAT32 格式分区的磁盘，由于文件分配表的扩大，运行速度比采用 FAT16 格式分区的硬盘要慢；另外，由于 DOS 系统和某些早期的应用软件不支持这种分区格式，所以采用这种分区格式后，就无法再使用老的 DOS 操作系统和某些旧的应用软件了。

#### NTFS

NTFS 是一种新兴的磁盘格式，目前广泛应用于 Win Vista、Win 7、Win 8、Win 10 操作系统中。早期用在 Windows NT 网络操作系统中，但随着安全性的提高，在 Windows Vista 和 Windows 7 操作系统中也开始使用这种格式。其显著的优点是安全性和稳定性极其出色，在使用中不易产生文件碎片，对硬盘的空间利用及软件的运行速度都有好处。而且**单个文件可以超过 4 GB**。它能对用户的操作进行日志记录，通过对用户权限进行非常严格的限制，使每个用户只能按照系统赋予的权限进行操作，充分保护了网络系统与数据的安全。

#### exFAT

exFAT（全称 Extended File Allocation Table File System，扩展 FAT，即扩展文件分配表）是 Microsoft 在Windows Embeded 6.0（包括 Windows CE 6.0、Windows Mobile）中引入的一种适合于闪存的文件系统。对于闪存设备（比如优盘和内存卡），NTFS 过于复杂，exFAT 更为适用。

相对FAT文件系统，exFAT 有如下好处：

- 增强了台式电脑与移动设备的互操作能力；
- 单文件大小最大可达 16 EB（1 EB = 1024 PB，1 PB = 1024 TB）；
- 簇大小可高达 32 MB；
- 采用了剩余空间分配表，剩余空间分配性能改进；
- 同一目录下最大文件数可达 65536 个；
- 支持访问控制；
- 支持 TFAT。

> 请注意：exFAT 只是一个折中的方案，只为 U 盘而生。采用该文件系统的闪存盘不支持 Windows Vista ReadyBoost。Windows Vista SP1 开始支持该文件系统。需要严格注意的是，Win Vista 以前系统并不支持这种格式，Win XP 可以通过替换驱动文件的方式支持此格式，但是只能读写，不能格式化。

### Linux 系统支持的文件系统

#### ext

Linux 操作系统中引入的最早的文件系统叫作扩展文件系统（extended filesystem，简记为 ext）。 它为 Linux 提供了一个基本的类 Unix 文件系统：使用虚拟目录来操作硬件设备，在物理设备上按 定长的块来存储数据。ext2 文件系统拥有极快的速度和极小的 CPU 占用率，既可以用于标准的块设备（如硬盘），也被应用在软盘等移动存储设备上。

ext 文件系统采用名为**索引节点**的系统来存放虚拟目录中所存储文件的信息。索引节点系统在每个物理设备中创建一个单独的表（称为**索引节点表**）来存储这些文件的信息。存储在虚拟目录中的每一个文件在索引节点表中都有一个条目。 ext 文件系统名称中的 extended 部分来自其跟踪的每个文件的额外数据，包括：

- 文件名
- 文件大小
- 文件的属主
- 文件的属组
- 文件的访问权限
- 指向存有文件数据的每个硬盘块的指针 

Linux 通过唯一的数值（称作**索引节点号**）来引用索引节点表中的每个索引节点，这个值是创建文件时由文件系统分配的。文件系统通过索引节点号而不是文件全名及路径来标识文件。

#### ext2

最早的 ext 文件系统有不少限制，比如文件大小不得超过 2 GB。在 Linux 出现后不久， ext 文件系统就升级到了第二代扩展文件系统，叫作 ext2。 如你所猜测的，ext2 文件系统是 ext 文件系统基本功能的一个扩展，但保持了同样的结构。 **ext2 文件系统扩展了索引节点表的格式来保存系统上每个文件的更多信息**。ext2 的索引节点表为文件添加了创建时间值、修改时间值和最后访问时间值来帮助系统管理 员追踪文件的访问情况。ext2 文件系统还将允许的最大文件大小增加到了 2 TB（在 ext2 的后期版 本中增加到了 32 TB），以容纳数据库服务器中常见的大文件。

 除了扩展索引节点表外， ext2 文件系统还改变了文件在数据块中存储的方式。 ext 文件系统常见的问题是在文件写入到物理设备时，存储数据用的块很容易分散在整个设备中（称作碎片化， fragmentation）。数据块的碎片化会降低文件系统的性能，因为需要更长的时间在存储设备中查找 特定文件的所有块。 保存文件时，ext2 文件系统通过按组分配磁盘块来减轻碎片化。通过将数据块分组，文件系统在读取文件时不需要为了数据块查找整个物理设备。 

多年来，ext 文件系统一直都是 Linux 发行版采用的默认文件系统。但它也有一些限制。索引节点表虽然支持文件系统保存有关文件的更多信息，但会对系统造成致命的问题。文件系统 每次存储或更新文件，它都要用新信息来更新索引节点表。问题在于这种操作并非总是一气呵 成的。如果计算机系统在存储文件和更新索引节点表之间发生了什么，这二者的内容就不同步了。ext2 文件系统由于容易在系统崩溃或断电时损坏而臭名昭著。即使文件数据正常保存到了物理设 备上，如果索引节点表记录没完成更新的话， ext2 文件系统甚至都不知道那个文件存在！

ext 文件系统和 ext2 文件系统都存在安全操作的问题。而**日志文件系统**为 Linux 系统增加了一层安全性。它不再使用之前先将数据直接写入存储设备再更新索引节点表的做法，而是**先将文件的更改写入到临时文件（称作日志， journal）中，在数据成功写到存储设备和索引节点表之后，再删除对应的日志条目**。    

如果系统在数据被写入存储设备之前崩溃或断电了，日志文件系统（Journal File System)下次会读取日志文件并处理上次留下的未写入的数据。 Linux 中有 3 种广泛使用的日志方法，每种的保护等级都不相同：

| 方法     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 数据模式 | 索引节点和文件都会被写入日志；丢失数据风险低，但性能差       |
| 有序模式 | 只有索引节点数据会被写入日志，但只有数据成功写入后才删除；在性能和安全性之间取得了良好的折中 |
| 回写模式 | 只有索引节点数据会被写入日志，但不控制文件数据何时写入；丢失数据风险高，但仍比不用日志好 |

数据模式日志方法是目前为止最安全的数据保护方法，但同时也是最慢的。所有写到存储设备上的数据都必须写两次：第一次写入日志，第二次写入真正的存储设备。这样会导致性能很差， 尤其是对要做大量数据写入的系统而言。    

#### ext3

2001 年， ext3 文件系统被引入 Linux 内核中，直到最近都是几乎所有 Linux 发行版默认的文件 系统。它采用和 ext2 文件系统相同的索引节点表结构，但给每个存储设备增加了一个日志文件， 以将准备写入存储设备的数据先记入日志。 

默认情况下， ext3文件系统用有序模式的日志功能——只将索引节点信息写入日志文件，直到数据块都被成功写入存储设备才删除。你可以在创建文件系统时用简单的一个命令行选项将 ext3 文件系统的日志方法改成数据模式或回写模式。 

虽然 ext3 文件系统为 Linux 文件系统添加了基本的日志功能，但它仍然缺少一些功能。例如，ext3 文件系统无法恢复误删的文件，它没有任何内建的数据压缩功能（虽然有个需单独安装的补 丁支持这个功能）， ext3 文件系统也不支持加密文件。鉴于这些原因， Linux 项目的开发人员选择再接再厉，继续改进 ext3 文件系统。    

#### ext4

扩展 ext3 文件系统功能的结果是ext4文件系统（你可能也猜出来了）。 ext4 文件系统在 2008 年受到Linux内核官方支持，现在已是大多数流行的 Linux 发行版采用的默认文件系统，比如 Ubuntu。

除了**支持数据压缩和加密**， ext4 文件系统还**支持区段（extent）特性**。区段在存储设备上按块分配空间，但在索引节点表中只保存起始块的位置。由于无需列出所有用来存储文件中数据的数据块，它可以在索引节点表中节省一些空间。 ext4 还**引入了块预分配技术（block preallocation）**。如果你想在存储设备上给一个你知道要变大的文件预留空间， ext4 文件系统可以为文件分配所有需要用到的块，而不仅仅是那些现在已经用到的块。 ext4 文件系统用 0 填满预留的数据块，不会将它们分配给其他文件。

#### JFS

作为可能依然在用的最老的日志文件系统之一， JFS（Journaled File System， 日志化文件系 统）是 IBM 在 1990 年为其 Unix 衍生版 AIX 开发的。然而直到第 2 版，它才被移植到 Linux 环境中。IBM 官方称 JFS 文件系统的第 2 版为JFS2，但大多数Linux系统提到它时都只用 JFS。除了用在 IBM Linux 上外， JFS 文件系统并没有流行起来，但你有可能在同 Linux 打交道的日 子中碰到它。

**JFS 文件系统采用的是有序日志方法**，即只在日志中保存索引节点表数据，直到真正的文件数据被写进存储设备时才删除它。这个方法在 ReiserFS 的速度和数据模式日志方法的完整性之间的采取的一种折中。 JFS 文件系统采用基于区段的文件分配，即为每个写入存储设备的文件分配一组块。这样可以减少存储设备上的碎片。 

#### XFS

XFS 日志文件系统是另一种最初用于商业 Unix 系统而如今走进 Linux 世界的文件系统。美国硅图公司（SGI）最初在1994 年为其商业化的 IRIX Unix 系统开发了X FS。 2002 年，它被发布到了适用于 Linux 环境的版本。 

**XFS 文件系统采用回写模式的日志**，在提供了高性能的同时也引入了一定的风险，因为实际数据并未存进日志文件。 XFS 文件系统还允许在线调整文件系统的大小，这点类似于 ReiserFS 文件系统，除了 XFS 文件系统只能扩大不能缩小。

尽管数据模式日志提供了最高的安全性，但是会对性能带来影响，因为索引节点和数据都需要被日志化。如果是回写模式日志， 性能倒是可以接受，但安全性就会受到损害。 就文件系统而言，日志式的另一种选择是一种叫作写时复制（copy-on-write， COW）的技术。 COW 利用快照兼顾了安全性和性能。如果要修改数据，会使用克隆或可写快照。修改过的数据并不会直接覆盖当前数据，而是被放入文件系统中的另一个位置上。即便是数据修改已经完成，之前的旧数据也不会被重写。 COW 文件系统已日渐流行，接下来会简要概览其中最流行的两种（Btrf和ZFS）。

#### ZFS

COW 文件系统 ZFS 是由 Sun 公司于 2005 年研发的，用于 OpenSolaris 操作系统，从 2008 年起开始向 Linux 移植，最终在 2012 年投入 Linux 产品的使用。 ZFS 是一个稳定的文件系统，与 Resier4、 Btrfs 和 ext4 势均力敌。它最大的弱项就是没有使用 GPL许可。自 2013 年发起的 OpenZFS 项目有可能改变这种局面。但是，在获得 GPL 许可之前， ZFS 有可能终无法成为 Linux 默认的文件系统。 

#### Btrf

Btrfs 文件系统是 COW 的新人，也被称为 B 树文件系统。它是由 Oracle 公司于 2007 年开始研发的。 Btrfs 在 Reiser4 的诸多特性的基础上改进了可靠性。另一些开发人员最终也加入了开发过程， 帮助 Btrfs 快速成为了最流行的文件系统。究其原因，则要归于它的稳定性、易用性以及能够动态调整已挂载文件系统的大小。 OpenSUSE Linux 发行版最近将 Btrfs 作为其默认文件系统。除此之 外，该文件系统也出现在了其他 Linux 发行版中（如RHEL），不过并不是作为默认文件系统。    

#### VFAT

VFAT 叫长文件名系统，这是一个**与 Windows 系统兼容的 Linux 文件系统，支持长文件名，可以作为 Windows 与 Linux 交换文件的分区**。

#### swap

它是 Linux 中一种专门用于交换分区 swap 的文件系统。Linux 使用这一整个分区作为交换空间。一般这个 swap 格式的交换分区是物理内存的 2 倍，在内存不够时，Linux 会将部分数据写到交换分区上。

随着 Linux 的不断发展，它所支持的文件格式系统也在迅速扩充，Linux 系统核心可以支持十多种文件系统类型：Btrfs、JFS、ReiserFS、exFAT、EXT、EXT2、EXT3、EXT4、XFS、ISO 9660、XFS、Minx、MSDOS、UMSDOS、VFAT、NTFS、HPFS、NFS、SMB、SysV、PROC等。

> 注意：部分 Linux 发行版默认不支持 NTFS 文件系统，解决方法是安装 NTFS-3G 或 ufsd 等 NTFS 驱动程序。部分 Linux 发行版对 NTFS 的支持度并不高。

### 常见文件系统的比较

| FS Name   | Year Introduced | Original OS | Max File Size | Max FS Size  | Journaling |
| --------- | --------------- | ----------- | ------------- | ------------ | ---------- |
| FAT16     | 1983            | MSDOS V2    | 4GB           | 16MB to 8GB  | N          |
| FAT32     | 1997            | Windows 95  | 4GB           | 8GB to 2TB   | N          |
| HPFS      | 1988            | OS/2        | 4GB           | 2TB          | N          |
| NTFS      | 1993            | Windows NT  | 16EB          | 16EB         | Y          |
| HFS+      | 1998            | Mac OS      | 8EB           | ?            | N          |
| UFS2      | 2002            | FreeBSD     | 512GB to 32PB | 1YB          | N          |
| ext2      | 1993            | Linux       | 16GB to 2TB4  | 2TB to 32TB  | N          |
| ext3      | 1999            | Linux       | 16GB to 2TB4  | 2TB to 32TB  | Y          |
| ReiserFS3 | 2001            | Linux       | 8TB8          | 16TB         | Y          |
| ReiserFS4 | 2005            | Linux       | ?             | ?            | Y          |
| XFS       | 1994            | IRIX        | 9EB           | 9EB          | Y          |
| JFS       | ?               | AIX         | 8EB           | 512TB to 4PB | Y          |
| VxFS      | 1991            | SVR4.0      | 16EB          | ?            | Y          |
| ZFS       | 2004            | Solaris 10  | 1YB           | 16EB         | N          |

