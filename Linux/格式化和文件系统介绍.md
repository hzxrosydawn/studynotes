---
typora-copy-images-to: ..\..\graphs\photos
typora-root-url: ..\..\graphs\photos
---

### 文件系统概述

**文件系统（File System）**是操作系统中负责管理和存储文件信息的软件机构，用于向用户提供底层数据访问。它将设备中的空间划分为特定大小的块（或称为簇），一般每块 512 字节，一个块可能由多个扇区组成。数据存储在这些块中，大小被修正为占用整数个块，由文件系统软件来负责将这些块组织为文件和树形目录，并记录哪些块被分配给了哪个文件，以及哪些块没有被使用。文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备实际使用数据块的概念，用户使用文件系统来保存数据时不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。

文件系统是数据的组织者和提供者，并不一定只在特定存储设备上出现，实际上文件系统可能仅仅是一种访问数据的界面而已，实际的数据是通过网络协议（如 NFS、SMB、9P 等）提供的或者在内存上，甚至可能根本没有对应的文件（如 PROC 文件系统）。严格地说，文件系统是一套实现了数据的存储、分级组织、访问和获取等操作的抽象数据类型（Abstract data type）。

分区建立后，在将数据存储到分区之前，你必须用某种文件系统对其进行格式化，这样操作系统才能使用它。创建文件系统的操作就是平时我们所说的格式化。格式化是指对磁盘或磁盘中的分区（partition）进行初始化的一种操作，这种操作通常会导致现有的磁盘或分区中所有的文件被清除。

> 格式化通常分为**低格（低级格式化）和高格（高级格式化）**。
>
> - 低级格式化（Low-Level Formatting）又称低层格式化或物理格式化（Physical Format），对于部分硬盘制造厂商，它也被称为初始化（initialization）。大多数的硬盘制造商将低级格式化（Low-Level Formatting）定义为**创建硬盘扇区使硬盘具备存储能力的操作**。
> - 高级格式化又称逻辑格式化，即**创建文件系统的过程**。高格是根据用户选定的文件系统在磁盘的特定区域写入特定数据，以初始化磁盘或磁盘分区、清除原磁盘或磁盘分区中所有文件的一个操作。高级格式化包括对主引导记录（MBR）中分区表相应区域的重写，根据用户选定的文件系统在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间以便用户使用该分区管理文件。
> - **低格在硬盘出厂时已经完成。如果没有特别指明，对硬盘的格式化通常是指高格**。

下图为一个全新的、未使用的磁盘驱动器的一种形象表示。

![unused-drive](G:/graphs/photos/unused-drive.png)

要在磁盘驱动器中保存数据，则首先需要格式化该磁盘驱动器。格式化（通常称“ 生成文件系统” ）是向驱动器
中写入信息，在未格式化驱动器中为空白空间建立顺序。下图表示一个有文件系统的磁盘驱动器。

![formatted-drive](G:/graphs/photos/formatted-drive.png)

如上图所示，文件系统所指派的顺序涉及了一些折衷方案：

- 驱动器中的一**小部分可用空间被用来存储与文件系统有关的数据**，这可以被视作额外部分。
- **文件系统将剩余的空间分成小的一定大小的片段。在 Linux 中，这些片段就是块**。

> 注：没有单一、通用的文件系统。不同的文件系统会彼此不兼容，也就是说，支持某一文件系统（或者相关的文件系统类型）的操作系统可能不支持另外一种文件系统。比如 Windows 不支持 ext4 等日志文件系统，而 Red Hat Enterprise Linux 就支持很多文件系统（包括许多被其他操作系统使用的文件系统），这就使得在不同文件系统之间的数据交换变得容易了。

在磁盘中写入文件系统只是第一步。这个进程的目的实际上是要保存和检索数据。下图显示了写入数据后的磁盘驱动器：

![used-formatted-drive](G:/graphs/photos/used-formatted-drive.png)

某些之前的空数据块现在也存放着数据。然而，只看这个框图，我们不能确认这个磁盘中有多少个文件系统。这有可能是一个，也有可能是多个，因为所有的文件都使用至少一个数据块，而有些文件则使用多个块。另外一个值得注意的地方是，已经被使用的块不一定组成连续的空间；未使用的和已使用的块可以散布排列。这被称作碎片。当尝试调整现存分区的大小时，碎片会对其产生影响。

和大多数与计算机相关的技术一样，与磁盘驱动器刚发明时相比，文件系统已经有了很大的变化。特别是保存信息的容量变得越来越大。同时额外的容量让使用磁盘驱动器的方法发生了根本改变。

生活中我们所说的磁盘格式就是指文件系统。不同的操作系统所使用的文件系统也不同。

### Windows 系统支持的文件系统

| Windows                                                      | FAT12/FAT16 | FAT32/VFAT | FAT64/exFAT | NTFS      |
| ------------------------------------------------------------ | ----------- | ---------- | ----------- | --------- |
| Windows 3.x 或更早、（MS-DOS 6.22）、（PC-DOS 7.0）          | 可读/可写   | 不支持     | 不支持      | 不支持    |
| Windows 95                                                   | 可读/可写   | 不支持     | 不支持      | 不支持    |
| Windows 95（OSR2以后）、Windows 98（含SE）、ME               | 可读/可写   | 可读/可写  | 不支持      | 不支持    |
| Windows NT                                                   | 可读/可写   | 不支持     | 不支持      | 可读/可写 |
| 2000、Windows XP、Windows Vista、Server 2003、Server 2008 (R2)、Windows 7、Windows 8、Server 2012 (R2)、Windows 8.1、Windows 10 | 可读/可写   | 可读/可写  | 可读/可写   | 可读/可写 |

> 注意：除非 NT 安装了 FAT32 For Windows NT 4.0，否则 NT 是不支持 FAT32。

#### FAT16

对电脑老手而言，对这种硬盘分区格式是最熟悉不过了它**采用 16 位的文件分配表，能支持的最大分区为 2 GB**，是曾经应用最为广泛和获得操作系统支持最多的一种磁盘分区格式，几乎所有的操作系统都支持这一种格式，从 DOS、Win 3.x、Win 95、Win 97 到 Win 98、Windows NT、Windows 2000、Windows XP 以及 Windows Vista 和 Windows 7 的非系统分区，**一些流行的 Linux 都支持这种分区格式**。

但是 FAT16 分区格式有一个最大的缺点，那就是硬盘的实际利用效率低。因为在 DOS 和 Windows 系统中，磁盘文件的分配是以簇为单位的，一个簇只分配给一个文件使用，不管这个文件占用整个簇容量的多少。而且每簇的大小由硬盘分区的大小来决定，分区越大，簇就越大。例如 1GB 的硬盘若只分一个区，那么簇的大小是 32 KB，也就是说，即使一个文件只有 1 字节长，存储时也要占 32 KB 的硬盘空间，剩余的空间便全部闲置在那里，这样就导致了磁盘空间的极大浪费。FAT16 支持的分区越大，磁盘上每个簇的容量也越大，造成的浪费也越大。所以随着当前主流硬盘的容量越来越大，这种缺点变得越来越突出。为了克服 FAT16 的这个弱点，微软公司在 Windows 97 操作系统中推出了一种全新的磁盘分区格式 FAT32。

#### FAT32

这种格式采用 32 位的文件分配表，使其对磁盘的管理能力大大增强，突破了 FAT16 对每一个分区的容量只有 2GB 的限制，**可以支持的磁盘大小达到 32 GB，但是不能支持小于 512 MB 的分区**。运用 FAT32 的分区格式后，用户可以将一个大硬盘定义成一个分区，而不必分为几个分区使用，大大方便了对硬盘的管理工作。而且，FAT32 还具有一个最大的优点是：在一个不超过 8GB 的分区中，FAT32 分区格式的每个簇容量都固定为 4KB，与 FAT16 相比，可以大大地减少硬盘空间的浪费，提高了硬盘利用效率，但是，**FAT32 的单个文件不能超过 4G**。

**有时候我们往优盘（或内存卡）中复制的文件大小明明小于优盘的可用空间大小，系统却提示存储空间不足，这个时候突然发现我们的优盘是 FAT32 格式，而我们所传的单个文件也超过了 4 GB。这个时候可以将优盘格式化为 NTFS 格式即可。使用 Windows 系统格式化时可以选择“快速格式化’”，前提是磁盘没有损坏。**

**多数 Android 系统手机仅支持 FAT32 格式的存储设备。有时候给手机插上 OTG 优盘（或内存卡）后提示格式化为便携式存储设备，可能并不我们的优盘损坏了，而是其格式不是 FAT32。但如果我们不想将优盘格式化为 FAT32 怎么办呢？手机上安装一个 ES 文件浏览器打开 OTG 优盘即可。其实，某些国产 Android  定制系统中，像 Flyme 和 EMUI 这些系统已经解决了这个问题 ，系统完全支持除 FAST32 外的 NTFS 和 exFAT 等格式**。

支持这一磁盘分区格式的桌面操作系统有 Windows 97/98/2000/XP/Vista/7/8 等。但是，这种分区格式也有它的缺点，首先是采用 FAT32 格式分区的磁盘，由于文件分配表的扩大，运行速度比采用 FAT16 格式分区的硬盘要慢；另外，由于 DOS 系统和某些早期的应用软件不支持这种分区格式，所以采用这种分区格式后，就无法再使用老的 DOS 操作系统和某些旧的应用软件了。

#### NTFS

NTFS 是一种新兴的磁盘格式，目前广泛应用于 Win Vista、Win 7、Win 8、Win 10 操作系统中。早期用在 Windows NT 网络操作系统中，但随着安全性的提高，在 Windows Vista 和 Windows 7 操作系统中也开始使用这种格式。其显著的优点是安全性和稳定性极其出色，在使用中不易产生文件碎片，对硬盘的空间利用及软件的运行速度都有好处。而且**单个文件可以超过 4 GB**。它能对用户的操作进行日志记录，通过对用户权限进行非常严格的限制，使每个用户只能按照系统赋予的权限进行操作，充分保护了网络系统与数据的安全。

#### exFAT

exFAT（全称 Extended File Allocation Table File System，扩展 FAT，即扩展文件分配表）是 Microsoft 在Windows Embeded 6.0（包括 Windows CE 6.0、Windows Mobile）中引入的一种适合于闪存的文件系统。对于闪存设备（比如优盘和内存卡），NTFS 过于复杂，exFAT 更为适用。

相对FAT文件系统，exFAT 有如下好处：

- 增强了台式电脑与移动设备的互操作能力；
- 单文件大小最大可达 16 EB（1 EB = 1024 PB，1 PB = 1024 TB）；
- 簇大小可高达 32 MB；
- 采用了剩余空间分配表，剩余空间分配性能改进；
- 同一目录下最大文件数可达 65536 个；
- 支持访问控制；
- 支持 TFAT。

> 请注意：exFAT 只是一个折中的方案，只为 U 盘而生。采用该文件系统的闪存盘不支持 Windows Vista ReadyBoost。Windows Vista SP1 开始支持该文件系统。需要严格注意的是，Win Vista 以前系统并不支持这种格式，Win XP 可以通过替换驱动文件的方式支持此格式，但是只能读写，不能格式化。

### Linux 系统支持的文件系统

#### ext

Linux 操作系统中引入的最早的文件系统叫作扩展文件系统（extended filesystem，简记为 ext）。 它为 Linux 提供了一个基本的类 Unix 文件系统：使用虚拟目录来操作硬件设备，在物理设备上按 定长的块来存储数据。ext2 文件系统拥有极快的速度和极小的 CPU 占用率，既可以用于标准的块设备（如硬盘），也被应用在软盘等移动存储设备上。

ext 文件系统采用名为**索引节点**的系统来存放虚拟目录中所存储文件的信息。索引节点系统在每个物理设备中创建一个单独的表（称为**索引节点表**）来存储这些文件的信息。存储在虚拟目录中的每一个文件在索引节点表中都有一个条目。 ext 文件系统名称中的 extended 部分来自其跟踪的每个文件的额外数据，包括：

- 文件名
- 文件大小
- 文件的属主
- 文件的属组
- 文件的访问权限
- 指向存有文件数据的每个硬盘块的指针 

Linux 通过唯一的数值（称作**索引节点号**）来引用索引节点表中的每个索引节点，这个值是创建文件时由文件系统分配的。文件系统通过索引节点号而不是文件全名及路径来标识文件。

#### ext2

最早的 ext 文件系统有不少限制，比如文件大小不得超过 2 GB。在 Linux 出现后不久， ext 文件系统就升级到了第二代扩展文件系统，叫作 ext2。 如你所猜测的，ext2 文件系统是 ext 文件系统基本功能的一个扩展，但保持了同样的结构。 **ext2 文件系统扩展了索引节点表的格式来保存系统上每个文件的更多信息**。ext2 的索引节点表为文件添加了创建时间值、修改时间值和最后访问时间值来帮助系统管理 员追踪文件的访问情况。ext2 文件系统还将允许的最大文件大小增加到了 2 TB（在 ext2 的后期版 本中增加到了 32 TB），以容纳数据库服务器中常见的大文件。

 除了扩展索引节点表外， ext2 文件系统还改变了文件在数据块中存储的方式。 ext 文件系统常见的问题是在文件写入到物理设备时，存储数据用的块很容易分散在整个设备中（称作碎片化， fragmentation）。数据块的碎片化会降低文件系统的性能，因为需要更长的时间在存储设备中查找 特定文件的所有块。 保存文件时，ext2 文件系统通过按组分配磁盘块来减轻碎片化。通过将数据块分组，文件系统在读取文件时不需要为了数据块查找整个物理设备。 

多年来，ext 文件系统一直都是 Linux 发行版采用的默认文件系统。但它也有一些限制。索引节点表虽然支持文件系统保存有关文件的更多信息，但会对系统造成致命的问题。文件系统 每次存储或更新文件，它都要用新信息来更新索引节点表。问题在于这种操作并非总是一气呵 成的。如果计算机系统在存储文件和更新索引节点表之间发生了什么，这二者的内容就不同步了。ext2 文件系统由于容易在系统崩溃或断电时损坏而臭名昭著。即使文件数据正常保存到了物理设 备上，如果索引节点表记录没完成更新的话， ext2 文件系统甚至都不知道那个文件存在！

ext 文件系统和 ext2 文件系统都存在安全操作的问题。而**日志文件系统**为 Linux 系统增加了一层安全性。它不再使用之前先将数据直接写入存储设备再更新索引节点表的做法，而是**先将文件的更改写入到临时文件（称作日志， journal）中，在数据成功写到存储设备和索引节点表之后，再删除对应的日志条目**。    

如果系统在数据被写入存储设备之前崩溃或断电了，日志文件系统（Journal File System)下次会读取日志文件并处理上次留下的未写入的数据。 Linux 中有 3 种广泛使用的日志方法，每种的保护等级都不相同：

| 方法     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 数据模式 | 索引节点和文件都会被写入日志；丢失数据风险低，但性能差       |
| 有序模式 | 只有索引节点数据会被写入日志，但只有数据成功写入后才删除；在性能和安全性之间取得了良好的折中 |
| 回写模式 | 只有索引节点数据会被写入日志，但不控制文件数据何时写入；丢失数据风险高，但仍比不用日志好 |

数据模式日志方法是目前为止最安全的数据保护方法，但同时也是最慢的。所有写到存储设备上的数据都必须写两次：第一次写入日志，第二次写入真正的存储设备。这样会导致性能很差， 尤其是对要做大量数据写入的系统而言。    

#### ext3

2001 年， ext3 文件系统被引入 Linux 内核中，直到最近都是几乎所有 Linux 发行版默认的文件 系统。它采用和 ext2 文件系统相同的索引节点表结构，但给每个存储设备增加了一个日志文件， 以将准备写入存储设备的数据先记入日志。 

默认情况下， ext3文件系统用有序模式的日志功能——只将索引节点信息写入日志文件，直到数据块都被成功写入存储设备才删除。你可以在创建文件系统时用简单的一个命令行选项将 ext3 文件系统的日志方法改成数据模式或回写模式。 

虽然 ext3 文件系统为 Linux 文件系统添加了基本的日志功能，但它仍然缺少一些功能。例如，ext3 文件系统无法恢复误删的文件，它没有任何内建的数据压缩功能（虽然有个需单独安装的补 丁支持这个功能）， ext3 文件系统也不支持加密文件。鉴于这些原因， Linux 项目的开发人员选择再接再厉，继续改进 ext3 文件系统。    

#### ext4

扩展 ext3 文件系统功能的结果是ext4文件系统（你可能也猜出来了）。 ext4 文件系统在 2008 年受到Linux内核官方支持，现在已是大多数流行的 Linux 发行版采用的默认文件系统，比如 Ubuntu。

除了**支持数据压缩和加密**， ext4 文件系统还**支持区段（extent）特性**。区段在存储设备上按块分配空间，但在索引节点表中只保存起始块的位置。由于无需列出所有用来存储文件中数据的数据块，它可以在索引节点表中节省一些空间。 ext4 还**引入了块预分配技术（block preallocation）**。如果你想在存储设备上给一个你知道要变大的文件预留空间， ext4 文件系统可以为文件分配所有需要用到的块，而不仅仅是那些现在已经用到的块。 ext4 文件系统用 0 填满预留的数据块，不会将它们分配给其他文件。

#### JFS

作为可能依然在用的最老的日志文件系统之一， JFS（Journaled File System， 日志化文件系 统）是 IBM 在 1990 年为其 Unix 衍生版 AIX 开发的。然而直到第 2 版，它才被移植到 Linux 环境中。IBM 官方称 JFS 文件系统的第 2 版为JFS2，但大多数Linux系统提到它时都只用 JFS。除了用在 IBM Linux 上外， JFS 文件系统并没有流行起来，但你有可能在同 Linux 打交道的日 子中碰到它。

**JFS 文件系统采用的是有序日志方法**，即只在日志中保存索引节点表数据，直到真正的文件数据被写进存储设备时才删除它。这个方法在 ReiserFS 的速度和数据模式日志方法的完整性之间的采取的一种折中。 JFS 文件系统采用基于区段的文件分配，即为每个写入存储设备的文件分配一组块。这样可以减少存储设备上的碎片。 

#### XFS

XFS 日志文件系统是另一种最初用于商业 Unix 系统而如今走进 Linux 世界的文件系统。美国硅图公司（SGI）最初在1994 年为其商业化的 IRIX Unix 系统开发了X FS。 2002 年，它被发布到了适用于 Linux 环境的版本。 

**XFS 文件系统采用回写模式的日志**，在提供了高性能的同时也引入了一定的风险，因为实际数据并未存进日志文件。 XFS 文件系统还允许在线调整文件系统的大小，这点类似于 ReiserFS 文件系统，除了 XFS 文件系统只能扩大不能缩小。

尽管数据模式日志提供了最高的安全性，但是会对性能带来影响，因为索引节点和数据都需要被日志化。如果是回写模式日志， 性能倒是可以接受，但安全性就会受到损害。 就文件系统而言，日志式的另一种选择是一种叫作写时复制（copy-on-write， COW）的技术。 COW 利用快照兼顾了安全性和性能。如果要修改数据，会使用克隆或可写快照。修改过的数据并不会直接覆盖当前数据，而是被放入文件系统中的另一个位置上。即便是数据修改已经完成，之前的旧数据也不会被重写。 COW 文件系统已日渐流行，接下来会简要概览其中最流行的两种（Btrf和ZFS）。

#### ZFS

COW 文件系统 ZFS 是由 Sun 公司于 2005 年研发的，用于 OpenSolaris 操作系统，从 2008 年起开始向 Linux 移植，最终在 2012 年投入 Linux 产品的使用。 ZFS 是一个稳定的文件系统，与 Resier4、 Btrfs 和 ext4 势均力敌。它最大的弱项就是没有使用 GPL许可。自 2013 年发起的 OpenZFS 项目有可能改变这种局面。但是，在获得 GPL 许可之前， ZFS 有可能终无法成为 Linux 默认的文件系统。 

#### Btrf

Btrfs 文件系统是 COW 的新人，也被称为 B 树文件系统。它是由 Oracle 公司于 2007 年开始研发的。 Btrfs 在 Reiser4 的诸多特性的基础上改进了可靠性。另一些开发人员最终也加入了开发过程， 帮助 Btrfs 快速成为了最流行的文件系统。究其原因，则要归于它的稳定性、易用性以及能够动态调整已挂载文件系统的大小。 OpenSUSE Linux 发行版最近将 Btrfs 作为其默认文件系统。除此之 外，该文件系统也出现在了其他 Linux 发行版中（如RHEL），不过并不是作为默认文件系统。    

#### VFAT

VFAT 叫长文件名系统，这是一个**与 Windows 系统兼容的 Linux 文件系统，支持长文件名，可以作为 Windows 与 Linux 交换文件的分区**。

#### swap

它是 Linux 中一种专门用于交换分区 swap 的文件系统。Linux 使用这一整个分区作为交换空间。一般这个 swap 格式的交换分区是物理内存的 2 倍，在内存不够时，Linux 会将部分数据写到交换分区上。

随着 Linux 的不断发展，它所支持的文件格式系统也在迅速扩充，Linux 系统核心可以支持十多种文件系统类型：Btrfs、JFS、ReiserFS、exFAT、EXT、EXT2、EXT3、EXT4、XFS、ISO 9660、XFS、Minx、MSDOS、UMSDOS、VFAT、NTFS、HPFS、NFS、SMB、SysV、PROC等。

> 注意：部分 Linux 发行版默认不支持 NTFS 文件系统，解决方法是安装 NTFS-3G 或 ufsd 等 NTFS 驱动程序。部分 Linux 发行版对 NTFS 的支持度并不高。

### 常见文件系统的比较

| FS Name   | Year Introduced | Original OS | Max File Size | Max FS Size  | Journaling |
| --------- | --------------- | ----------- | ------------- | ------------ | ---------- |
| FAT16     | 1983            | MSDOS V2    | 4GB           | 16MB to 8GB  | N          |
| FAT32     | 1997            | Windows 95  | 4GB           | 8GB to 2TB   | N          |
| HPFS      | 1988            | OS/2        | 4GB           | 2TB          | N          |
| NTFS      | 1993            | Windows NT  | 16EB          | 16EB         | Y          |
| HFS+      | 1998            | Mac OS      | 8EB           | ?            | N          |
| UFS2      | 2002            | FreeBSD     | 512GB to 32PB | 1YB          | N          |
| ext2      | 1993            | Linux       | 16GB to 2TB4  | 2TB to 32TB  | N          |
| ext3      | 1999            | Linux       | 16GB to 2TB4  | 2TB to 32TB  | Y          |
| ReiserFS3 | 2001            | Linux       | 8TB8          | 16TB         | Y          |
| ReiserFS4 | 2005            | Linux       | ?             | ?            | Y          |
| XFS       | 1994            | IRIX        | 9EB           | 9EB          | Y          |
| JFS       | ?               | AIX         | 8EB           | 512TB to 4PB | Y          |
| VxFS      | 1991            | SVR4.0      | 16EB          | ?            | Y          |
| ZFS       | 2004            | Solaris 10  | 1YB           | 16EB         | N          |

### 配置分区大小

CentOS 7 （参考 Red Hat Ent erprise Linux 7 安装手册）至少需要为 `/boot` 、`/ `、`/home` 、`swap` 这四个挂载点配置分区。下面是常见挂载点分区大小建议：

- `/boot` ：建议大小至少有 500 MB。系统中安装的每个内核大约需要占用 20 MB /boot 分区。500 MB /boot 分区足以应付大多数常规使用。多数情况下 500 MB 的 `/boot` 分区就足够了。如果要同时保留多个内核，请增大该分区。挂载到 `/boot` 的分区含有操作系统内核，它可让您的系统引导 CentOS，并提供引导过程中要使用的文件。它也可以存放内核在执行用户态程序之前所使用的其他数据。`/boot` 在日常系统运行中并不需要，只在启动和内核升级的时候用到。

- `/ ` ：建议大小至少为 10 GB。/ 分区（或叫根分区）是最重要而且必需的，需要最先挂载。/ 目录（或叫根目录）是目录树的顶层，所有文件和目录都在 / 目录中显示，即使它们实际上存储在其他的物理设备上。根文件系统中的内容应该足以启动、恢复、修复系统。因此 `/` 目录下的特定目录是不能作为独立分区的。默认情况下所有文件都写入这个分区，除非要写入的路径挂载到了不同分区，比如 `/home` 分区；

  不要将 `/ 目录`与 `/root 目录`混淆。`/root 目录`是 `root 用户`的主目录。

- `/home` ：其分区大小跟着存储的用户内容而定。/home 目录包含用户定义的配置文件、缓存、应用程序数据和媒体文件。考虑为所有可能包含敏感数据的分区加密。加密可防止对这些分区中数据的未授权访问，即使他们可以访 问物理存储设备。在大多数情况下，应该至少对 /home 分区加密。

- `swap` ：swap 分区支持虚拟内存。当没有足够的 RAM 保存系统处理的数据时会将数据写入 swap 分区。当系统缺乏 swap 空间时，内核会因 RAM 内存耗尽而终止进程。配置过多 swap 空间会造成存储 设备处于分配状态但闲置，这是浪费资源。过多 swap 空间还会掩盖内存泄露。内存小于4G的为内存的2倍  内存大于4G的和内存大小一致即可 。下表根据系统中的 RAM 容量以及是否需要足够的内存以便系统休眠来提供推荐的 swap 分区大小。    

| 系统 RAM 容量 | 建议 swap 空间大小        | 允许休眠的建议 swap 空间大小 |
| ------------- | ------------------------- | ---------------------------- |
| 低于 2 GB     | RAM 容量的两倍            | RAM 容量的三倍               |
| 2 GB - 8 GB   | 与 RAM 容量相等           | RAM 容量的两倍               |
| 8 GB - 64 GB  | 4 GB 到 RAM 容量的 0.5 倍 | RAM 容量的 1.5 倍            |
| 超过 64 GB    | 独立负载（至少 4GB）      | 不建议使用休眠功能           |

- `/var` ：/var 分配 8-12 GB 对于桌面系统来说是比较合适的取值，具体取值取决于安装的软件数量。/var 目录中包含大量的应用程序变量数据，例如 spool 目录和文件，管理和登录数据，pacman 的缓存，ABS 树，Apache 网页服务器，临时下载的更新软件包等等。它通常被用作缓存或者日志记录，因此读写频繁。将它独立出来可以避免由于大量日志写入造成的磁盘空间耗尽等问题。确定包含 /var 目录的分区中有足够空间可用于保存下载的更新以及其他内容。PackageKit 更新软件默认将更新的软件包下载到 /var/cache/yum/。如果要为 /var 生成独立分 区，请确定 /var/cache/yum/ 大小至少在 3.0 GB 以上以便保存下载的软件包更新。
- `/usr` ：/user 目录中包含 Red Hat Enterprise Linux 系统中大部分软件内容。要安装默认软件组需要分配至少 5 GB 空间。如果将该系统作为软件开发工作站使用，则至少需要分配 10GB。如果 /usr 或 /var 是在剩余 root 卷之外进行分区，引导过程会变得非常复杂，因为这些目录包含对引导 极为重要的组件。在某些情况下，比如这些目录位于 iSCSI 驱动器或 FCoE 位置， 系统可能无法引导，或 者在关机或重启时挂起，并给出 Device is busy 出错信息。这些限制仅适用于 /usr 或 /var，不会对以下目录产生影响。例如：/var/www 的独立分区可正常工 作，没有任何问题。    
- `/boot/efi` ：如果使用 UEFI 引导方式，则还需要 /boot/efi 分区，该分区应至少应有 50 MB，建议使用 200 MB。我们可以根据需要（比如安装 Weblogic 和 Oracle 时）创建额外的分区。如果您将子目录分成分区，就可以在决定使用当前安装 Red Hat Enterprise Linux 新版时保留那些子目录中的内容。例如：如果您要在 /var/lib/mysql 中运行 MySQL 数据库，请将那个目录放在单独的分 区中，以备之后您需要重新安装。    
- `/data`：可以为需要多用户共享的文件建立一个 data 分区，比如 Oracle 的数据库实例可以放在该目录下。

###    创建文件系统

在 Windows 环境下，格式化的操作相对简单。通常的操作步骤是：先打开资源管理器，接着在希望被执行格式化的盘符图标上右击，然后选择“格式化”，再按照提示操作即可。需要注意的是：对硬盘执行格式化操作时，用户需要拥有系统管理员权限（仅限于 Windows Vista 以及此后推出的作业系统。）在 Windows 环境中，除了可以使用图形化的操作界面执行格式化操作之外，也可以在命令提示字符中使用 `Diskpart 指令`（仅限于 Windows 2000 及以后的作业系统，包含 Windows PE）进行操作。

在 Unix/Linux 环境下，通常使用命令工具执行格式化操作。需要注意的是：对硬盘执行格式化操作时，用户需要拥有超级用户权限。创建文件系统的常用命令如下：

- mkfs：创建一个 ext 文件系统；
- mke2fs：创建一个 ext2 文件系统；
- mkfs.ext2：创建一个 ext2 文件系统；
- mkfs.ext3：创建一个 ext3 文件系统；
- mkfs.ext4：创建一个 ext4 文件系统；
- mkfs.xfs：创建一个 XFS 文件系统；
- xfs_mkfile：创建一个 XFS t文件系统；
- mkfs.cramfs：创建一个 cramfs 文件系统；
- mkfs.btrfs：创建一个 Btrfs 文件系统；
- mkswap：创建一个 swap 文件系统；
- jfs_mkfs：创建一个 JFS 文件系统。  

并非所有文件系统的命令工具都已经默认安装了。要想知道某个文件系统的命令工具是否可用，可以使用 type命令。

```shell
[root@localhost ~]# type mkfs
mkfs is /usr/sbin/mkfs
[root@localhost ~]# type mke2fs
mke2fs is /usr/sbin/mke2fs
[root@localhost ~]# type mkfs.ext2
mkfs.ext2 is /usr/sbin/mkfs.ext2
[root@localhost ~]# type mkfs.ext3
mkfs.ext3 is /usr/sbin/mkfs.ext3
[root@localhost ~]# type mkfs.ext4
mkfs.ext4 is /usr/sbin/mkfs.ext4
[root@localhost ~]# type mkfs.xfs
mkfs.xfs is /usr/sbin/mkfs.xfs
[root@localhost ~]# type mkfs.cramfs
mkfs.cramfs is /usr/sbin/mkfs.cramfs
[root@localhost ~]# type mkfs.btrfs
mkfs.btrfs is /usr/sbin/mkfs.btrfs
[root@localhost ~]# type xfs_mkfile
xfs_mkfile is /usr/sbin/xfs_mkfile
[root@localhost ~]# type mkswap
mkswap is /usr/sbin/mkswap
[root@localhost ~]# type jfs_mkfs
-bash: type: jfs_mkfs: not found
```

每个文件系统命令都有很多命令行选项，允许你定制如何在分区上创建文件系统。要查看所 有可用的命令行选项，可用 man 命令来显示该文件系统命令的手册页面。所有的文件系统命令都允许通过不带选项的简单命令来创建一个默认的文件系统。

```shell

[root@localhost ~]# parted
GNU Parted 3.1
Using /dev/sda
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) select /dev/sdb
Using /dev/sdb
(parted) print                                                            
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 21.5GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End     Size    Type     File system  Flags
 1      1049kB  2149MB  2147MB  primary  ext4
 2      2149MB  4296MB  2147MB  primary
 3      4296MB  5370MB  1074MB  primary

(parted) q                                                                
[root@localhost ~]# mkfs.ext3 /dev/sdb2
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
131072 inodes, 524288 blocks
26214 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=536870912
16 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376, 294912

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done 

[root@localhost ~]# parted
GNU Parted 3.1
Using /dev/sda
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) select /dev/sdb                                                  
sdb   sdb1  sdb2  sdb3  
(parted) select /dev/sdb
Using /dev/sdb
(parted) print                                                            
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 21.5GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End     Size    Type     File system  Flags
 1      1049kB  2149MB  2147MB  primary  ext4
 2      2149MB  4296MB  2147MB  primary  ext3
 3      4296MB  5370MB  1074MB  primary

(parted) q
[root@localhost ~]# 
```

为分区创建了文件系统之后，下一步是将它挂载到虚拟目录下的某个挂载点，这样就可以将 数据存储在新文件系统中了。你可以将新文件系统挂载到虚拟目录中需要额外空间的任何位置。

```shell
[root@localhost ~]# mkdir /data
[root@localhost ~]# cd /
[root@localhost /]# ll
total 70
lrwxrwxrwx.   1 root root     7 May  4 06:32 bin -> usr/bin
dr-xr-xr-x.   5 root root  1024 May  8 21:44 boot
drwxr-xr-x.   2 root root  4096 May 13 20:47 data
drwxr-xr-x.  20 root root  3400 May 13 20:43 dev
drwxr-xr-x. 139 root root 12288 May 13 20:25 etc
drwxr-xr-x.   4 root root  4096 May  4 06:46 home
lrwxrwxrwx.   1 root root     7 May  4 06:32 lib -> usr/lib
lrwxrwxrwx.   1 root root     9 May  4 06:32 lib64 -> usr/lib64
drwx------.   2 root root 16384 May  4 06:32 lost+found
drwxr-xr-x.   2 root root  4096 Nov  5  2016 media
drwxr-xr-x.   3 root root  4096 May  8 21:41 mnt
drwxr-xr-x.   3 root root  4096 May  4 06:42 opt
dr-xr-xr-x. 182 root root     0 May  8 07:35 proc
dr-xr-x---.   5 root root  4096 May 13 20:19 root
drwxr-xr-x.  41 root root  1200 May 13 11:23 run
lrwxrwxrwx.   1 root root     8 May  4 06:32 sbin -> usr/sbin
drwxr-xr-x.   2 root root  4096 Nov  5  2016 srv
dr-xr-xr-x.  13 root root     0 May  8 07:35 sys
drwxrwxrwt.  20 root root  4096 May 13 20:42 tmp
drwxr-xr-x.  13 root root  4096 May  4 06:32 usr
drwxr-xr-x.  22 root root  4096 May  8 07:35 var
[root@localhost /]# mount -t ext4 /dev/sdb1 /data
[root@localhost /]# ls -al /data
total 24
drwxr-xr-x.  3 root root  4096 May 13 20:39 .
dr-xr-xr-x. 19 root root  4096 May 13 20:47 ..
drwx------.  2 root root 16384 May 13 20:39 lost+found
[root@localhost /]# df -h
Filesystem           Size  Used Avail Use% Mounted on
/dev/mapper/cl-root  9.8G  4.6G  4.7G  50% /
devtmpfs             474M     0  474M   0% /dev
tmpfs                489M  156K  489M   1% /dev/shm
tmpfs                489M   14M  476M   3% /run
tmpfs                489M     0  489M   0% /sys/fs/cgroup
/dev/sda1            477M  142M  307M  32% /boot
/dev/mapper/cl-home  5.8G  276M  5.2G   5% /home
tmpfs                 98M   24K   98M   1% /run/user/1000
tmpfs                 98M     0   98M   0% /run/user/0
/dev/sdb1            2.0G  6.0M  1.8G   1% /data
[root@localhost /]# 
```

mkdir 命令在虚拟目录中创建了挂载点， mount 命令将新的硬盘分区添加到挂载点。 mount 命令的 -t 选项指明了要挂载的文件系统类型。现在你可以在新分区中保存新文件和目录了！ 这种挂载文件系统的方法只能临时挂载文件系统。当重启Linux 系统时，文件系统并不会自动挂载。要强制 Linux 在启动时自动挂载新的文件系统，可以将其添加到 /etc/fstab 文件。

### 逻辑卷管理（LVM）

如果用标准分区在硬盘上创建了文件系统，为已有文件系统添加额外的空间多少是一种痛苦的体验。你只能在同一个物理硬盘的可用空间范围内调整分区大小。如果硬盘上没有地方了，你 就必须弄一个更大的硬盘，然后手动将已有的文件系统移动到新的硬盘上。 这时候可以通过将另外一个硬盘上的分区加入已有文件系统，动态地添加存储空间。 Linux 逻辑卷管理器（logical volume manager， LVM）软件包正好可以用来做这个。它可以让你在无需重建整个文件系统的情况下，轻松地管理磁盘空间。 

#### 逻辑卷管理布局

逻辑卷管理的核心在于如何处理安装在系统上的硬盘分区。在逻辑卷管理的世界里，硬盘称作**物理卷（physical volume， PV）**。每个物理卷都会映射到硬盘上特定的物理分区。 多个物理卷集中在一起可以形成一个**卷组（volume group， VG）**。逻辑卷管理系统**将卷组视为一个物理硬盘**，但事实上卷组可能是由分布在多个物理硬盘上的多个物理分区组成的。**卷组提供了一个创建逻辑分区的平台，而这些逻辑分区则包含了文件系统。 整个结构中的最后一层是逻辑卷（logical volume， LV）**。**逻辑卷为Linux提供了创建文件系统的分区环境，作用类似于到目前为止我们一直在探讨的Linux 中的物理硬盘分区。Linux 系统将逻辑卷视为物理分区。 可以使用任意一种标准 Linux 文件系统来格式化逻辑卷，然后再将它加入Linux虚拟目录中的 某个挂载点**。    

![lvm01](/lvm01.png)

Linux 系统将每个逻辑卷视为一个物理分区。每个逻辑卷可以被格式化成某种文件系统，然后挂载到虚拟目录中某个特定位置。 注意，上图中的第三个物理硬盘有一个未使用的分区。通过逻辑卷管理，你随后可以轻松地将这个未使用分区分配到已有卷组：要么用它创建一个新的逻辑卷，要么在需要更多空间时用它来扩展已有的逻辑卷。 类似地，如果你给系统添加了一块硬盘，逻辑卷管理系统允许你将它添加到已有卷组，为某个已有的卷组创建更多空间，或是创建一个可用来挂载的新逻辑卷。这种扩展文件系统的方法要好用得多！    

#### Linux LVM

Linux LVM 是由 Heinz Mauelshagen 开发的，于 1998年 发布到了 Linux 社区。它允许你在 Linux 上用简单的命令行命令管理一个完整的逻辑卷管理环境。 Linux LVM 有两个可用的版本。 

- LVM1：最初的 LVM 包于 1998 年发布，只能用于 Linux 内核 2.4 版本。它仅提供了基本的逻 辑卷管理功能。
- LVM2： LVM 的更新版本，可用于 Linux 内核 2.6 版本。它在标准的 LVM1 功能外提供了额外的功能。

大部分采用 2.6 或更高内核版本的现代 Linux 发行版都提供对 LVM2 的支持。除了标准的逻辑卷管理功能外， LVM2 还提供了另外一些好用的功能。 

1. **快照**。

   最初的Linux LVM允许你在逻辑卷在线的状态下将其复制到另一个设备。这个功能叫作快 照。在备份由于高可靠性需求而无法锁定的重要数据时，快照功能非常给力。传统的备份方法在 将文件复制到备份媒体上时通常要将文件锁定。快照允许你在复制的同时，保证运行关键任务的 Web 服务器或数据库服务器继续工作。遗憾的是， LVM1 只允许你创建只读快照。一旦创建了快照，就不能再写入东西了。 LVM2 允许你创建在线逻辑卷的可读写快照。有了可读写的快照，就可以删除原先的逻辑卷， 然后将快照作为替代挂载上。这个功能对快速故障转移或涉及修改数据的程序试验（如果失败， 需要恢复修改过的数据）非常有用。    

2.  **条带化**。

   LVM2 提供的另一个引人注目的功能是条带化（striping）。有了条带化，可跨多个物理硬盘创建逻辑卷。当Linux LVM 将文件写入逻辑卷时，文件中的数据块会被分散到多个硬盘上。每个后继数据块会被写到下一个硬盘上。 条带化有助于提高硬盘的性能，因为 Linux 可以将一个文件的多个数据块同时写入多个硬盘， 而无需等待单个硬盘移动读写磁头到多个不同位置。这个改进同样适用于读取顺序访问的文件， 因为 LVM 可同时从多个硬盘读取数据。

   > LVM 条带化不同于 RAID 条带化。 LVM 条带化不提供用来创建容错环境的校验信息。事实上， LVM 条带化会增加文件因硬盘故障而丢失的概率。单个硬盘故障可能会造成多个逻辑卷无法访问。        

3. **镜像**。

   通过 LVM 安装文件系统并不意味着文件系统就不会再出问题。和物理分区一样， LVM 逻辑卷也容易受到断电和磁盘故障的影响。一旦文件系统损坏，就有可能再也无法恢复。 LVM 快照功能提供了一些安慰，你可以随时创建逻辑卷的备份副本，但对有些环境来说可能还不够。对于涉及大量数据变动的系统，比如数据库服务器，自上次快照之后可能要存储成百上千条记录。 这个问题的一个解决办法就是 LVM 镜像。镜像是一个实时更新的逻辑卷的完整副本。当你创建镜像逻辑卷时， LVM 会将原始逻辑卷同步到镜像副本中。根据原始逻辑卷的大小，这可能需要一些时间才能完成。 一旦原始同步完成， LVM 会为文件系统的每次写操作执行两次写入——一次写入到主逻辑卷，一次写入到镜像副本。可以想到，这个过程会降低系统的写入性能。就算原始逻辑卷因为某些原因损坏了，你手头也已经有了一个完整的最新副本！

#### 使用 Linux LVM

Linux LVM 包只提供了命令行程序来创建和管理逻辑卷管理系统中所有组件。有些 Linux 发行版则包含了命令行命令对应的图形化前端，但为了完全控制你的 LVM 环境，最好习惯直接使用这些命令。

1. **定义物理卷**

   创建过程的第一步就是将硬盘上的物理分区转换成 Linux LVM 使用的物理卷区段。fdisk 命令可以帮忙。在创建了基本的 Linux 分区之后，你需要通过 t 命令改变分区类型。

   ```shell
   
   ```

   分区类型 8e 表示这个分区将会被用作 Linux LVM 系统的一部分，而不是一个直接的文件系统。

   下一步是用分区来创建实际的物理卷。这可以通过 pvcreate 命令来完成。 pvcreate 定义了用于物理卷的物理分区。它只是简单地将分区标记成 Linux LVM 系统中的分区而已。

   ```shell
   
   ```

   > 别被吓人的消息 dev_is_mpath: failed to get device for 8:17 或类似的消息唬住了。只要看到了 successfully created 就没问题。 pvcreate 命令会检查分区是否为多路（multi-path， mpath）设备。如果不是的话，就会发出上面那段消息。    

   如果你想查看创建进度的话，可以使用 pvdisplay 命令来显示已创建的物理卷列表。

   ```shell
   
   ```

   pvdisplay 命令显示出 /dev/sdb1 现在已经被标记为物理卷。注意，输出中的 VG Name 内容为空，因为物理卷还不属于某个卷组。

2. **创建卷组**

   下一步是从物理卷中创建一个或多个卷组。究竟要为系统创建多少卷组并没有既定的规则， 你可以将所有的可用物理卷加到一个卷组，也可以结合不同的物理卷创建多个卷组。 要从命令行创建卷组，需要使用 vgcreate 命令。 vgcreate 命令需要一些命令行参数来定义卷组名以及你用来创建卷组的物理卷名。

   ```shell
   
   ```

   输出结果平淡无奇。如果你想看看新创建的卷组的细节，可用 vgdisplay 命令。

   ```shell
   
   ```

   这个例子使用 /dev/sdb1 分区上创建的物理卷，创建了一个名为 Vol1 的卷组。 创建一个或多个卷组后，就可以创建逻辑卷了。

3. **创建逻辑卷**

   Linux 系统使用逻辑卷来模拟物理分区，并在其中保存文件系统。 Linux 系统会像处理物理分区一样处理逻辑卷，允许你定义逻辑卷中的文件系统，然后将文件系统挂载到虚拟目录上。 要创建逻辑卷，使用 lvcreate 命令。虽然你通常不需要在其他 Linux LVM 命令中使用命令行选项，但 lvcreate 命令要求至少输入一些选项。

   -  

   虽然命令行选项看起来可能有点吓人，但大多数情况下你用到的只是少数几个选项。

   ```shell
   
   ```

   如果想查看你创建的逻辑卷的详细情况，可用 lvdisplay 命令。

   ```shell
   
   ```

   卷组名（Vol1）用来标识创建新逻辑卷时要使 用的卷组。 -l选项定义了要为逻辑卷指定多少可用的卷组空间。注意，你可以按照卷组空闲空间的百分 比来指定这个值。本例中为新逻辑卷使用了所有的空闲空间。 你可以用-l选项来按可用空间的百分比来指定这个大小，或者用-L选项以字节、千字节 （KB）、兆字节（MB）或吉字节（GB）为单位来指定实际的大小。 -n选项允许你为逻辑卷指定 一个名称（在本例中称作lvtest）。    

4. **创建文件系统**

   运行完 lvcreate 命令之后，逻辑卷就已经产生了，但它还没有文件系统。你必须使用相应的命令行程序来创建所需要的文件系统。

   ```shell
   
   ```

   在创建了新的文件系统之后，可以用标准 mount 命令将这个卷挂载到虚拟目录中，就跟它是物理分区一样。唯一的不同是你需要用特殊的路径来标识逻辑卷。

   注意，mkfs.ext4 和 mount 命令中用到的路径都有点奇怪。路径中使用了卷组名和逻辑卷名，而不是物理分区路径。文件系统被挂载之后，就可以访问虚拟目录中的这块新区域了。

5. 修改LVM Linux LVM的好处在于能够动态修改文件系统，因此最好有工具能够让你实现这些操作。在 Linux有一些工具允许你修改现有的逻辑卷管理配置。

  vgchange 激活和禁用卷组
  vgremove 删除卷组
  vgextend 将物理卷加到卷组中
  vgreduce 从卷组中删除物理卷
  lvextend 增加逻辑卷的大小
  lvreduce 减小逻辑卷的大小   

  在手动增加或减小逻辑卷的大小时，要特别小心。逻辑卷中的文件系统需要手动修整来 处理大小上的改变。大多数文件系统都包含了能够重新格式化文件系统的命令行程序， 比如用于 ext2、 ext3 和 ext4 文件系统的 resize2fs 程序。              
