---
typora-copy-images-to: ..\..\graphs\photos
typora-root-url: ./
---

全新硬盘装系统之前，必须对其进行分区，硬盘分区初始化的格式主要有两种：传统的 MBR（[Master Boot Record](https://en.wikipedia.org/wiki/Master_boot_record) ，即主引导记录）  和新的 GPT（ [GUID Partition Table](https://wiki.archlinux.org/index.php/GUID_Partition_Table)）。后者功能更强大，解决了 MBR 的许多限制。

### MBR

MBR 早在 1983 年 IBM PC DOS 2.0 中就已经提出。之所以叫“主引导记录”，是因为它位于驱动器开始部分的主引导扇区，是硬盘的第一扇区。它由三个部分组成：**Boot loader、硬盘分区表 DPT 和结束标志字**。

![201610170953378340](https://github.com/hzxrosydawn/graphs/blob/master/photos/201610170953378340.png?raw=true)

- 第一部分为 Boot loader，位于主引导扇区的前 446 个字节，偏移地址为 0000H--0088H，是一小段代码，用于加载硬盘上其他分区上更大的加载器（如操作系统的启动加载器）。**如果你安装了 Windows，Windows 启动加载器的初始信息就放在这个区域里。如果 MBR 的信息被覆盖导致 Windows不能启动，你就需要使用启动优盘中 DiskGenius 软件提供的重建 MBR 功能来使其恢复正常。如果你安装了 Linux，则这里通常存储的是 GRUB 启动加载器的初始信息**。该区域主要提供以下三个功能：
  - **提供启动引导菜单**：使用者可以在该菜单中选择启动不同的开机项。在系统未加载前按下主板[快速启动的快捷键]()就可以看到该菜单；
  - 指向开机所需的核心文件来启动操作系统；
  - 还可将开机引导权交给其它 loader。每个分区也拥有自己的启动扇区（Boot sector），开机引导程序除了可以装在这里外，还可装在各分区的启动扇区。
- 第二部分为 Disk partition table 区（DPT分区表），占 64 个字节，偏移地址为 01BEH--01FDH，记录整个磁盘分区的状态，每 16 个字节标记一个分区，因此最多可记录 4 个分区。**分区的单位是柱面**，每个 16 字节的记录区记录了该分区从开始到结束的柱面号。所谓的分区操作即是对分区表进行设置，当文件系统要写入磁盘时，首先会参考分区表。在 MBR 分区表中，逻辑块地址采用 32 位二进制数表示，因此一共可表示 2 的 32 次方个逻辑块地址，所以，MBR 硬盘最大分区容量仅为 2.2 TB = 2^32 × 512 bytes；
- 第三部分是结束标志字，占 2 个字节，偏移地址为 01FEH--01FFH。固定为 55AA，是检验主引导记录是否有效的标志。该标志错误将导致系统不能启动。

上面所说的分区为**主分区（primary partition）**。**一个磁盘或者 RAID 卷上只能有 4 个可启动的主分区**。如果 MBR 分区方案需要使用 4 个以上的分区，那就需**将至少一个主分区作为扩展分区（extend partition），然后在该扩展分区上面建立若干个逻辑分区（logic partition）**。扩展分区可以被看作是容纳逻辑分区的容器。**硬盘上最多只能有 1 个扩展分区（操作系统的限制）且其本身不能格式化，必须划分逻辑分区后才能使用，但扩展分区中的逻辑分区没有数量限制**。扩展分区也被看作是一个主分区，因此，在存在扩展分区的情况下最多只能再建 3 个主分区（3 个主分区加 1 个可包含多个逻辑分区的扩展分区）。

扩展分区中逻辑驱动器的引导记录是链式的。每一个逻辑分区都有一个和 MBR 结构类似的扩展引导记录（EBR），其分区表的第一项指向该逻辑分区本身的引导扇区，第二项指向下一个逻辑驱动器的 EBR，分区表第三、第四项没有用到。

### BIOS

**BIOS**（Basic Input Output System）即**基本输入输出系统** ，它是个人电脑启动时加载的第一个软件。其实，它是一个存储在计算机内主板 BOIS 芯片上的程序，它保存着计算机最重要的基本输入输出的程序、加电自检程序（Power On Self Test，简称 POST 自检）和系统启动程序等。

一般在计算机启动时按 F2 或者 Delete 即可进入 BIOS 程序进行设置（一些特殊机型按 F1、Esc、F12 等进行设置）。 其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。

### UEFI

**UEFI** 的全称是 **Unified Extensible Firmware Interface**，意即**统一可扩展固件接口**，它是基于 EFI 1.10 标准为基础发展而来，值得注意的是在 UEFI 正式确立之前，Intel 就开始积极推进传统 BIOS 的升级方案，并最终确立了过渡方案 EFI 标准，直到 2007 年 Intel 将 EFI 标准的改进与完善工作交给 Unified EFI Form 进行全权负责，EFI 标准则正式更名为 UEFI。UEFI 其实和 BIOS 是同一类程序，是随着硬件发展而出现的 BIOS 升级版，被看做是有近20多年历史的传统的（Legacy）BIOS 的继任者。UEFI 一般就是指 UEFI BIOS 环境，而和 UEFI 比较时的所说的 BOIS 则是指传统的 BIOS 环境。

相比 BIOS，UEFI 的一些优点在于：

1.  高效开发。BIOS 开发一般采用汇编语言，代码多是硬件相关的代码。而在 UEFI 中，绝大部分代码采用 C 语言编写，UEFI 应用程序和驱动甚至可以使用 C++ 编写。UEFI通过固件操作系统接口（BS 和 RT 服务）为 OS 和 OS 加载器屏蔽了底层硬件细节，使得 UEFI 上层应用可以方便重用。
2.  可扩展性。UEFI 的模块化设计在逻辑上分为硬件控制与 OS（操作系统）软件管理两部分，硬件控制为所有 UEFI 版本所共有，而 OS 软件管理其实是一个可编程的开放接口。借助这个接口，主板厂商可以实现各种丰富的功能。比如我们熟悉的各种备份及诊断功能可通过 UEFI 加以实现，主板或固件厂商可以将它们作为自身产品的一大卖点。UEFI 也提供了强大的联网功能，其他用户可以对你的主机进行可靠的远程故障诊断，而这一切并不需要进入操作系统。
3.  **缩短启动和休眠恢复时间**。UEFI 可运行于 32 位或 64 位模式，突破了传统 16 位代码的寻址能力，达到处理器的最大寻址，此举克服了 BIOS 代码运行缓慢的弊端。
4.  **启动的安全性**。当系统的安全启动功能被打开后，UEFI 在执行应用程序和驱动前会先检测程序和驱动的证书，仅当证书被信任时才会执行这个应用程序或驱动。UEFI 应用程序和驱动采用 PE/COFF 格式，其签名放在签名块中。
5.  **更大的磁盘容量和分区数量**。传统 MBR 分区最大只能支持 2.2 TB 的硬盘和 4 个主分区，而 UEFI 规范之一的 GPT 分区格式，则可以支持过百 TB 大小的硬盘和 100 个主分区。
6.  兼容性。与 BIOS 不同的是，UEFI 体系的驱动并不是由直接运行在 CPU 上的代码组成的，而是用 EFI Byte Code（EFI字节代码）编写而成的。EFI Byte Code 是一组类似于 Java 类文件的虚拟机器指令，必须在 UEFI 驱动运行环境下被解释运行，由此保证了充分的向下兼容性。
7.  **鼠标操作**。UEFI 内置图形驱动功能，可以提供一个高分辨率的彩色图形环境，用户进入后能用鼠标点击调整配置，一切就像操作 Windows 系统下的应用软件一样简单。

相比传统的 BIOS，UEFI 还提供了文件系统的支持，它**能够直接读取 FAT、FAT32 分区中的文件**，例如华硕、华擎等主板在 UEFI 环境下更新 BIOS 就**可以直接读取 U 盘中的 BIOS 及其他文件**，另外**新的 UEFI 主板基本都提供了截屏功能，这些截屏图片都可以存储在U盘当中**。

**UEFI 还有一个重要特性就是在 UEFI 下运行应用程序，这类程序文件通常以 efi 结尾。利用 UEFI 可以直接识别 FAT 分区中的文件，又可直接在其中运行应用程序**。我们就可以将 Windows 安装程序做成 efi 类型应用程序，然后把它放到任意FAT 分区中直接运行即可。

当然由于 UEFI 主要由高级语言编写（C语言），相比于传统 BIOS 的汇编语言，UEFI BIOS 在安全防护性方面相比传统 BIOS 要弱，比较容易遭到病毒的攻击，安全性有待进一步提升。不过在图形化界面、应用程序扩展面前，UEFI BIOS 还是非常成功的。

现在，多数主板为了兼容 MBR 分区表，一般会提供 Legacy BIOS 和 UEFI BIOS 启动模式选项，如果要使用 UEFI 模式安装操作系统，就必须开启 UEFI 模式。UEFI 模式可切换回 BIOS 模式，而仅有 BIOS 模式时无法切换为 UEFI 模式。 

目前 64bit Windows Vista、7、8、8.1、10 都已经支持 GPT 分区表，而 Windows 8、8.1、10 都已经原生支持 UEFI，安装这些系统的时候：只要硬盘设置为 GPT 分区表 主板设置为 UEFI 启动后，就可以直接开始安装操作系统了。自 Win8 发布以来，新出厂的预装 Win8/Win8.1 的电脑都默认在 UEFI 式下启动操作系统。

而对于 Windows Vista、7 系统，就需要手动添加 UEFI 支持，我们可以找一份 Windows 8 或者 10 安装镜像，从安装文件中提取 Bootmgfw.efi 文件，重命名为 BOOTX64.EFI，拷贝到 Win7 安装文件的 \EFI\Boot\ 下，如果没有 BOOT 文件夹就新建一个。

### GPT

GPT 的全称是 Globally Unique Identifier Partition Table，意即 [GUID 分区表](http://www.jinbuguo.com/storage/gpt.html)。UEFI BOIS 将逐渐取代 Legacy  BOIS ，而 GPT 也将逐渐取代 MBR。UEFI 和 GPT 是相辅相成的，二者缺一不可，要想使用 GPT 分区表则必须是 UEFI BIOS 环境。

与支持最大 **2T** 磁盘和 RAID 卷且至多有 4 个主分区的 MBR 分区表相比， **GPT 分区表**能支持最大 18 EB（Exabytes）磁盘和 RAID 卷。并且磁盘和 RAID 卷的分区数没有上限，只受到操作系统限制（由于分区表本身需要占用一定空间，最初规划硬盘分区时，留给分区表的空间决定了最多可以有多少个分区）。比如，在 Windows 系统上，由于系统的限制 GPT 最多只能支持 128个 磁盘分区，基本可以满足所有用户的存储需求。在每一个分区上，这个标识符是一个随机生成的字符串，可以保证为地球上的每一个 GPT 分区都分配完全唯一的标识符。

![201610170953379290](https://github.com/hzxrosydawn/graphs/blob/master/photos/201610170953379290_%E7%9C%8B%E5%9B%BE%E7%8E%8B-9799511705.jpg?raw=true)

在安全性方面，GPT 分区表也进行了全方位改进。在早期的 MBR 磁盘上，分区和启动信息是保存在一起的。如果这部分数据被覆盖或破坏，事情就麻烦了。相对的，GPT 在整个磁盘上保存多个这部分信息的副本，因此它更为健壮，并可以恢复被破坏的这部分信息。GPT 还为这些信息保存了循环冗余校验码（CRC）以保证其完整性和正确性——如果数据被破坏，GPT 会发觉这些破坏，并从磁盘上的其他地方进行恢复。

### MBR  or GPT

GPT 相对于诞生于 MS-DOS 时代的 MBR 而言，有许多优点。在做出选择前，需要考虑如下内容：

- **如果使用 GRUB legacy 作为 bootloader，必须使用 MBR**。
- **如果使用传统的 BIOS，并且双启动中包含 Windows （无论是 32 位版还是 64位 版），必须使用 MBR**。
- **如果使用 UEFI 而不是 BIOS，并且双启动中包含 Windows 64 位版，必须使用 GPT**。
- 非常老的机器需要使用 MBR，因为 BIOS 可能不支持 GPT.
- 如果不属于上述任何一种情况，可以随意选择使用 GPT 还是 MBR。由于 GPT 更先进，建议选择 GPT。
- 建议在使用 UEFI 的情况下选择 GPT，因为有些 UEFI firmware 不支持从 MBR 启动。
- 为了使 GRUB 从一台有 GPT 分区的基于 BIOS 的系统上启动，需要创建一个 BIOS 启动分区, 这个分区和 /boot 没关系，仅仅是 GRUB 使用，不要建立文件系统和挂载。


以下为主流操作系统对 GPT 的支持情况列表。

![Cg-4zFTdcXWIU7ABAAWGKozbRYUAAUsRQLKPWsABYZC801](https://github.com/hzxrosydawn/graphs/blob/master/photos/Cg-4zFTdcXWIU7ABAAWGKozbRYUAAUsRQLKPWsABYZC801.jpg?raw=true)

更详细的支持列表可参考[维基百科](https://zh.wikipedia.org/wiki/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8#.E6.93.8D.E4.BD.9C.E7.B3.BB.E7.BB.9F.E6.94.AF.E6.8C.81)。

对于新平台用户（Intel 6 系以后 /AMD 900 系列以后和 A 系列）来说，都强烈推荐使用 GPT 分区表格式。目前包括 Win Vista、Win7、Win8、Win8.1、Win10 已经都支持读取和使用 GPT 分区表。而对于使用 Win8、Win8.1、Win10 的用户，换用 GPT 后开机启动速度也可以进一步得到显著提升。

### 选择引导方式和分区格式

由于现在刚出的新电脑基本都是 UEFI + GPT 的，如果要更换系统就必须按照 GPT 分区格式 + UEFI 引导的方式去安装。但如果想使用以前的 MBR 方式去安装（比如安装 Ghost 系统）那就只能将转换硬盘的分区格式转换为 MBR 、修改系统引导方式为 Legacy、重新分区再安装。

**如果在分区格式为 MBR 的硬盘上安装较新的 Windows 系统时忘了把之前 MBR 分区格式改为 GPT，然后在选择 Windows 安装位置时不能继续**，如下图所示。

![1306Windows-8-2013-06-08-20-13-39](https://github.com/hzxrosydawn/graphs/blob/master/photos/1306Windows-8-2013-06-08-20-13-39.png?raw=true)

这个时候就需要将硬盘分区格式修改为 GPT，修改系统引导方式为 UEFI、重新分区再安装。

#### 查看操作系统的引导方式

##### Windows 系统

**方法一**

在安装操作系统时，安装程序会收集一些必备信息，电脑的启动方式就是其中之一。可以在 Windows 电脑上的 C:\Windows\Panther 文件夹中找到 setupact.log 文件，用记事本打开，然后搜索 Detected Boot Environment，在这里你就可以看到系统启动方式了。

![20150508_141525_232](/../../graphs/photos/20150508_141525_232.jpg)

**方法二**

如果你知晓 GPT 与 UEFI 启动之间的关系，那么你可能知道，Windows 想要从 GPT 硬盘引导，就必须以 UEFI 方式启动（反之则不成立）。在磁盘管理中看一下硬盘类型，如果是 GPT，那么电脑肯定就是 UEFI 启动了。打开磁盘管理，在主硬盘上右键单击，如果出现“转换成 GPT 磁盘”，那说明硬盘为 MBR 类型；如果出现“转换成 MBR 磁盘”则说明硬盘为 GPT 类型（因为是主硬盘，这一项是灰色不可用状态）。

![](/../../graphs/photos/20150508_141539_737.jpg)

**方法三**

该方法适用于 Win 8 及更高版本的 Windows 系统。按 Win+R 打开运行，输入 msinfo32，回车查看系统信息。在 BIOS 模式中如果显示“传统”，表示系统启动方式为 Legacy BIOS；如果为 UEFI，则显示 UEFI。

![](/../../graphs/photos/20150508_141600_274.jpg)

##### Linux 系统

**方法一**

可以通过查看是否存在 /sys/firmware/efi  目录就可以判断出是否为 UEFI 引导方式。

**方法二**

也可以通过安装 efibootmgr 程序，然后执行 sudo efibootmgr 命令即可查看 Linux 系统是否支持 UEFI 引导方式。

##### 终极查看方法

下面介绍一种适用于任何操作系统的查看即修改方法。

在系统开始加载前按下热键（一般为 Del、F2 等）进入 BIOS。一般该功能一般位于 Boot 相关的菜单下，不同主板的电脑操作方式大同小异。如下图所示，可以查看当前的引导方法，也可以修改引导方式。

![20160512_172140_341](../../graphs/photos/20160512_172140_341.png)

> 注意：UEFI 引导方式需要主板芯片组支持，如果你在 BIOS 设定中没有找到相应内容，那么很可能就是你的主板并不支持 UEFI 引导方式。近些年的新主板一般都支持 UEFI。

> 不同电脑的快捷启动键有所不同，可以参考这里查看常见主板和笔记本的快捷启动键表。



### Windows 系统设置硬盘分区

分区的容量和数量根据硬盘数量、容量、类型和使用习惯而定。分区容量小了、数量多了会导致各分区之间转移文件很麻烦，分区容量大了、数量少了会增加文件丢失的风险（比如经常直接断电而非正常关机或其他原因导致的硬盘故障），单个分区损坏则该分区中所有文件丢失。

如果你的硬盘够大、够多，比如容量为 1 TB，甚至有多个 1TB 硬盘，那么可以将 Windows 系统所在分区设置为 100 GB，剩下的空间可以按软件安装、媒体存储、文档办公、文件备份等用途来分出合适容量、数量的分区。如果使用 128 GB 或 256 GB 的 SSD + HDD 组合的模式，那么可以将整个 SSD 分为一个分区，将 Windows 和应用软件都安装在整个 SSD 的分区上以便加快开机和应用软件的启动速度。

如果 Windows 系统使用 MBR 分区格式，一般都是只划分一个主分区给系统，剩余的部分全部划入扩展分区。

#### 通过安装 Windows 时的 diskpart 工具

1. 安装系统时在系统版本选择界面按下 `Shift+F10` 快捷键调出命令提示符，如下图所示：

   ![20160512_172343_387](../../graphs/photos/20160512_172343_387.png)

2. 输入 [`diskpart`](https://technet.microsoft.com/zh-cn/library/cc766465(v=ws.10).aspx) 命令后按回车键，进入 DISKPART 工具，如下图所示。

3. 输入 `list disk` 命令后按回车键，查看电脑当前可用硬盘，编号为 0、1、2。。。，如果你只有一块硬盘，则只有 0 号磁盘；有两块硬盘，则还会显示 1 号磁盘，以此类推，如下图所示。


4. 输入 `select disk x`（`x` 为上述硬盘编号），选择你要进行分区操作的硬盘，如果只有一块硬盘，输入`select disk 0` 后按回车键即可，如下图所示。

![20160512_172423_739](../../graphs/photos/20160512_172423_739.png)

5. 执行 `clean` 命令清除该硬盘上的所有分区（记得备份数据，新硬盘无需此步骤），此时会清除所有硬盘数据，如下图所示。
6. 如果是按照 GPT 分区格式安装操作系统，则执行 `convert gpt` 命令将该硬盘转换成 GPT 分区格式，如下图所示。

![20160512_172707_714](../../graphs/photos/20160512_172707_714.png)

   > 当然，如果是按 MBR 分区格式安装系统，也可以创建 MBR 分区格式，使用 `convert mbr` 命令即可。 

7. 创建 EFI 分区，执行 `create partition efi size=200`（分区大小为 200 MB），如下图所示。

> EFI 系统分区，即 EFI system partition，简写为 ESP。ESP 是一个 FAT16 或 FAT32 格式的物理分区，但是其分区标识是 EF (十六进制) 而非常规的 0E 或 0C，因此，该分区在 Windows 操作系统下一般是不可见的。支持 EFI 模式的电脑需要从 ESP 启动系统，EFI 固件可从 ESP 加载 EFI 启动程序或者应用。
>
> **仅当使用 UEFI 模式以及 GPT 分区表的时候需要 EFI 系统分区（又称 ESP），对于 GPT 分区表，EFI 分区是必需的，它用来存放操作系统的引导器（loader），而 MSR 不是必需的，仅当使用 Windows 系统时才需要 MSR 保留分区**。

8. 创建 MSR 分区，执行 `create partition msr size=200`（微软系统保留分区），如下图所示。

> **MSR 分区（Microsoft Reserved Partition，缩写 MSR）即 Microsoft 保留分区，是每个在 GUID 分区表上的 Windows 操作系统（Win 7 及以上）都要求的分区**。系统组件可以将 MSR 分区的部分分配到新的分区以供它们使用。
>
> MSR 分区的大小会因 GPT 磁盘的大小不同而发生变化。对于小于 16 GB 的磁盘，MSR 分区为 32 MB。**对于大于 16 GB 的磁盘，MSR 分区为 128 MB。MSR 分区在“磁盘管理”中不可见，用户也无法在 MSR 分区上存储或删除数据**。
>
> **对于在 GPT 磁盘上的 Windows 操作系统，MSR 分区是必须保留的，不可删除（无法启动可能是由于用 part1，part2… 等表示的分区因为 MSR 分区的删除而改变导致的）。而对于 GPT 磁盘中的其他操作系统，如 Linux、Mac 等则不受影响**。
>
> 可以使用命令：`create partition msr [size=<n>][offset=] [noerr]` 创建 MSR 分区，单位为 MB。
>
> 用 Win8 系统安装版分区时，系统自动划分出“分区 1、2、3”，它们是 Win 8 的特有分区。其中 300 MB 为恢复区，100 MB 为系统分区，128 MB 为 MSR 分区。

9. 创建主分区，执行 `create partition primary size=xxx`（单位为 MB，具体大小根据你的要求而定）（创建结束后，可执行 active 命令设置活动分区，然后可顺便执行 format quick 进行快速格式化。在 MBR 格式下，若要创建扩展分区，则执行：`create partition extended size=n` ，如果你不需要建立其他主分区，可把剩余空间全部划分为扩展分区。在扩展分区中创建逻辑分区，则执行：`create partition logical size=n` 。可建立多个逻辑分区，总容量要小于等于扩展分区，但最好等于扩展分区大小，以免浪费空间。也可以在每个逻辑分区创建完毕后顺便执行 format quick，进行快速格式化。分区结束后，如果忘记格式化，可执行 select partition x，然后为该分区执行 format quick 快速格式化）。
10. 再次输入 `list disk` 命令后按回车键可查看已建立的分区列表。如下图所示。

![20160512_172628_875](../../graphs/photos/20160512_172628_875.png)

> 注意：这里系统安装过程采用虚拟机模拟，模拟硬盘为 60 GB，因此主分区大小设定 30 GB 仅作为操作演示。
>
> 可在进入 DISKPART 工具后输入 help 查看有关 [diskpart](https://technet.microsoft.com/zh-cn/library/cc766465(v=ws.10).aspx) 命令的详细信息。

10. 如果还有剩余空间，可继续重复执行上述命令来创建新的分区（注意修改具体数值）。但**建议用户创建完系统分区后就退出命令提示符（输入 exit 后回车）继续安装系统**，毕竟这种方式不容易估算剩下的硬盘空间大小，进入安装位置选择界面后可以进一步划分剩余空间，如下图所示。也可以在安装后，进入系统磁盘管理中进行分配。

![20160512_173005_16](../../graphs/photos/20160512_173005_16.png)

**这种的方法不需要任何第三方工具，属于最基本方法。好处就在于操作简便直观，缺点在于命令不好记，整个硬盘需要全部格式，数据无法保留**。所以，在操作之前，务必对于硬盘上的重要数据提前备份到其他存储设备上。

#### 使用 Win7/Win8.1/Win10 安装程序自带的分区工具

1. 使用原版系统安装盘（非 Ghost 版）引导电脑。
2. 以未分区硬盘为例，选中未分配空间（多硬盘用户需要按照总大小和可用空间区分好目标硬盘），点击“新建”，如下图 所示。

![20161101_141513_121](../../graphs/photos/20161101_141513_121.jpg)

3. 给出分区大小，单位 MB，比如要想分 30 GB 的区，就写上“30000”，如下图所示。

![20161101_141821_811](../../graphs/photos/20161101_141821_811.jpg)

4. 分区会格式化硬盘，将会清除所有文件。所以重装系统之前做好文件备份。记住，Windows 桌面上的文件是位于 C 盘的。

![20161101_142452_166](../../graphs/photos/20161101_142452_166.jpg)

> 使用 GPT 分区系统会要求创建 MSR 和 EFI 分区，默认为 128 MB 和 100 MB，用于保留空间和存放引导程序等。

4. 同理按照上述方法划分其他区域，如果使用的是 MBR 分区方式，那么在此处最多只能分出 4 个主分区，但如果用 GPT 分区，数量就不限。如下图所示。

![20161101_142437_607](../../graphs/photos/20161101_142437_607.jpg)

5. 分区后可以在此格式化，也可以直接点“下一步”，系统会自动格式化选中的系统分区；其他未格式化的分区可以在系统安装结束后手动格式化。这里的格式化创建的是 NTFS 文件系统。

![20161101_143201_749](../../graphs/photos/20161101_143201_749.jpg)

> 在此处格式化会给出提示，在确认硬盘中并无文件，或者文件已备份的情况下点击“确定”开始格式化。

实际上只有遵循 UEFI 规范的主板才能按照 efi/boot/bootx64.efi 路径启动 Windows 安装程序，大多数主板都是遵循这一规范的。如果不遵循这一规范，那么你需要手动选择从该文件启动，或者需要在 UEFI Shell 中以命令的方式启动bootx64.efi。

#### 使用 DiskGenius 分区软件

这款工具很多资深用户并不陌生，常见于某些国产改版 PE 系统中，当然这些系统中还有其他强大的硬盘操作工具。关于该软件的全部功能用法可以参考[其官网帮助信息](http://www.diskgenius.cn/help/index.php)。

##### 创建 GPT 分区

1. 打开 DiskGenius 工具后就可以很明显看到当前硬盘分区情况，如下图所示。

   ![20161101_151041_857](../../graphs/photos/20161101_151041_857.jpg)

2.  如果现有分区不满意，可以删掉后重新分，如下图所示。

   ![20161101_151746_879](../../graphs/photos/20161101_151746_879.jpg)

3. 删掉所有已有分区后，重新建立分区会首先提示是否新建 ESP 和 MSR 分区，其中 **ESP 分区是必须要建立的**（默认 100 MB 即可），否则 Windows 安装程序无法在选择安装位置后开始安装（UEFI + GPT 用户直接使用安装盘分区会自动创建所需分区，不会出现影响安装的问题），如下图所示。


![20161101_151814_137](../../graphs/photos/20161101_151814_137.jpg)

4. 建立完上述辅助分区后，就可以正式建立主分区，方法同之前介绍的大同小异，无非就是给出分区大小，如下图所示。

![20161101_155717_591](../../graphs/photos/20161101_155717_591.jpg)

如果是为 SSD 新建分区，要勾选 “对齐到下列扇区数的整数倍”，并在 “扇区数” 下拉菜单中选择 “4096”（如上图），以便满足所谓的 “4K 对齐” 条件，这有利于充分发挥 SSD 的性能优势（**原版系统盘安装程序分区时会自动设置 “4K 对齐”**，无需手动设置）。可以通过 DiskGenius 的“工具”菜单中的“分区4K扇区对齐监测”菜单项查看 SSD 是否已经 4K 对齐（最后一列显示为“Y”表示已对齐）。

5. 按照上述方法新建分区，完成后要“**保存更改**”，此时程序会询问你是否顺便格式化这些分区，点击“是”即可开始格式化，完成后这些分区就可以使用了，如下图所示。

![](/../../graphs/photos/20161101_160447_982.jpg)

##### 创建 MBR 分区

这种分区表和 GPT 比起来在分区方式上有一定差异，下面具体说明一下：

1. 可直接新建主分区和扩展分区，不会提示 MSR 等辅助分区建立。

![](/../../graphs/photos/20161101_163048_328.jpg)

2. 主分区用于安装系统和引导系统；**扩展分区及下属的逻辑分区用于存储数据**，GPT 不具备上述结构。

![](/../../graphs/photos/20161101_174631_178.jpg)

3. **主分区最多能建立 4 个，扩展分区只有一个，下属逻辑分区数量不限，主分区和扩展分区总和不超过 4 个**，逻辑分区总量必须小于等于扩展分区容量。

![](/../../graphs/photos/20161101_163140_269.jpg)

> DiskGenius 软件目前支持 NTFS、FAT32、FAT16、exFAT、EXT2、EXT3、EXT4 等文件系统的格式化。

安装 Windows 和 Linux 双系统时，后安装的引导加载程序可能会覆盖之前系统的引导加载程序，这就会导致之前安装的系统的无法被加载。CentOS 7（最近的 Ubuntu） 使用 GRUB2 作为引导加载程序。该引导加载程序是计算机启动后首先运行的程序，负责操作系统的加载及传输控制。GRUB2 可以兼容所有操作系统，同时还可以在不支持的操作系统中使用链式载入将控制权转给其他操作系统。如果先安装 Windows 再安装使用 GRUB2 引导的 Linux，将会使用 GRUB2 引导双系统。而如果先安装 Linux 再安装 Windows，除了 Win10 可以识别出 Linux 系统的引导程序外，其他版本的 Windows 系统都会覆盖已安装 Linux 系统的引导程序，这种情况下可以在 Windows 下使用 EasyBCD 软件在修改引导加载程序。

### Linux  系统设置硬盘分区

一开始，你必须在存储设备上创建分区来容纳文件系统。分区可以是整个硬盘，也可以是部分硬盘，以容纳虚拟目录的一部分。在 Linux 系统中，硬盘分区常见的名称格式如下：

- /dev/hd[a-h]n：hd 表示 IDE 接口的硬盘；
- /dev/sd[a-p]n：sd 表示 SATA 接口和 SCSI 接口的硬盘；
- /dev/ed[a-d]n：ed 表示 ESDI 接口的硬盘；
- /dev/xd[ab]n：xd 表示 XT 接口的硬盘。

中括号中的字母表示驱动器的检测顺序，第一个驱动器是a，第二个驱动器是b，以此类推。n 表示分区号，在 MBR 分区的硬盘中，1－4 是主分区（或者扩展分区），逻辑分区号只能从分区号 5 开始，习惯上创建主分区 sda1 到 sda3（最多也只能创建三个主分区），然后建立一个扩展分区 sda4（创建三个主分区之后默认只能创建扩展分区），后续创建的分区 sda5，sda6 等只能为逻辑分区，默认会被包含在 sda4 扩展分区中 。

#### 创建 MBR 分区

fdisk 工具用来在存储设备上的创建 MBR 分区。它是个交互式程序，允许输入命令来逐步完成硬盘分区操作。 该命令的用法如下：

```shell
fdisk [options] <disk>    变更分区表
fdisk [options] -l <disk> 列出分区表
fdisk -s <partition>      显示分区的块大小
```

可用的选项如下：

```shell
-b <size>：扇区大小（512, 1024, 2048, 或 4096）；
-c[=<mode>]：兼容模式：`dos`或`nondos`(默认模式)；
-h：打印该帮助文本；
-u[=<unit>]：打印单位：`cylinders`或`sectors`（默认单位）；
-v：打印程序的版本；
-C <number>指定柱面数；
-H <number>：指定头数；
-S <number>：指定每个磁道的扇区数。
```

可以使用 -l 选项而不指定设备名来查看当前所有磁盘分区及映射的逻辑卷。也可以指定设备名称来查看指定磁盘的分区列表。

```shell
[root@localhost ~]# ll /dev/sd*
brw-rw----. 1 root disk 8, 0 May  8 07:05 /dev/sda
brw-rw----. 1 root disk 8, 1 May  8 07:05 /dev/sda1
brw-rw----. 1 root disk 8, 2 May  8 07:05 /dev/sda2
[root@localhost ~]# fdisk -l

Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x000d5723

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     1026047      512000   83  Linux
/dev/sda2         1026048    38780927    18877440   8e  Linux LVM

Disk /dev/mapper/cl-root: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/mapper/cl-swap: 2147 MB, 2147483648 bytes, 4194304 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/mapper/cl-home: 6442 MB, 6442450944 bytes, 12582912 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


[root@localhost ~]# fdisk -l /dev/sda

Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x000d5723

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     1026047      512000   83  Linux
/dev/sda2         1026048    38780927    18877440   8e  Linux LVM
[root@localhost ~]# fdisk -l /dev/sda1

Disk /dev/sda1: 524 MB, 524288000 bytes, 1024000 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

[root@localhost ~]# fdisk -l /dev/sda2

Disk /dev/sda2: 19.3 GB, 19330498560 bytes, 37754880 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

[root@localhost ~]# 
```

我们将演示虚拟机原有硬盘扩容了 20 GB 左右，同时又添加了一块容量为 10 GB 左右的新硬盘。

```shell
[root@localhost vincent]# ll /dev/sd*
brw-rw----. 1 root disk 8,  0 May  8 07:35 /dev/sda
brw-rw----. 1 root disk 8,  1 May  8 07:35 /dev/sda1
brw-rw----. 1 root disk 8,  2 May  8 07:35 /dev/sda2
brw-rw----. 1 root disk 8, 16 May  8 07:44 /dev/sdb
[root@localhost vincent]# fdisk -l

Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x000d5723

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     1026047      512000   83  Linux
/dev/sda2         1026048    38780927    18877440   8e  Linux LVM

Disk /dev/mapper/cl-root: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/mapper/cl-swap: 2147 MB, 2147483648 bytes, 4194304 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/mapper/cl-home: 6442 MB, 6442450944 bytes, 12582912 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

[root@localhost vincent]# fdisk -l /dev/sdb

Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

[root@localhost vincent]# fdisk -l /dev/sda

Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x000d5723

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     1026047      512000   83  Linux
/dev/sda2         1026048    38780927    18877440   8e  Linux LVM
[root@localhost vincent]# fdisk -l /dev/sda1

Disk /dev/sda1: 524 MB, 524288000 bytes, 1024000 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

[root@localhost vincent]# fdisk -l /dev/sda2

Disk /dev/sda2: 19.3 GB, 19330498560 bytes, 37754880 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

[root@localhost vincent]# 
```

从上面的执行结果可以看出，在扩容原有硬盘和新增硬盘之后，原有的 /dev/sda 容量增加了，同时新增了一个 /dev/sdb 的未分区的新磁盘。

使用 fdisk 命令后直接指定要分区的存储设备的设备名（需要使用超级用户）就可以进入 fdisk 工具的交互式操作模式了。下面展示了该命令在 CentOS 发行版中的使用情景。如果这是你第一次给该存储设备分区， fdisk 会提示你设备上没有可识别的分区表。

```shell
[root@localhost ~]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0x5ecbc139.

Command (m for help): 
```

根据提示，输入 m 命令可以查看可用的交互式命令

```shell
Command (m for help): m
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   g   create a new empty GPT partition table
   G   create an IRIX (SGI) partition table
   l   list known partition types
   m   print this menu
   n   add a new partition
   o   create a new empty DOS partition table
   p   print the partition table
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition's system id
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit
   x   extra functionality (experts only)

Command (m for help): 
```

各命令解释如下：

```shell
a 切换是否可启动的标识`on`或`off`（toggle a bootable flag）
b 编辑 bsd 磁盘标签（disklabel）
c 切换 dos 兼容性标识（toggle the dos compatibility flag）
d 删除分区
l 列出可用的系统ID
m 显示该命令菜单
n 添加一个新分区
o 创建一个新的DOS分区表
p 显示当前分区表
q 退出，不保存更改
s 为Sun Unix系统创建一个新的空磁盘标签（create a new empty Sun disklabel）
t 修改分区的系统ID
u 改变使用的存储单位
v 验证分区表
w 将分区表写入磁盘
x 高级功能（experts only）
```

实际上在日常工作中用到的只有几个基本命令。 可以用 p 命令将一个存储设备的详细信息显示出来。

```shell
Command (m for help): p

Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x5ecbc139

   Device Boot      Start         End      Blocks   Id  System

Command (m for help): 
```

输出显示这个存储设备有约 21.5 GB 的空间。存储设备明细的列表列出这个设备所有分区。这个例子中的输出中没有显示任何分区，所以设备还未分区。 下一步，可以使用 n 命令在该存储设备上根据提示创建新的分区。使用 n 命令需要先指定创建的分区类型（p 表示主分区，e 表示扩展分区），然后指定分区号，最后分别指定分区的起始柱面和结束柱面（也可以根据提示指定增加的柱面数或增加的容量大小来代替）。

```shell
Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): 
Using default response p
Partition number (1-4, default 1): 
First sector (2048-41943039, default 2048): 
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-41943039, default 41943039): +2G
Partition 1 of type Linux and of size 2 GiB is set

Command (m for help): n
Partition type:
   p   primary (1 primary, 0 extended, 3 free)
   e   extended
Select (default p): 
Using default response p
Partition number (2-4, default 2): 
First sector (4196352-41943039, default 4196352): 
Using default value 4196352
Last sector, +sectors or +size{K,M,G} (4196352-41943039, default 41943039): +2G
Partition 2 of type Linux and of size 2 GiB is set

Command (m for help): n
Partition type:
   p   primary (2 primary, 0 extended, 2 free)
   e   extended
Select (default p): 
Using default response p
Partition number (3,4, default 3): 
First sector (8390656-41943039, default 8390656): 
Using default value 8390656
Last sector, +sectors or +size{K,M,G} (8390656-41943039, default 41943039): +2G
Partition 3 of type Linux and of size 2 GiB is set

Command (m for help): 
Command (m for help): n
Partition type:
   p   primary (3 primary, 0 extended, 1 free)
   e   extended
Select (default e): 
Using default response e
Selected partition 4
First sector (12584960-41943039, default 12584960): 
Using default value 12584960
Last sector, +sectors or +size{K,M,G} (12584960-41943039, default 41943039): +2G
Partition 4 of type Extended and of size 2 GiB is set

Command (m for help): n
All primary partitions are in use
Adding logical partition 5
First sector (12587008-16779263, default 12587008): 
Using default value 12587008
Last sector, +sectors or +size{K,M,G} (12587008-16779263, default 16779263): +2G
Value out of range.
Last sector, +sectors or +size{K,M,G} (12587008-16779263, default 16779263): +1G
Partition 5 of type Linux and of size 1 GiB is set

Command (m for help): n
All primary partitions are in use
Adding logical partition 6
First sector (14686208-16779263, default 14686208): 
Using default value 14686208
Last sector, +sectors or +size{K,M,G} (14686208-16779263, default 16779263): +500M
Partition 6 of type Linux and of size 500 MiB is set

Command (m for help):
```

在上面的示例中，我们依次根据默认参数先创建了三个主分区，第四个分区默认只能选择扩展分区，后续只能在扩展分区中创建逻辑分区。主分区可以被文件系统直接格式化，而扩展分区则只能容纳其他逻辑分区。使用 p 命令可以查看该磁盘上已创建分区的列表（这些分区仅保存到内存中，还未实际执行）。

```shell
Command (m for help): p

Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x21258da3

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     4196351     2097152   83  Linux
/dev/sdb2         4196352     8390655     2097152   83  Linux
/dev/sdb3         8390656    12584959     2097152   83  Linux
/dev/sdb4        12584960    16779263     2097152    5  Extended
/dev/sdb5        12587008    14684159     1048576   83  Linux
/dev/sdb6        14686208    15710207      512000   83  Linux

Command (m for help): 
```

从输出中现在可以看到，该存储设备上所有分区列表。 其中，Id 列定义了 Linux 怎么对待该分区。 fdisk 允许创建多种分区类型。使用 l 命令列出可用的不同类型及其十六进制码。

```shell
Command (m for help): l

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        
 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      40  Venix 80286     85  Linux extended  c7  Syrinx         
 5  Extended        41  PPC PReP Boot   86  NTFS volume set da  Non-FS data    
 6  FAT16           42  SFS             87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility   
 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       df  BootIt         
 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access     
 a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O        
 b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor      
 c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi eb  BeOS fs        
 e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT            
 f  W95 Ext'd (LBA) 54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor      
12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f4  SpeedStor      
14  Hidden FAT16 <3 61  SpeedStor       ab  Darwin boot     f2  DOS secondary  
16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS    
17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE 
18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fe  LANstep        
1c  Hidden W95 FAT3 75  PC/IX           be  Solaris boot    ff  BBT            
1e  Hidden W95 FAT1 80  Old Minix      

Command (m for help): 
```

默认类型是 Linux 文件系统类型，对应的十六进制码为 83。如果你想为其他文件系统创建一个分区（比如 Solaris 类型的分区），只要通过 t 交互命令指定一个分区类型的十六进制代码即可。 

```shell
Command (m for help): t
Partition number (1-6, default 6): 5
Hex code (type L to list all codes): bf
Changed type of partition 'Linux' to 'Solaris'

Command (m for help): p

Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x21258da3

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     4196351     2097152   83  Linux
/dev/sdb2         4196352     8390655     2097152   83  Linux
/dev/sdb3         8390656    12584959     2097152   83  Linux
/dev/sdb4        12584960    16779263     2097152    5  Extended
/dev/sdb5        12587008    14684159     1048576   bf  Solaris
/dev/sdb6        14686208    15710207      512000   83  Linux

Command (m for help): 
```

创建了想要的分区之后就可以用 w 命令将更改保存到存储设备上。

```shell
Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
[root@localhost ~]# ll /dev/sd*
brw-rw----. 1 root disk 8,  0 May  8 07:35 /dev/sda
brw-rw----. 1 root disk 8,  1 May  8 07:35 /dev/sda1
brw-rw----. 1 root disk 8,  2 May  8 07:35 /dev/sda2
brw-rw----. 1 root disk 8, 16 May  8 22:49 /dev/sdb
brw-rw----. 1 root disk 8, 17 May  8 22:49 /dev/sdb1
brw-rw----. 1 root disk 8, 18 May  8 22:49 /dev/sdb2
brw-rw----. 1 root disk 8, 19 May  8 22:49 /dev/sdb3
brw-rw----. 1 root disk 8, 20 May  8 22:49 /dev/sdb4
brw-rw----. 1 root disk 8, 21 May  8 22:49 /dev/sdb5
brw-rw----. 1 root disk 8, 22 May  8 22:49 /dev/sdb6
[root@localhost ~]# 
```

存储设备的分区信息被写入分区表中， Linux 系统通过 ioctl() 调用来获知新分区的出现。 设置好分区之后，可以使用Linux 文件系统对其进行格式化。有些发行版和较旧的发行版在生成新分区之后并不会自动提醒 Linux 系统。如果是这样的话，你要么使用 partprob 或 hdparm 命令（参考相应的手册页），要么重启系统，让系统读取更新过的分区表。 

当然，我们可以通过 d 命令来删除已创建的分区。

```shell
[root@localhost ~]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.


Command (m for help): p

Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x21258da3

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     4196351     2097152   83  Linux
/dev/sdb2         4196352     8390655     2097152   83  Linux
/dev/sdb3         8390656    12584959     2097152   83  Linux
/dev/sdb4        12584960    16779263     2097152    5  Extended
/dev/sdb5        12587008    14684159     1048576   bf  Solaris
/dev/sdb6        14686208    15710207      512000   83  Linux

Command (m for help): d
Partition number (1-6, default 6): 5
Partition 5 is deleted

Command (m for help): p

Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x21258da3

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     4196351     2097152   83  Linux
/dev/sdb2         4196352     8390655     2097152   83  Linux
/dev/sdb3         8390656    12584959     2097152   83  Linux
/dev/sdb4        12584960    16779263     2097152    5  Extended
/dev/sdb5        14686208    15710207      512000   83  Linux

Command (m for help): 
```

从删除结果来看，Solaris 类型的 /dev/sdb5 分区被删除了，后面的 /dev/sdb6 就变成了新的 /dev/sdb5。

#### 创建 GPT 分区

如果要创建 GPT 分区，可以使用 parted 命令实现。parted 命令可用来操作磁盘分区，它支持多种分区格式，包括 MS_DOS 和 GPT。该命令语法如下。

```shell
parted [options] [device [command [options...]...]]
```

- [options]：该命令支持的命令行选项如下，

```shell
-l, --list：列出所有设备上的分区信息；
-m, --machine：显示机器可解析的输出；
-i, --interactive：在必要时，提示用户；
-s, --script：从不提示用户；
-a, --align alignment-type：为新创建的分区设置对齐，可用的对齐类型有：none（使用磁盘类型允许的最小对齐方式）、cylinder（将分区对齐到柱面）、minimal（使用根据磁盘拓扑信息给定的最小对齐方式。这种设置将使用磁盘提供的布局信息来对齐逻辑分区表地址到磁盘上实际的物理块。最小值是对齐分区到物理块最小对齐所需的，这可以避免性能下降）、optimal（使用由磁盘拓扑信息给定最佳的对齐，将对齐到物理块大小的整数倍以保证最佳性能）；
-h, --help：显示帮助信息；
-v, --version：显示版本。
```

- [device]：所操作的块设备。如果没有指定，parted 命令将使用它找到的第一个块设备，也可以在进入交互模式后执行 `select 设备路径` 命令来选择操作指定的磁盘 ；
- [command [options]：指定要执行的命令。如果没有指定命令，parted 将给出命令提示。

使用 parted -l 不指定设备名称，我们可以查看当前可操作的磁盘分区信息。

```shell
[root@localhost ~]# parted -l
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sda: 42.9GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End     Size    Type     File system  Flags
 1      1049kB  525MB   524MB   primary  ext4         boot
 2      525MB   19.9GB  19.3GB  primary               lvm


Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 21.5GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start  End  Size  Type  File system  Flags


Model: Linux device-mapper (linear) (dm)
Disk /dev/mapper/cl-home: 6442MB
Sector size (logical/physical): 512B/512B
Partition Table: loop
Disk Flags: 

Number  Start  End     Size    File system  Flags
 1      0.00B  6442MB  6442MB  ext4


Model: Linux device-mapper (linear) (dm)
Disk /dev/mapper/cl-swap: 2147MB
Sector size (logical/physical): 512B/512B
Partition Table: loop
Disk Flags: 

Number  Start  End     Size    File system     Flags
 1      0.00B  2147MB  2147MB  linux-swap(v1)


Model: Linux device-mapper (linear) (dm)
Disk /dev/mapper/cl-root: 10.7GB
Sector size (logical/physical): 512B/512B
Partition Table: loop
Disk Flags: 

Number  Start  End     Size    File system  Flags
 1      0.00B  10.7GB  10.7GB  ext4
```

直接使用 parted 命令会进入交互模式，然后输入 help 命令将显示基本的帮助信息，也可以输入 help COMMAND 查看某个交互式命令 COMMAND 的帮助信息，

```shell
[root@localhost ~]# parted
GNU Parted 3.1
Using /dev/sda
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) help                                                             
  align-check TYPE N                       check partition N for TYPE(min|opt) alignment
  help [COMMAND]                           print general help, or help on COMMAND
  mklabel,mktable LABEL-TYPE               create a new disklabel (partition table)
  mkpart PART-TYPE [FS-TYPE] START END     make a partition
  name NUMBER NAME                         name partition NUMBER as NAME
  print [devices|free|list,all|NUMBER]     display the partition table, available devices, free
        space, all found partitions, or a particular partition
  quit                                     exit program
  rescue START END                         rescue a lost partition near START and END
  rm NUMBER                                delete partition NUMBER
  select DEVICE                            choose the device to edit
  disk_set FLAG STATE                      change the FLAG on selected device
  disk_toggle [FLAG]                       toggle the state of FLAG on selected device
  set NUMBER FLAG STATE                    change the FLAG on partition NUMBER
  toggle [NUMBER [FLAG]]                   toggle the state of FLAG on partition NUMBER
  unit UNIT                                set the default unit to UNIT
  version                                  display the version number and copyright information
        of GNU Parted
(parted) version

GNU Parted 3.1

Copyright (C) 1998 - 2006 Free Software Foundation, Inc.
This program is free software, covered by the GNU General Public License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

(parted) 
```

对于这些交互式命令解释如下，

```shell
align-check TYPE N：检查分区 N 的对齐类型 TYPE（min|opt）；
help [COMMAND]：打印一般帮助，或指定命令 COMMAND 的帮助：检查分区的对齐；
mklabel,mktable LABEL-TYPE：创建新的磁盘标签（分区表）；
mkpart PART-TYPE [FS-TYPE] START END：创建一个分区；
name NUMBER NAME：将分区号为 NUMBER 的分区命名为 NAME；
p, print [devices|free|list,all|NUMBER]：显示分区表、可用设备、剩余空间、所有发现的分区、或特定的分区；
quit：退出交互模式；
rescue START END：挽救 START 和 END 附近丢失的分区；
rm NUMBER：删除分区号为 NUMBER 的分区；
select DEVICE：选择要编辑的设备；
disk_set FLAG STATE：设置所选设备的 FLAG 状态为 STATE；
disk_toggle [FLAG]：切换所选设备的 FLAG 状态；
set NUMBER FLAG STATE：设置分区号为 NUMBER 的分区的 FLAG 状态为 STATE；
toggle [NUMBER [FLAG]]：将分区号为 NUMBER 的分区的 FLAG 状态切换为 FLAG；
u, unit UNIT：设置默认的单位为 UNIT，为 s, B, kB, MB（默认）, GB, TB, compact, cyl, chs, %, kiB, MiB, GiB, TiB 之一；
version:显示版本号和版权信息。
```

如果要对新增的磁盘创建 GPT 分区，则先要使用 mklabel 命令创建 GPT 磁盘标签（分区表）。

```shell
(parted) select /dev/sdb		# 首先选择或切换要操作的磁盘设备
Using /dev/sdb
(parted) help mklabel 
  mklabel,mktable LABEL-TYPE               create a new disklabel (partition table)

        LABEL-TYPE is one of: aix, amiga, bsd, dvh, gpt, mac, msdos, pc98, sun, loop
(parted) mklabel gpt                                                      
Warning: The existing disk label on /dev/sdb will be destroyed and all data on this disk will be
lost. Do you want to continue?
Yes/No? Yes
(parted) print                                                            
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 21.5GB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start  End  Size  File system  Name  Flags

(parted)
```

mklabel 命令的帮助信息表示： LABEL-TYPE 为 aix, amiga, bsd, dvh, gpt, mac, msdos, pc98, sun, loop 之一。新磁盘标签（分区表）是没有分区的，该命令从技术上不会毁掉你分区上的数据，但数据基本上却不能使用，可以使用 rescue 命令来恢复任意分区或者操作之前做好备份。从上面 print 命令的打印结果来看，我们已经创建了 gpt 分区表。

> 当然，也可以使用 mklabel 命令创建 msdoc 磁盘标签（分区表），这样后续创建的分区就是 MSR 分区了。所以 parted 命令也可以用来创建 MSR 分区。

接下来就可以通过 mkpart 命令创建分区了。

```shell
(parted) help mkpart 
  mkpart PART-TYPE [FS-TYPE] START END     make a partition

        PART-TYPE is one of: primary, logical, extended
        FS-TYPE is one of: btrfs, nilfs2, ext4, ext3, ext2, fat32, fat16, hfsx, hfs+, hfs, jfs,
        swsusp, linux-swap(v1), linux-swap(v0), ntfs, reiserfs, hp-ufs, sun-ufs, xfs, apfs2,
        apfs1, asfs, amufs5, amufs4, amufs3, amufs2, amufs1, amufs0, amufs, affs7, affs6, affs5,
        affs4, affs3, affs2, affs1, affs0, linux-swap, linux-swap(new), linux-swap(old)
        START and END are disk locations, such as 4GB or 10%.  Negative values count from the
        end of the disk.  For example, -1s specifies exactly the last sector.
        
        'mkpart' makes a partition without creating a new file system on the partition.  FS-TYPE
        may be specified to set an appropriate partition ID.
(parted) mkpart                                                         
Partition name?  []? first_part                                           
File system type?  [ext2]? ext4                                           
Start? 1                                                                  
End? 2048M
(parted) print                                                            
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 21.5GB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start   End     Size    File system  Name        Flags
 1      1049kB  2048MB  2047MB               first_part

(parted) 
```

需要指定分区类型为 PART-TYPE，为 primary, logical, extended 之一，extended 和 logical 仅用在 msdos 和 mips 磁盘标签。如果是创建 GPT 磁盘标签，那么就没有这三者的概念了，该项就变成了为分区指定任意名称（Name），指定文件系统为 FS-TYPE（从 mkpart 之后 print 的结果来看，即使指定该项也不会创建文件系统，可指定其值来为分区设置一个合适的文件系统签名。在创建不同的实际文件系统时或创建物理卷时，该签名会被擦除），指定起始和结束位置为 START 和 END，START、END 均为磁盘起始位置的偏移量，可以为其指定数字时带上单位，如果仅指定数字而没有单位，则其默认单位可以由 unit 命令来指定。负值表示从磁盘结束位置向前计算位置，比如`-1s`倒数第一个扇区。

上面的操作也可以一行就可以完成，

```shell
(parted) mkpart second_part 2048MB 4096MB                                 
(parted) print                                                            
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 21.5GB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start   End     Size    File system  Name         Flags
 1      1049kB  2048MB  2047MB               first_part
 2      2048MB  4096MB  2048MB               second_part

(parted) 
```

当然，也可以通过仅一行的命令行模式来完成上面的操作，

```shell
parted /dev/sda mklabel gpt mkpart third_part ext3 4096MB 5120MB 
```

**请注意 parted 命令是输入命令回车后即可生效，不像 fdisk 一样要最后确认执行才生效**。使用 parted 命令创建分区之后，有的发行版可能不会自动识别新建的分区，需要重新读取 /etc/fstab 文件识别新的分区或重启。

> /etc/mtab  文件由操作系统维护，处于安全考虑不要手动修改该文件，/etc/fstab 定义了应该挂载什么，在系统启动时会被读取，

我们也可以 rm 命令删除创建的分区，这里就不详述了。

