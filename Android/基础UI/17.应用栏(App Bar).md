# **应用栏(App Bar)详解**

### **应用栏简介**

应用栏，以前也称操作栏（ActionBar），是应用活动中最重要的一项设计元素，因为它为用户提供了熟悉的视觉结构和交互元素。使用应用栏可让您的应用与其他 Android 应用保持一致，允许用户快速了解如何使用您的应用并获得一流的体验。应用栏的主要功能包括：

- 一个专用区域，可以标识您的应用并指示用户在应用中的位置。
- 以可预测的方式访问搜索等重要操作。
- 支持导航和视图切换（通过标签页或下拉列表）。

![appbar_sheets](C:\Users\Vincent Huang\Desktop\studynotes\Android\基础UI组件\appendix\appbar_sheets.png)

此类说明了如何将 [v7 appcompat](https://developer.android.com/tools/support-library/features.html#v7-appcompat) 支持库的 Toolbar 部件（widget）作为应用栏使用。也可以通过其他方式实现应用栏，例如，某些主题默认情况下会设置一个 ActionBar 作为应用栏。但是，使用 appcompat Toolbar 设置的应用栏能兼容最广泛的设备，也使您能够随着应用的发展自定义应用栏。

### **设置应用栏**

最基本的操作栏会在一侧显示 Activity 的标题，在另一侧显示一个溢出菜单（overflow menu）。即便是这种简单的应用栏也能为用户提供有用的信息，并有助于赋予 Android 应用一致的观感。

![appbar_basic](C:\Users\Vincent Huang\Desktop\studynotes\Android\基础UI组件\appendix\appbar_basic.png)

从 Android 3.0（API 级别 11）开始，所有使用默认主题的 Activity 均使用 ActionBar 作为应用栏。不过，**经过不同 Android 版本的演化，应用栏功能已逐渐添加到原生 ActionBar 中。因此，原生 ActionBar 的行为会随设备使用的 Android 系统的版本而发生变化。相比之下，最新功能已添加到支持库版本的 Toolbar 中，并且这些功能可以在任何能够使用该支持库的设备上使用**。

因此，您**应使用支持库的 Toolbar类来实现 Activity 的应用栏。使用支持库的工具栏有助于确保您的应用在最大范围的设备上保持一致的行为**。例如，Toolbar小部件能够在运行 Android 2.1（API 级别 7）或更高版本的设备上提供 [Material Design](https://developer.android.com/design/material/index.html) 体验，但除非设备运行的是 Android 5.0（API 级别 21）或更高版本，否则原生操作栏不会支持 Material Design。

#### **向 Activity 添加工具栏**

以下步骤说明了如何将 Toolbar 设置为 Activity 的应用栏：

1. 按照**支持库设置中**所述向您的项目添加 [v7 appcompat](https://developer.android.com/tools/support-library/features.html#v7-appcompat) 支持库。
2. 确保 Activity 可以扩展 AppCompatActivity：

```java
public class MyActivity extends AppCompatActivity {
  // ...
}
```

请为您应用中每个使用 Toolbar 作为应用栏的 Activity 进行此更改。

3. 要使用Toolbar需要将Activity的ActionBar隐藏掉。有下面三种方法:
方法一：

在应用清单中，将\<application> 或\<activity>元素设置为使用 appcompat 的其中一个 Xxx.NoActionBar 主题。使用这些主题中的一个可以防止应用使用原生 ActionBar 类提供应用栏。例如：

```xml
<application android:theme="@style/Theme.AppCompat.Light.NoActionBar" />
```
或者

```xml
<activity android:name="MainActivity"
           android:theme="@style/Theme.AppCompat.Light.NoActionBar">
</activity>
```

方法二：
在res/values/styles.xml文件中修改

```xml
<style name="AppTheme.Base" parent="Theme.AppCompat">
 <item name="windowActionBar">false</item>
 <item name="android:windowNoTitle">true</item>
</style>
```

也可以直接使用没有ActionBar的主题

```xml
<style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
```

方法三：
直接在代码中取消。在setContentView之前：

```java
requestWindowFeature(Window.FEATURE_NO_TITLE);
setContentView(R.layout.activity_main);
//supportRequestWindowFeature(Window.FEATURE_NO_TITLE);  在AppCompatActivity中
```
4. 向 Activity 的布局添加一个 Toolbar。例如，以下布局代码可以添加一个 Toolbar 并赋予其浮动在 Activity 之上的外观：

```xml
<android.support.v7.widget.Toolbar
   android:id="@+id/my_toolbar"
   android:layout_width="match_parent"
   android:layout_height="?attr/actionBarSize"
   android:background="?attr/colorPrimary"
   android:elevation="4dp"
   android:theme="@style/ThemeOverlay.AppCompat.ActionBar"
   app:title="Title" 
   app:titleTextColor="@color/white"
   app:titleTextAppearance="@style/ToolbarTextAppearanceTitle"
   app:subtitle="subtitle"
   app:subtitleTextColor="@color/white"
   app:subtitleTextAppearance="@style/ToolbarTextAppearanceSubTitle"                                
   app:logo="@mipmap/ic_launcher"
   app:navigationIcon="@drawable/menu_icon"   
   app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/>
```

[Material Design 规范](https://www.google.com/design/spec/what-is-material/elevation-shadows.html#elevation-shadows-shadows)建议应用栏具有 4 dp 的仰角。将工具栏定位在 Activity [布局](https://developer.android.com/guide/topics/ui/declaring-layout.html)的顶部，因为您要使用它作为应用栏。

或者在Java代码中进行Toobar的一些设置：

```java
mToolbar.setTitle("JavaTitle");
mToolbar.setSubtitle("JavaSubTitle");
mToolbar.setLogo(R.mipmap.ic_launcher);
mToolbar.setNavigationIcon(android.R.drawable.ic_input_delete);
mToolbar.setOverflowIcon(ContextCompat.getDrawable(this, android.R.drawable.ic_menu_more));
// setActionBar(mToolbar);  //activity中
setSupportActionBar(mToolbar);   //AppCompatActivity中
```

5. 在 Activity 的 onCreate() 方法中，调用 Activity 的 setSupportActionBar() 方法，然后传递 Activity 的工具栏。该方法会将工具栏设置为 Activity 的应用栏。例如：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_my);
    Toolbar myToolbar = (Toolbar) findViewById(R.id.my_toolbar);
    setSupportActionBar(myToolbar);
    }
```

您的应用现在具有一个基本操作栏。默认情况下，操作栏只包含应用的名称和一个溢出菜单。选项菜单最初只包含 Settings 菜单项。您可以按照**添加和处理操作**中所述向操作栏和溢出菜单添加更多操作。

#### **使用应用栏实用方法**

将工具栏设置为 Activity 的应用栏后，您就可以访问 v7 appcompat 支持库的 ActionBar 类提供的各种实用方法。您可以通过此方法执行许多有用的操作，例如隐藏和显示应用栏。

要使用 ActionBar 实用方法（如设置标题等操作），请调用 Activity 的 **getSupportActionBar()** 方法。此方法将返回对 appcompat ActionBar 对象的引用。获得该引用后，您就可以调用任何一个 ActionBar 方法来调整应用栏。例如，要隐藏应用栏，请调用 ActionBar.hide()。

### **添加和处理操作**

应用栏允许您为用户操作提供按钮。这个特性可以让您把当前上下文中最重要的操作放到应用顶部。例如，一个图片浏览应用在用户查看图片列表时，可能会在顶部显示出分享和创建相簿的按钮，当用户查看一个独立的图片时，应用可能会显示出裁剪和筛选按钮。

应用栏的空间是有限的。如果一个应用声明的操作按钮超过了应用栏可容纳的数量，应用栏会将超出的操作按钮放到溢出菜单中。应用可以指定一个操作按钮一直显示在溢出菜单中，而是不是显示在应用栏中。

#### **添加操作按钮**

所有操作按钮和其他显示在溢出菜单中的操作按钮都是在菜单资源中定义的。要向操作栏添加操作按钮，就在 res/menu/ 目录下定义一个菜单资源的XML文件。在菜单资源中为每一个您想包含到应用栏中的操作按钮添加一个\<item>元素。例如：

```xml
<menu xmlns:android="http://schemas.android.com/apk/res/android" 
      xmlns:app="http://schemas.android.com/apk/res-auto">
  
    <!-- "Mark Favorite", should appear as action button if possible -->
    <item
        android:id="@+id/action_favorite"
        android:icon="@drawable/ic_favorite_black_48dp"
        android:title="@string/action_favorite"
        app:showAsAction="ifRoom|withText"/>

    <!-- Settings, should always be in the overflow -->
    <item android:id="@+id/action_settings"
          android:title="@string/action_settings"
          app:showAsAction="never"/>
  
</menu>
```

app:showAsAction 属性用来指定该菜单项是否作为一个操作按钮添加到应用栏中：

- app:showAsAction="ifRoom"，该菜单项就会在应用栏有放置它的空间时作为一个按钮被添加应用栏中，如果没有足够的空间，就将该多出的菜单项添加到溢出菜单中；
- app:showAsAction="never"，那么该菜单项将会一直列在溢出菜单中，而不会显示在应用栏中。

然后再Activity代码中创建选项菜单：

```java
@Override
public boolean onCreateOptionsMenu(Menu menu) {
	MenuInflater menuInflater = getMenuInflater();
	menuInflater.inflate(R.menu.overflow_menu_test_items, menu);
	return super.onCreateOptionsMenu(menu);
}
```

如果菜单项显示在应用栏中，系统将使用其图标生成操作按钮。您可以在[Material Icons](https://www.google.com/design/icons/) 上找到许多有用的图标。

#### **响应操作按钮**

当用户选择了应用栏中的条目，系统会调用Activity的OptionsItemSelected()回调方法，传入的MenuItem参数表明点击了哪一个条目。在你的onOptionsItemSelected()方法实现中调用MenuItem.getItemId() 方法来确定哪一个条目被按下了，方法返回的ID值即为该条目在菜单资源中对应的\<item>元素的android:id 属性值。如下面代码所示，如果该方法未能识别出用户点击的按钮，将使用父类的方法：

```java
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.action_settings:
            // User chose the "Settings" item, show the app settings UI...
            return true;

        case R.id.action_favorite:
            // User chose the "Favorite" action, mark the current item
            // as a favorite...
            return true;

        default:
            // If we got here, the user's action was not recognized.
            // Invoke the superclass to handle it.
            return super.onOptionsItemSelected(item);

    }
}
```

由于隐藏的MenuItem默认是不显示图标的。如果要显示出溢出菜单中的图标，只需要重写以下方法：

```java
// 这是在AppCompatActivity中
@Override
protected boolean onPrepareOptionsPanel(View view, Menu menu) {
	if (menu != null) {
		if (menu.getClass() == MenuBuilder.class) {
			try {
				   Method m = menu.getClass().getDeclaredMethod("setOptionalIconsVisible",
                              Boolean.TYPE);	
              		m.setAccessible(true);
					m.invoke(menu, true);
				} catch (Exception e) {
					Log.i("tag", "onPrepareOptionsPanel: " + getClass().getSimpleName()
                          +"onMenuOpened...unable to set icons for overflow menu" + e);
					}
				}
		}
	return super.onPrepareOptionsPanel(view, menu);
}
```

### **添加向上操作**

您的应用应该让用户很容易返回到应用的主屏幕。一种简单的方式就是在除了主Activity以外的其他所有Activity的应用栏上添加一个向上按钮，用户点击向上按钮之后，应用导航到父Activity（译者注：这里的父子关系是指导航层次上的父子关系）。

#### **声明一个父Activity**

要在一个Activity中支持“向上”功能，您需要为该Activity声明一个父Activity，您可以在应用的清单文件中通过设置android:parentActivityName属性来实现父Activity的添加。该属性自Android 4.1 (API 16)开始引入，为了支持旧版Android设备，定义一个\<meta-data> name-value对，其中android:name设置为android.support.PARENT_ACTIVITY，android:value设置为添加的父Activity 。如以下清单代码所示：

```xml
<application ... >
    ...

    <!-- The main/home activity (it has no parent activity) -->

    <activity
        android:name="com.example.myfirstapp.MainActivity" ...>
        ...
    </activity>

    <!-- A child of the main activity -->
    <activity
        android:name="com.example.myfirstapp.MyChildActivity"
        android:label="@string/title_activity_child"
        android:parentActivityName="com.example.myfirstapp.MainActivity" >

        <!-- Parent activity meta-data to support 4.0 and lower -->
        <meta-data
            android:name="android.support.PARENT_ACTIVITY"
            android:value="com.example.myfirstapp.MainActivity" />
    </activity>
</application>
Enable the
```

#### **启用(Enable)向上按钮**

要启用一个有父Activity的Activity的向上按钮，调用应用栏的setDisplayHomeAsUpEnabled() 方法，通常在该Activity创建时调用该方法。如以下代码所示：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_my_child);

    // my_child_toolbar is defined in the layout file
    Toolbar myChildToolbar =
        (Toolbar) findViewById(R.id.my_child_toolbar);
    setSupportActionBar(myChildToolbar);

    // Get a support ActionBar corresponding to this toolbar
    ActionBar ab = getSupportActionBar();

    // Enable the Up button
    ab.setDisplayHomeAsUpEnabled(true);
}
```

您不用在该Activity的onOptionsItemSelected() 方法中捕获该向上按钮，而是如上面**响应操作按钮**中所示的调用父类的该方法。父类的onOptionsItemSelected() 方法会通过导航到清单文件中指定的父Activity来响应向上操作。

### **操作视图(Action Views)和操作提供者(Action Providers)**

 [v7 appcompat](https://developer.android.com/tools/support-library/features.html#v7-appcompat) 支持库的Toolbar为用户提供了几种不同的应用交互方式。这节课讲一下如何添加两种通用组件：

- 操作视图（Action View）可在应用栏中提供丰富的功能。例如，一个搜索Action View可以允许用户在不改变Activity和Fragment的情况下在应用栏键入搜索文本；
- 操作提供者（Action Provider）拥有自己的自定义布局。一个操作条目（action）最初可显示为一个按钮或菜单项，但当用户点击该操作条目时，Action Provider可按你定义的任何方式控制该操作条目的行为。例如，Action Provider可以通过显示一个菜单来响应点击事件。

Android支持库提供了几个指定的Action View和Action Providers部件（widget）。例如，SearchView 部件实现了一个搜索查询的Action View，[ShareActionProvider](https://developer.android.com/reference/android/support/v7/widget/ShareActionProvider.html) 部件实现了一个与其他应用分享信息的Action Provider。您也可以定义自己的Action View和Action Provider。

#### **添加一个Action View**

要添加一个Action View，就如**添加操作按钮**部分所述，在toolbar的菜单资源中创建一个\<item>元素，然后向该\<item>元素添加以下两个属性：

- actionViewClass：实现该操作的部件的类名；
- actionLayout：描述该操作组件的布局资源。

将showAsAction属性设置为“ifRoom|collapseActionView”或“never|collapseActionView”。collapseActionView 表明了当用户不与该部件交互时如何显示该部件：如果该部件在应用栏上，那么应用应该将该部件显示为图标。如果该部件在溢出菜单中，应用应该将该部件显示为菜单项。当用户与Action View交互时，它会扩展充满应用栏。例如，下面的代码在应用栏添加了一个SearchView：

```xml
<item android:id="@+id/action_search"
     android:title="@string/action_search"
     android:icon="@drawable/ic_search"
     app:showAsAction="ifRoom|collapseActionView"
     app:actionViewClass="android.support.v7.widget.SearchView" />
```

如果用户没有不该部件交互，那么该部件将显示为android:icon属性指定的图标（如果应用栏没有足够的空间，则会添加到溢出菜单中）。当用户点击图标或菜单项时，该部件将扩展充满应用栏来与用户交互。

![action_view_2x](C:\Users\Vincent Huang\Desktop\studynotes\Android\基础UI组件\appendix\action_view_2x.png)

用户点击Action View图标之后，该部件充满应用栏来与用户交互

您可以在Activity的onCreateOptionsMenu() 回调方法中配置操作条目（action）。您可以通过getActionView() 方法来获取action view对象的引用。例如，以下代码获取了之前定义的SearchView 部件的对象引用：

```java
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main_activity_actions, menu);

    MenuItem searchItem = menu.findItem(R.id.action_search);
    SearchView searchView =
            (SearchView) MenuItemCompat.getActionView(searchItem);

    // Configure the search info and add any event listeners...

    return super.onCreateOptionsMenu(menu);
}
```

#### **响应Action View的扩展**

如果一个操作条目的\<item>元素有collapseActionView标记，在用户与该action view交互之前，应用会将该action view显示为图标。当用户点击图标时，为onOptionsItemSelected() 方法内建的处理器会扩展该action view。如果您的Activity子类重写了onOptionsItemSelected()方法，您的重写方法必须调用super.onOptionsItemSelected() 来让父类可以扩展该action view。

如果你想在操作条目扩展或折叠时做些什么，您可以定义一个实现 MenuItem.OnActionExpandListener接口的类，然后向[MenuItem.setOnActionExpandListener()](https://developer.android.com/reference/android/view/MenuItem.html#setOnActionExpandListener(android.view.MenuItem.OnActionExpandListener)) 方法传递一个该类的成员。例如，您可能想在action view扩展或收缩的时来更新Activity，下面的代码片段展示了如何定义并传入一个监听器：

```java
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.options, menu);
    // ...

    // Define the listener
    OnActionExpandListener expandListener = new OnActionExpandListener() {
        @Override
        public boolean onMenuItemActionCollapse(MenuItem item) {
            // Do something when action item collapses
            return true;  // Return true to collapse action view
        }

        @Override
        public boolean onMenuItemActionExpand(MenuItem item) {
            // Do something when expanded
            return true;  // Return true to expand action view
        }
    };

    // Get the MenuItem for the action item
    MenuItem actionMenuItem = menu.findItem(R.id.myActionItem);

    // Assign the listener to that action item
    MenuItemCompat.setOnActionExpandListener(actionMenuItem, expandListener);

    // Any other things you have to do when creating the options menu…

    return true;
}
```

#### **添加一个Action Provider**

要声明一个action provider，就如**添加操作按钮**部分所述，在toolbar的菜单资源中创建一个\<item>元素，然后向该\<item>元素添加一个actionProviderClass属性，为该属性指定action provider类的全限定类名。例如，以下代码声明了一个[ShareActionProvider](https://developer.android.com/reference/android/support/v7/widget/ShareActionProvider.html) ，在支持库中定义的该部件（widget）您的应用可以与其他应用共享信息：

```xml
<item android:id="@+id/action_share"
    android:title="@string/share"
    app:showAsAction="ifRoom"
    app:actionProviderClass="android.support.v7.widget.ShareActionProvider"/>
```

在上面的例子中，没必要为该部件声明一个图标，因为ShareActionProvider有自己的图像。如果你使用了一个自定义的操作条目（action），就声明一个图标。

### **相关类详解**

#### **[Toolbar](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html)** 

工具栏（Toolbar）是广义的操作栏（ActionBar）。操作栏习惯上是Activity上受框架所控制的不透明窗口装饰，而工具栏可以放在view层级中的任意嵌套级别中，应用可以通过[AppCompatActivity.setSupportActionBar()](https://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html#setSupportActionBar(android.support.v7.widget.Toolbar)) 方法来指定一个工具栏作为操作栏。

工具栏相比操作栏，支持一种更专注的特性。从头到尾，工具栏可以包含以下可选元素的组合：

- 导航按钮（navigation button）。可以是一个向上箭头，导航菜单开关，关闭，折叠，完成或者其他应用选择的字形。该按钮应总是用来导航到工具栏和它所指内容中的另一个导航点，否则将工具栏指向当前上下文。导航按钮在工具栏的最小高度范围内垂直对齐（如果已设置）；
- 标记图像（branded logo image）。这可以扩展到工具栏的高度，可以是任意宽度；
- 标题和副标题（title and subtitle）。标题标记了工具栏在导航层级中的当前位置，副标题表示当前内容的额外信息。如果应用已经使用了**标记图像** ，强烈建议取消标题和副标题；
- 一个或多个自定义view。应用可以在工具栏添加任意的子view。如果子view的Toolbar.LayoutParams 表明Gravity值指定为CENTER_HORIZONTAL ，那么该view在工具栏中的其他元素被测量之后尝试居中在剩余空间中；
- 操作菜单（action menu）。操作菜单被钉在工具栏末尾随可选的溢出菜单提供一些常用、重要或典型的操作，操作按钮在工具栏的最小高度范围内垂直对齐（如果已设置）。

在API 21或更高版本中不推荐使用应用图标加上标题作为标准布局了。现代Android UI开发者应该使用一种独特的颜色方案而不是应用图标。

该类包含以下内部类和内部接口：

- public static class Toolbar.LayoutParams，该类用来控制工具栏中子view的布局信息。其间接父类为android.view.ViewGroup.MarginLayoutParams，直接父类为android.support.v7.app.ActionBar.LayoutParams，所以该类可以使用这两个父类的相关XML属性；
- public static interface Toolbar.OnMenuItemClickListener；
- public static class Toolbar.SavedState ，该类用于将工具栏的实例写入[Parcel](https://developer.android.com/reference/android/os/Parcel.html)并从Parcel中恢复。



| XML属性                                    | 描述                                       |
| ---------------------------------------- | ---------------------------------------- |
| [`android.support.v7.appcompat:buttonGravity`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:buttonGravity) | 定义按钮的对齐方式                                |
| [`android.support.v7.appcompat:collapseContentDescription`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:collapseContentDescription) | 定义折叠按钮的内容描述                              |
| [`android.support.v7.appcompat:collapseIcon`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:collapseIcon) | 定义折叠按钮的图标                                |
| [`android.support.v7.appcompat:contentInsetEnd`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:contentInsetEnd) | 定义栏中尾部内容视图的最小嵌入尺寸                        |
| [`android.support.v7.appcompat:contentInsetEndWithActions`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:contentInsetEndWithActions) | 当操作菜单中的操作条目显示时，定义其内容视图的最小嵌入尺寸            |
| [`android.support.v7.appcompat:contentInsetLeft`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:contentInsetLeft) | 定义栏中左边内容视图的最小嵌入尺寸                        |
| [`android.support.v7.appcompat:contentInsetRight`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:contentInsetRight) | 定义栏中右边内容视图的最小嵌入尺寸                        |
| [`android.support.v7.appcompat:contentInsetStart`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:contentInsetStart) | 定义栏中首部内容视图的最小嵌入尺寸                        |
| [`android.support.v7.appcompat:contentInsetStartWithNavigation`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:contentInsetStartWithNavigation) | 当导航按钮（如向上按钮）按下时，定义内容视图的最小嵌入尺寸            |
| [`android.support.v7.appcompat:logo`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:logo) | 定义在导航按钮之后，工具栏起始处的标记所用的Drawable对象         |
| [`android.support.v7.appcompat:logoDescription`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:logoDescription) | 定义标记图像所用的内容描述字符串                         |
| [`android.support.v7.appcompat:maxButtonHeight`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:maxButtonHeight) | 定义按钮的最大高度                                |
| [`android.support.v7.appcompat:navigationContentDescription`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:navigationContentDescription) | 定义导航按钮的内容描述                              |
| [`android.support.v7.appcompat:navigationIcon`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:navigationIcon) | 定义导航按钮图标                                 |
| [`android.support.v7.appcompat:popupTheme`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:popupTheme) | 引用一个用来显示工具栏中部件弹出组件的主题                    |
| [`android.support.v7.appcompat:subtitle`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:subtitle) | 在navigationMode="normal"时，指定副标题文本，使用 '\\;'来下士转义的Unicode字符 |
| [`android.support.v7.appcompat:subtitleTextAppearance`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:subtitleTextAppearance) | 定义副标题文本外观                                |
| [`android.support.v7.appcompat:subtitleTextColor`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:subtitleTextColor) | 定义副标题文本颜色                                |
| [`android.support.v7.appcompat:title`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:title) | 定义标题文本                                   |
| [`android.support.v7.appcompat:titleMargin`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:titleMargin) | 定义标题页边距                                  |
| [`android.support.v7.appcompat:titleMarginBottom`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:titleMarginBottom) | 定义标题文本的底部页边距                             |
| [`android.support.v7.appcompat:titleMarginEnd`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:titleMarginEnd) | 定义标题文本的尾部页边距                             |
| [`android.support.v7.appcompat:titleMarginStart`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:titleMarginStart) | 定义标题文本的首部页边距                             |
| [`android.support.v7.appcompat:titleMarginTop`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:titleMarginTop) | 定义标题文本的顶部页边距                             |
| [`android.support.v7.appcompat:titleTextAppearance`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:titleTextAppearance) | 定义标题文本外观                                 |
| [`android.support.v7.appcompat:titleTextColor`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android.support.v7.appcompat:titleTextColor) | 定义标题文本颜色                                 |
| [`android:gravity`](https://developer.android.com/reference/android/support/v7/widget/Toolbar.html#attr_android:gravity) | 定义对齐方式                                   |

其他方法如下：

- void setOverflowIcon(Drawable icon)：设置移出按钮图标所用的Drawable对象；
- void inflateMenu(int resId)：填充一个菜单资源作为溢出菜单；
  - booleanshowOverflowMenu()：显示溢出菜单；
  - booleanhideOverflowMenu()：隐藏菜单中的一处条目。

#### **Action Bar**

##### **ActionBar类概述**

操作栏（[ActionBar](https://developer.android.com/reference/android/app/ActionBar.html)）是一个可显示Activity名称的工具栏，支持应用级别的导航和其他交互操作。主要提供以下主要功能：

- 显示选项菜单的菜单项（将选项菜单显示为Action Item），将较少使用的操作放入溢出菜单来减少混乱；
- 使用应用图标作为返回Home主屏幕或向上的导航操作；
- 提供交互式View作为Action View，如新建和搜索操作；
- 提供基于Tab的导航方式，可用于切换多个Fragment；
- 提供基于下拉的导航方式。

ActionBar自Android 3.0 (API level 11)开始引入，显示在Activity的窗口顶部，使用系统[Holo](https://developer.android.com/reference/android/R.style.html#Theme_Holo) 主题（默认）或其派生主题。您应该通过调用[Window.requestFeature(FEATURE_ACTION_BAR)](https://developer.android.com/reference/android/view/Window.html#requestFeature(int)) 方法来添加ActionBar，或者使用 [windowActionBar](https://developer.android.com/reference/android/R.styleable.html#Theme_windowActionBar) 声明一个自定义主题来添加ActionBar。

自Android 5.0 (API level 21)开始，ActionBar可显示成一个Toolbar，应用可给Activity发送信息来告诉该Activity将哪一个Toolbar当作ActionBar，使用该功能的Activity应该使用一种.NoActionBar主题，将windowActionBar设置为false，或者不使用窗口特性。通过调整[主题和Activity的内容视图（content view）]所请求的窗口特性，应用可以在新旧Android版本中使用系统标准的ActionBar，在新Android版本中行内Toolbar（inline toolbar）。从Activity获得的ActionBar对象可以用来控制任何（either）配置。

使用Holo主题时，ActionBar在将应用图标显示在左边，后面跟着Activity的标题。如果Activity有选项菜单，你可以在ActionBar中选择使用某些作为Action Item的菜单项。当使用Material Design主题（API level 21或更高）时，导航按钮（原来叫“Home”）接替了之前应用图标的位置，想要表现出特有风格的应用应在ActionBar上使用其特有风格的颜色。

对于你的Activity来说，调用其getActionBar()方法可以获得一个ActionBar对象。

在其他情形中，ActionBar可能被其他通过使用[ActionMode](https://developer.android.com/reference/android/view/ActionMode.html) （可提供一些上下文操作来替换一般UI，直到完成操作）的可以执行上下文操作UI所覆盖。例如，当用户在Activity中选择了的一个或多个条目，您可以指定一个action mode来提供一些临时显示在ActionBar中、针对所选条目的特定操作UI，尽管这些临时UI占据了ActionBar的位置，但是ActionMode 的API与ActionBar的API是相互独立的。

![action_bar_basics](C:\Users\Vincent Huang\Desktop\studynotes\Android\基础UI组件\appendix\action_bar_basics.png)

ActionBar结构如上图所示，主要包含以下几个部分：

1. 应用图标。该图标基于您的应用的图标，可以被替换成你希望的logo或商标（branding）。注意，如果您的应用当前不是在顶级屏幕上，一定要将该图标显示成一个向上符号，方便用户进行导航；

![action_bar_pattern_up_app_icon](C:\Users\Vincent Huang\Desktop\studynotes\Android\基础UI组件\appendix\action_bar_pattern_up_app_icon.png)

带向上操作的应用图标和不带向上操作的应用图标

2. 视图控制（View Control）。如果你的应用在不同的view中显示数据，ActionBar的这部分可以允许用户进行视图切换，切换视图的控制通过下拉菜单或tab来控制。如果你的应用不支持不同视图，你也可在该位置显示非交互内容，如应用标题或商标信息；
3. 操作按钮。该区域用来显示最重要最常用的操作，其他较少使用的操作项自动移入溢出菜单中。如果某个操作按钮不用了就隐藏它而不是禁用它（禁用仍然占用了宝贵的有限空间）；
4. 溢出操作。其他较少使用的操作项会被自动移入溢出菜单中。

##### **适应屏幕旋转和不同尺寸的屏幕**

一个最重要的UI问题就是在开发一款应用时如何适应屏幕旋转和不同尺寸的屏幕。可以通过分割ActionBar来适应这些变化，分割ActionBar可以在主ActionBar下方或在屏幕底部显示多个栏目（multiple bars）。

![action_bar_pattern_rotation](C:\Users\Vincent Huang\Desktop\studynotes\Android\基础UI组件\appendix\action_bar_pattern_rotation.png)

##### **考虑分割ActionBar布局**

通过多行ActionBar分割内容后，一般会在以下三个位置显示ActionBar的内容：

1. 主ActionBar
2. 顶部栏
3. 底部栏

![action_bar_pattern_considerations](C:\Users\Vincent Huang\Desktop\studynotes\Android\基础UI组件\appendix\action_bar_pattern_considerations.png)

如果用户可以在给定屏幕上导航，那么主ActionBar至少要包含一个向上的箭头符号。在顶部栏使用标签（tab）或下拉列表（spinner）可以让用户可以快速切换视图。可以在底部栏显示操作按钮和溢出菜单项。

##### **操作按钮的放置规则**

放置规则：

- 主ActionBar上的所有操作按钮加起来不要超过主ActionBar宽度的50%；
- 底部栏的操作按钮可以占据整个宽度；
- 主ActionBar上的屏幕宽度（以dp为单位）决定了显示多少个操作按钮图标：
  - 小于360 dp = 2 icons
  - 360-499 dp = 3 icons
  - 500-599 dp = 4 icons
  - 600 dp或更大 = 5 icons

通过在ActionBar中使用share action provider可以实现分享操作。分享操作按钮显示在下拉列表按钮旁边，包含一些分享选项。

![action_bar_pattern_share_pack](C:\Users\Vincent Huang\Desktop\studynotes\Android\基础UI组件\appendix\action_bar_pattern_share_pack.png)

##### **上下文操作栏**

上下文操作栏（contextual action bar，简称CAB ）是一个在执行特定操作期间临时覆盖应用操作栏的栏目。CAB通常用在选中数据或文本时显示出来。

![action_bar_cab](C:\Users\Vincent Huang\Desktop\studynotes\Android\基础UI组件\appendix\action_bar_cab.png)

ActionBar抽象类包含以下内部类和内部接口：

- public static class ActionBar.LayoutParams ，该类间接继承自android.view.ViewGroup.LayoutParams，直接继承自android.view.ViewGroup.MarginLayoutParams，所以该类可以使用这两个父类的XML属性和方法。该类还提供了一个android:layout_gravity属性用来控制其内部视图在父容器中的对齐方式；
- public static interface ActionBar.OnMenuVisibilityListener ，该接口用来监听ActionBar中菜单的消失和显示。可以用来在播放或暂停视屏、玩游戏等需要全屏的操作时显示或隐藏ActionBar；
- public static interface ActionBar.OnNavigationListener，该接口自API level 21就弃用了，不支持行内工具栏（inline toolbar）的ActionBar。主要用来监听导航项（navigation item）的选择；
- public static abstract class ActionBar.Tab ，该抽象类自API level 21就弃用了，不支持行内工具栏（inline toolbar）的ActionBar。Android推荐使用更为通用的[导航方式](https://developer.android.com/design/patterns/navigation.html) 。该类代表惯例Fragment显示或隐藏的标签。主要包含以下方法：
  - abstract View	getCustomView()：返回当前tab使用的自定义View；
    - abstract DrawablegetIcon()：设置该tab相关联的图标；
    - abstract intgetPosition()：获取当前tab在ActionBar中的位置；
    - abstract ObjectgetTag()：获取当前tab的标签（tag）；
    - abstract CharSequencegetText()：获取当前tab的文本；
    - abstract voidselect()：选中该tab；
    - abstract ActionBar.TabsetCustomView(int layoutResId)：设置该tab所用的自定义View。该方法会覆盖setText(CharSequence) 和 setIcon(Drawable)设置的值；
    - abstract ActionBar.TabsetCustomView(View view)：设置该tab所用的自定义View。该方法会覆盖setText(CharSequence) 和 setIcon(Drawable)设置的值；
    - abstract ActionBar.TabsetIcon(Drawable icon)：设置该tab的图标；
    - abstract ActionBar.TabsetIcon(int resId)：设置该tab的图标；
      abstract ActionBar.TabsetTabListener(ActionBar.TabListener listener)：设置监听从该tab切换出去或切换到该Tab的监听器；
    - abstract ActionBar.TabsetTag(Object obj)：设置该tab的标签（tag）；
    - abstract ActionBar.TabsetText(int resId)：设置该tab的显示文本；
    - abstract ActionBar.TabsetText(CharSequence text)：设置该tab的显示文本。
- public static interface ActionBar.TabListener，该接口也自API level 21就弃用了 该接口提供了以下三个方法：
  - abstract void	onTabReselected(ActionBar.Tab tab, FragmentTransaction ft)：当一个已被选中的tab再次被用户选中时回调该方法；
    - abstract voidonTabSelected(ActionBar.Tab tab, FragmentTransaction ft)：当一个tab进入选中状态时回调该方法；
    - abstract voidonTabUnselected(ActionBar.Tab tab, FragmentTransaction ft)：当一个tab退出选中状态时回调该方法。

ActionBar抽象类包含以下常量：

- int	DISPLAY_HOME_AS_UP：将“Home”操作按钮显示为“向上”操作按钮；
  - intDISPLAY_SHOW_CUSTOM：显示自定义View，如果已定义了一个这样的View；
  - intDISPLAY_SHOW_HOME：显示“Home”按钮，为其他导航按钮留出更多的空间；
  - intDISPLAY_SHOW_TITLE：显示Activity的标题和副标题，如果存在的话；
  - intDISPLAY_USE_LOGO：如果可用的话，使用logo代替图标；
  - intNAVIGATION_MODE_LIST：该常量自API level 21就弃用了。ActionBar的导航模式被启用了不支持行内工具栏的ActionBar，考虑使用通用导航方式；
  - intNAVIGATION_MODE_STANDARD：该常量自API level 21就弃用了。ActionBar的导航模式被启用了不支持行内工具栏的ActionBar，考虑使用通用导航方式；
  - intNAVIGATION_MODE_TABS：该常量自API level 21就弃用了。ActionBar的导航模式被启用了不支持行内工具栏的ActionBar，考虑使用通用导航方式。

常用方法如下：

- abstract void	addTab(ActionBar.Tab tab, int position)：在指定位置添加一个tab。该方法自API level 21就弃用了；
  - abstract voidaddTab(ActionBar.Tab tab)：添加一个tab。该方法自API level 21就弃用了；
  - abstract voidaddTab(ActionBar.Tab tab, int position, boolean setSelected)：在指定位置添加一个tab，并跳转到该tab上。该方法自API level 21就弃用了；
  - abstract voidaddTab(ActionBar.Tab tab, boolean setSelected)：：添加一个tab，并跳转到该tab上。该方法自API level 21就弃用了；
  - abstract View getCustomView()：获取一个自定义View；
  - abstract intgetDisplayOptions()：获取显示选项。返回值即ActionBar中定义的常量；
  - floatgetElevation()：返回该ActionBar在Z轴上的高度，以像素为单位；
  - abstract intgetHeight()：返回ActionBar的高度；
  - intgetHideOffset()：返回ActionBar的当前垂直偏移距离；
  - abstract intgetNavigationMode()：获取导航模式。可以指定为NAVIGATION_MODE_STANDARD、NAVIGATION_MODE_LIST、NAVIGATION_MODE_TABS之一。该方法自API level 21就弃用了；
  - abstract intgetSelectedNavigationIndex()：获取导航列表中或tab导航模式下选中的导航项的索引。该方法自API level 21就弃用了；
  - abstract ActionBar.TabgetSelectedTab()：获取当前选中的tab。该方法自API level 21就弃用了；
  - abstract CharSequencegetSubtitle()：获取当前ActionBar在标准模式下的副标题；
  - abstract ActionBar.TabgetTabAt(int index)：获取指定索引出的tab。该方法自API level 21就弃用了；
  - abstract intgetTabCount()：获取tab数量。该方法自API level 21就弃用了；
  - ContextgetThemedContext()：获取显示在ActionBar中的View所用主题的Context对象；
  - abstract CharSequencegetTitle()：获取ActionBar在标准模式下的标题；
  - abstract void**hide()**：隐藏该ActionBar；
  - abstract void**show()**：如果该ActionBar未显示则显示该ActionBar；
  - booleanisHideOnContentScrollEnabled()：判断该ActionBar是否随内部滚动View一起滚动消失在视野中；
  - abstract booleanisShowing()：判断该ActionBar是否已显示出来了；
  - abstract ActionBar.TabnewTab()：新建一个tab。该方法自API level 21就弃用了；
  - abstract voidremoveAllTabs()：删除所有tab。该方法自API level 21就弃用了；
  - abstract voidremoveOnMenuVisibilityListener(ActionBar.OnMenuVisibilityListener listener)：删除菜单可见性的监听器；
  - abstract voidremoveTab(ActionBar.Tab tab)：删除某个tab。该方法自API level 21就弃用了；
  - abstract voidremoveTabAt(int position)：删除某个tab。该方法自API level 21就弃用了；
  - abstract voidselectTab(ActionBar.Tab tab)：选中某个tab。该方法自API level 21就弃用了；
  - abstract voidsetBackgroundDrawable(Drawable d)：设置ActionBar的背景色；
  - abstract voidsetCustomView(View view, ActionBar.LayoutParams layoutParams)：设置该ActionBar处于自定义导航模式，提供一个自定义导航的View；
  - abstract voidsetCustomView(View view)：设置该ActionBar处于自定义导航模式，提供一个自定义导航的View；
  - abstract voidsetCustomView(int resId)：设置该ActionBar处于自定义导航模式，提供一个自定义导航的View；
  - abstract voidsetDisplayHomeAsUpEnabled(boolean showHomeAsUp)：设置是否将“Home”按钮设置向上按钮；
  - abstract voidsetDisplayOptions(int options, int mask)：设置显示选项。options参数即为ActionBar中定义的常量，mask指定哪一个显示选项会被改变。如setDisplayOptions(NAVIGATION_MODE_STANDARD, DISPLAY_SHOW_HOME) 将禁用DISPLAY_SHOW_HOME选项，setDisplayOptions(DISPLAY_SHOW_HOME, DISPLAY_SHOW_HOME | DISPLAY_USE_LOGO) 将启用DISPLAY_SHOW_HOME 禁用DISPLAY_USE_LOGO；
  - abstract voidsetDisplayOptions(int options)：设置显示选项。options参数即为ActionBar中定义的常量；
  - abstract voidsetDisplayShowCustomEnabled(boolean showCustom)：设置是否显示自定义View（如果设置了的话）；
  - abstract voidsetDisplayShowHomeEnabled(boolean showHome)：设置是否显示“Home”按钮；
  - abstract voidsetDisplayShowTitleEnabled(boolean showTitle)：设置是否显示标题；
  - abstract voidsetDisplayUseLogoEnabled(boolean useLogo)：设置是否显示logo；
  - void setElevation(float elevation)：设置该ActionBar在Z轴方向上的像素高度；
  - void setHideOffset(int offset)：设置隐藏时的偏移出屏幕的距离。offset参数的范围是从0（完全可见）到ActionBar的测量高度（easured height）（完全不可见）；
  - void setHideOnContentScrollEnabled(boolean hideOnContentScroll)：设置该ActionBar是否随内容的滚动而消失；
- void setHomeAsUpIndicator(int resId)：当DISPLAY_HOME_AS_UP可用时，设置显示向上按钮所用的Drawable资源；
- void setHomeAsUpIndicator(Drawable indicator)：当DISPLAY_HOME_AS_UP可用时，设置显示向上按钮所用的Drawable对象；
- void setHomeButtonEnabled(boolean enabled)：设置是否使用“Home”按钮；
  - abstract voidsetIcon(Drawable icon)：设置显示“Home”按钮的Drawable对象；
  - abstract voidsetIcon(int resId)：设置显示“Home”按钮的资源；
  - abstract voidsetListNavigationCallbacks(SpinnerAdapter adapter, ActionBar.OnNavigationListener callback)：设置列表导航模式下导航所用的Adapter或导航监听器。该方法自API level 21就弃用了；
  - abstract voidsetLogo(int resId)：设置显示“Home”所用logo的资源；
  - abstract voidsetLogo(Drawable logo)：设置显示“Home”所用logo的Drawable对象；
  - abstract voidsetNavigationMode(int mode)：设置导航模式。可以设置为NAVIGATION_MODE_STANDARD、NAVIGATION_MODE_LIST、NAVIGATION_MODE_TABS之一。该方法自API level 21就弃用了；
  - abstract voidsetSelectedNavigationItem(int position)：设置选中列表导航模式或tab导航模式下指定位置的导航项；
- void setSplitBackgroundDrawable(Drawable d)：设置分割ActionBar的分割栏的背景。可以通过在 \<activity>或\<application>标签中指定[uiOptions](https://developer.android.com/reference/android/R.attr.html#uiOptions) 为none或splitActionBarWhenNarrow来选择是否分割ActionBar；
  - voidsetStackedBackgroundDrawable(Drawable d)：设置ActionBar堆叠行的背景色；
  - abstract voidsetSubtitle(CharSequence subtitle)：设置副标题；
  - abstract voidsetSubtitle(int resId)：设置副标题；
  - abstract voidsetTitle(CharSequence title)：设置标题；
  - abstract voidsetTitle(int resId)：设置标题。

#### **[ActionProvider](https://developer.android.com/reference/android/support/v4/view/ActionProvider.html)**

该抽象类（android.support.v4.view.ActionProvider）代表完成给定任务（如分享操作）的中介，它负责创建用于完成给定任务的操作的View。该类也实现了默认操作功能。

该类包含在兼容到API level 4 或更高版本的 [support library](https://developer.android.com/tools/extras/support-library.html) 中，如果开发基于 API level 14 或更高版本的应用时，应该使用框架中的[android.view.ActionProvider](https://developer.android.com/reference/android/view/ActionProvider.html)。

可为MenuItem对象指定一个ActionProvider对象，当该MenuItem作为ActionBar Item显示在ActionBar中时，绑定的ActionProvider对象将负责创建显示在ActionBar中的操作按钮来替换该MenuItem。如果该MenuItem在溢出菜单中被选中而没有回调方法来处理该选中事件，则该绑定的ActionProvider对象也负责指定默认的选中操作。该ActionProvider对象也可以提供一个子菜单。

ActionProvider创建并处理Action View的方式有以下两种：

- 通过[MenuItemCompat.setActionProvider(android.view.MenuItem, ActionProvider)](https://developer.android.com/reference/android/support/v4/view/MenuItemCompat.html#setActionProvider(android.view.MenuItem, android.support.v4.view.ActionProvider)) 方法为一个MenuItem对象指定一个ActionProvider对象；

- 在菜单资源的XML文件中通过android:actionProviderClass属性指定一个ActionProvider：

  ```xml
  <item android:id="@+id/my_menu_item"
       android:title="Title"
       android:icon="@drawable/my_menu_item_icon"
       android:showAsAction="ifRoom"
       android:actionProviderClass="foo.bar.SomeActionProvider" />
  ```

#### **[ShareActionProvider](https://developer.android.com/reference/android/support/v7/widget/ShareActionProvider.html)**

该类（android.support.v7.widget.ShareActionProvider）继承自上面的android.support.v4.view.ActionProvider，代表一个适合应用栏的分享操作，负责创建可以分享数据的View，如果创建的View显示在溢出菜单中，将创建一个分享用的子菜单。该类也有对应的框架版本（android.widget.ShareActionProvider）。

通过在应用栏菜单资源的XML文件中添加一个ShareActionProvider来为Activity添加一个分享操作：

```xml
<item android:id="@+id/action_share"
      android:title="@string/share"
      app:showAsAction="ifRoom"
      app:actionProviderClass="android.support.v7.widget.ShareActionProvider"/>
```

因为ShareActionProvider有自己的外观和行为，就不需要为其添加图标了。但是，应该为其通过android:title属性指定一个标题，以防它显示在溢出菜单中（在溢出菜单中可能不显示图标）。

接下来设置包含当前Activity可分享数据的Intent，应该在onCreateOptionsMenu()方法中创建该Intent，每次分享内容改变时都更新该Intent：

1. 通过向getActionProvider()方法传入分享操作的MenuItem来获得ShareActionProvider对象的引用。例如：

```java
 MenuItem shareItem = menu.findItem(R.id.action_share);
 ShareActionProvider myShareActionProvider =
     (ShareActionProvider) MenuItemCompat.getActionProvider(shareItem);
```

2. 创建一个ACTION_SEND 的Intent，附上当前Activity分享的数据。例如，下面代码中的Intent分享了一张照片：

```java
  Intent myShareIntent = new Intent(Intent.ACTION_SEND);
  myShareIntent.setType("image/*");
  Uri uri = Uri.fromFile(new File(getFilesDir(), "foo.jpg"));
  myShareIntent.putExtra(Intent.EXTRA_STREAM, uri.toString());
```

3. 调用[ShareActionProvider.setShareIntent()](https://developer.android.com/reference/android/support/v7/widget/ShareActionProvider.html#setShareIntent(android.content.Intent)) 方法来将该Intent添加到前面的ShareActionProvider对象上：

```java
 myShareActionProvider.setShareIntent(myShareIntent); 
```

4. 当内容变化时，修改该Intent或者创建一个新的Intent，然后再次调用setShareIntent()方法：

```java
// Image has changed! Update the intent:
myShareIntent.putExtra(Intent.EXTRA_STREAM, myNewImageUri);
myShareActionProvider.setShareIntent(myShareIntent);
```

ShareActionProvider对象保留了一个基于用户选择频率的分享目标的排名，用户选择的越频繁，排名越高。使用最多的目标显示在应用栏中作为默认分享目标。

默认情况下，排名信息存储在一个名为 [DEFAULT_SHARE_HISTORY_FILE_NAME](https://developer.android.com/reference/android/support/v7/widget/ShareActionProvider.html#DEFAULT_SHARE_HISTORY_FILE_NAME) （ShareActionProvider的唯一常量，String类型）的私有文件中。ShareActionProvider将所有分享历史存储在该文件中。但是，如果ShareActionProvider用于不同类型的内容，单一的一套排名就没有了意义。例如，如果Activity有时候分享图片，有时候分享联系人，就应该维护两套不同的排名。

通过在调用[setShareHistoryFileName()](https://developer.android.com/reference/android/support/v7/widget/ShareActionProvider.html#setShareHistoryFileName(java.lang.String)) 方法是出入一个XML文件来设置该分享历史文件。指定的文件在下次调用setShareHistoryFileName()方法之前将一直使用：

```java
 private void doShare(Intent intent) {
     if (IMAGE.equals(intent.getMimeType())) {
         mShareActionProvider.setHistoryFileName(SHARE_IMAGE_HISTORY_FILE_NAME);
     } else if (TEXT.equals(intent.getMimeType())) {
         mShareActionProvider.setHistoryFileName(SHARE_TEXT_HISTORY_FILE_NAME);
     }
     mShareActionProvider.setIntent(intent);
     supportInvalidateOptionsMenu();
 }
```

如果没必要保留多个排名文件，就传入null作为参数，这样将使用默认的DEFAULT_SHARE_HISTORY_FILE_NAME作为分享历史的文件名。可以在任何时候设置调用该方法设置这个文件名，然而只有在设置该文件名之后，通过[onCreateActionView()](https://developer.android.com/reference/android/support/v7/widget/ShareActionProvider.html#onCreateActionView()) 创建的Action View的才会被这个文件支持。因此，如果想为不同类型的分享内容使用不同的历史文件，每次通过setShareHistoryFileName(String)改变历史文件后必须调用[AppCompatActivity.supportInvalidateOptionsMenu()](https://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html#supportInvalidateOptionsMenu()) 来再次创建Action View。不应该在onCreateOptionsMenu(Menu)中调用supportInvalidateOptionsMenu()。

ShareActionProvider其他常用方法如下：

- void setOnShareTargetSelectedListener (ShareActionProvider.OnShareTargetSelectedListener listener)：设置一个分享目标被选中的监听器。该监听器可以选择在分享操作实际执行之前是否执行一些其他操作。如果在该监听器中支持分享历史文件，则在该回调中将仍会接到分享通知。不能在该监听器中修改Intent，该监听器目的主要是通知分享操作正在执行，如果有必要可以用来更新UI；
- View onCreateActionView ()：创建Action View的工厂方法；
- boolean hasSubMenu ()：判断该ShareActionProvider是否有一个相关联的子菜单。当Action View没有显示时就会显示该关联的子菜单。在子菜单显示之前，该ShareActionProvider实例会在 onPerformDefaultAction() 调用之后调用onPrepareSubMenu(SubMenu) ；
- void onPrepareSubMenu (SubMenu subMenu)：准备该ShareActionProvider相关联的子菜单。如果hasSubMenu ()返回true，当子菜单项被选中后准备将子菜单列表显示给用户时将调用该方法。应用可以在显示子菜单列表之前创建或修改子菜单的内容。

测试实例：

overflow_menu_test_items.xml：

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <!-- actionViewClass属性用来指定Action View。collapseActionView 表明了当用户不与该部件交互时，
    该部件将显示为android:icon属性指定的图标 -->
    <item
        android:id="@+id/search_item"
        android:title="@string/action_text_search"
        android:icon="@drawable/icon_search_black"
        app:showAsAction="ifRoom|collapseActionView"
        app:actionViewClass="android.support.v7.widget.SearchView" />
    <!-- acitonProvider属性用来指定一个Action Provider-->
    <item
        android:id="@+id/action_provider_test_item"
        android:title="@string/action_text_share"
        android:icon="@drawable/icon_share_black"
        app:showAsAction="ifRoom|collapseActionView"
        app:actionProviderClass="android.support.v7.widget.ShareActionProvider"/>
    <!-- 如果应用栏有足够的空间，则该菜单项将作为一个按钮被添加应用栏中，否则，就添加到溢出菜单中 -->
    <item
        android:id="@+id/red_item"
        android:icon="@drawable/font_color_black"
        android:title="@string/text_red"
        app:showAsAction="ifRoom|collapseActionView" />
    <!-- 该菜单项将会一直列在溢出菜单中，而不会显示在应用栏中 -->
    <item
        android:id="@+id/green_item"
        android:title="@string/text_green"
        app:showAsAction="never" />
    <item
        android:id="@+id/blue_item"
        android:title="@string/text_blue"
        app:showAsAction="collapseActionView" />
    <item
        android:id="@+id/font_10"
        android:icon="@drawable/font_size_black"
        android:title="@string/font_10"
        app:showAsAction="ifRoom" />
    <!-- 默认使用 -->
    <item
        android:id="@+id/font_14"
        android:title="@string/font_14" />
    <item
        android:id="@+id/font_16"
        android:title="@string/font_16"
        app:showAsAction="withText" />

</menu>
```

AndroidManifest.xml：

```xml
<application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        <!-- 中间省略了其他Activity -->
        <!-- 设置该Activity可以向上返回到指定的父Activity -->
        <activity android:name=".activity.AppBarTest"
            android:theme="@style/Theme.AppCompat.Light.NoActionBar"
            android:parentActivityName=".MainActivity">
            <meta-data
                android:name="android.support.PARENT_ACTIVITY"
                android:value=".MainActivity"/>
        </activity>
    </application>
```

AppBarTest.java：

```java
public class AppBarTest extends AppCompatActivity {
    private TextView appBarTestTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_app_bar_test);
        Toolbar mToolbar = (Toolbar) findViewById(R.id.my_test_Toolbar);
        appBarTestTextView = (TextView) findViewById(R.id.appbar_test_text_view);

        setSupportActionBar(mToolbar);
        ActionBar testActionBar = getSupportActionBar();

        if (testActionBar != null) {
            // 启用向上按钮
            testActionBar.setDisplayHomeAsUpEnabled(true);
            // 设置ActionBar的标题
            testActionBar.setTitle(R.string.test_action_bar_title);
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater menuInflater = getMenuInflater();
        menuInflater.inflate(R.menu.overflow_menu_test_items, menu);

        MenuItem searchItem = menu.findItem(R.id.search_item);
        MenuItem providerItem = menu.findItem(R.id.action_provider_test_item);

        // 监听Action View的扩展和折叠事件
        MenuItemCompat.setOnActionExpandListener(searchItem, new MenuItemCompat.OnActionExpandListener() {
            @Override
            public boolean onMenuItemActionExpand(MenuItem item) {
                if (item.getItemId() == R.id.search_item) {
                    Toast.makeText(AppBarTest.this, "该Action View扩展开了", Toast.LENGTH_SHORT).show();
                }
                // 返回true表明处理了展开事件，如果返回false，就表明没有处理展开事件，该Action View就不会展开
                return true;
            }

            @Override
            public boolean onMenuItemActionCollapse(MenuItem item) {
                if (item.getItemId() == R.id.search_item) {
                    Toast.makeText(AppBarTest.this, "该Action View折叠起来了", Toast.LENGTH_SHORT).show();
                }
                return true;
            }
        });

        // 获取Action View并执行与该View相关的操作
        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
        searchView.setQueryHint("搜索文本");
        searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
            @Override
            public boolean onQueryTextSubmit(String query) {
                Toast.makeText(AppBarTest.this, "未找到[" + query + "]", Toast.LENGTH_SHORT).show();
                return false;
            }

            @Override
            public boolean onQueryTextChange(String newText) {
                return false;
            }
        });

        // 获取ActionBar Provider并执行相关操作
        ShareActionProvider mShareActionProvider = (ShareActionProvider) MenuItemCompat
                .getActionProvider(providerItem);
        // 创建一个发送的Intent，并附上分享的数据
        Intent mShareIntent = new Intent(Intent.ACTION_SEND);
        mShareIntent.setType("text/plain");
        mShareIntent.putExtra(Intent.EXTRA_STREAM, appBarTestTextView.getText());
        mShareActionProvider.setShareIntent(mShareIntent);

        return super.onCreateOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.red_item:
                appBarTestTextView.setTextColor(Color.RED);
                return true;
            case R.id.green_item:
                appBarTestTextView.setTextColor(Color.GREEN);
                return true;
            case R.id.blue_item:
                appBarTestTextView.setTextColor(Color.BLUE);
                return true;
            case R.id.font_10:
                appBarTestTextView.setTextSize(10.0F);
                return true;
            case R.id.font_14:
                appBarTestTextView.setTextSize(14.0F);
                return true;
            case R.id.font_16:
                appBarTestTextView.setTextSize(16.0F);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }
}
```

运行效果如下图所示：

![Appbar](C:\Users\Vincent Huang\Desktop\studynotes\Android\基础UI组件\appendix\Appbar.gif)