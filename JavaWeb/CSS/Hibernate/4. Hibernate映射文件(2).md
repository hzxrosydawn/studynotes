### Hibernate关联映射

关联关系是面向对象分析、面向对象设计最中要的知识，Hibernate完全可以理解这种关联关系，如果映射得当，Hibemate的关联映射将可以大大简化持久层数据的访问。关联关系大致有如下两个分类：

- **单向关系**：只需单向访问关联端。例如，**只能通过老师访问学生，或者只能通过学生访问老师**。
- **双向关系**：关联的两端可以互相访问。例如，**老师和学生之间可以互相访问**。

单向关联可分为：

- 单向N-1
- 单向1-1
- 单向1-N
- 单向N-N

双向关联又可分为：

- 双向1-1
- 双向1-N
- 双向N-N

> 注意：双向关系单没有N一1，因为双向关系1-N和N-1是完全相同的。

### 单向N-1关联

N-1是非常常见的关联关系，最常见的父子关系也是N-1关联，**单向的N-1关联只需从N的一端可以访问1的一端**。单向N-1关系，比如多个人对应同一个住址，只需从人实体端可以找到对应的地址实体，无须关心某个地址的全部住户。为了让两个持久化类支持这种关联映射，程序应该在N的一端的持久化类中增加一个属性，该属性引用1的一端的关联实体。下面是两个持久化类描述了这种关联关系，Person类中增加了一个Address属性，引用关联的Address实体。

```java
public class Person {
	//标识属性
	private Integer id;
	//普通属性name
	private String name;
	//普通属性age
	private int age;
	//引用关联实体的属性
	private Address address;
	
	//省略setter和getter方法
  	...
}
```

```java
public class Address {
	//标识属性
	private Integer addressId;
	//地址详细信息
	private String addressDetail;
  
	//无参数的构造器
	public Address() {
	}
  
	//初始化全部属性的构造器
	public Address(String addressDetail) {
		this.addressDetail = addressDetail;
	}
	
	//省略setter和getter方法
	...-
}
```

#### 无连接表的N-1关联

Person端增加了Address属性，该属性不是一个普通的组件属性，而是引用另一个持久化类的类。

**Hibernate使用`<many-to-one.../>`元素映射N-1的关联实体，直接采用`<many-to-one.../>`元素来映射关联实体将会在N的一端的数据表中增加一个外键列，用于参照主表记录**。

**直接使用`<many-to-one.../>`元素来映射N-1关联时，Hibernate将无须使用连接表，直接使用外键关联策略来处理这种关联映射**。`<many-to-one.../>`元素的作用有点类似于`<property.../>`元素，也用于映射持久化类的某个属性，区别是该元素映射的是关联实体。与`<property.../>`元素类似的是，`<many-to-one.../>`元素还可拥有如下可选属性：

- name：该属性用来确定该属性的名称；
- column：该属性指定进行关联的**外键列的列名，该列名默认与该属性同名**；
- class：该属性指定**关联实体的全限定类名，默认是通过反射得到该属性所属类的类名**；
- cascade：该属性指定哪些持久化操作会从主表记录级联到子表记录。关于关联实体之间的级联行为，后面还会有更详细的介绍；
- fetch：该属性指定Hibernate的抓取策略，该属性值只能是join（使用外连接抓取）和select（使用选择抓取）两个值的其中之一；
- update、insert：**指定对应的字段是否包含在用于Hibernate生成的update或insert语句中，两个属性的默认值都是true。如果将二指定为false，则表明这是一个纯粹的外源关联**，它的值是通过映射同一个（或多个）字段的其他属性得到的，或由触发器或其他程序来负责生成；
- property-ref：指定关联类的一个属性，这个属性将会和本类的外键相对应（当外键参照唯一键时需指定该属性）。如果没有指定，直接使用对方关联类的主键；
- access：指定Hibernate访问此关联属性的访问策略，默认是property；
- unique：指定Hiberate通过DDL为外健列添加唯一约束。此外，也可以用做property-ref的目标属性。这使关联同时具有一对一的效果；
- not-null：指定使用DDL为外键字段添加非空约束；
- optimistic-lock：该属性指定其更新时是否需要获得乐观锁定，也就是其值决定引用关联实体的属性发生改变时版本值是否增长；
- lazy：指定引用关联实体的延迟加载特性，该属性只能接受false、proxy、no-proxy三个值，该属性默认值是proxy。实际上，Hibernate默认会启动单实例关联（即多对一、一对一）的代理，指定no-proxy即要求该属性应该在实例变量第一次被访问时采用延迟抓取，`lazy="false"`指定此关联实体总是被预先抓取；
- not-found：该属性指定当外键参照的主表记录不存在时如何处理。该属性只接受ignore和exception两个值，默认是exception。即不存在时抛出异常。如果程序希望Hibernate忽略这个异常，则可指定该属性值为ignore；
- formula：指定一个SQL表达式，该外键值将根据该SQL表达式来计算。

对应的映射文件如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- 映射Person持久化类-->
	<class name="Person" table="person_id">
		<!-- 映射标识属性 -->
		<id name="id" column="person_id">
			<!-- 定义主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- 用于映射N-1关联实体，指定关联实体类为Address
		指定外键列名为address_id,并指定级联全部操作 -->
		<many-to-one name="address" cascade="all" class="Address" column="address_id"/>
	</class>
</hibernate-mapping>
```

因为1的一端无须访问N的一端，所以Address类的映射文件无须改变。

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- Address持久化类-->
	<class name="Address" table="address_inf">
		<!-- 映射标识属性addressid -->
		<id name="addressId" column="address_id">
			<!-- 指定主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 映射普通属性addressDetail -->
		<property name="addressDetail"/>
	</class>
</hibernate-mapping>
```

测试代码如下：

```java
private void testPerson() {
	Session session = HibernateUtil.currentSession();
	Transaction tx = session.beginTransaction();
	//创建一个Person对象
	Person p = new Person();
	//创建一个瞬态的Address对象
	Address a = new Address("德玛西亚");
	//设置Person的Name为Yeeku字符串
	p.setName("rosydawn");
	p.setAge(24);
	//设置Person和Address之间的关联关系
	p.setAddress(a);
	//持久化Person对象
  	//先执行一条insert into address...语句
  	//再执行一条insert into person...语句
	session.persist(p);
	//创建一个瞬态的Address对象
	Address a2 = new Address("诺克萨斯");
	//修改持久化状态的Person对象
  	//Hibernate会先执行一条insert into addres..语句插入记录
  	//再执行update person..。修改该Person记录的外键值
	p.setAddress(a2);
	tx.commit();
	HibernateUtil.closeSession();
}
```

当程序执行到`session.persist(p);`处时，系统准备保存Person对象，系统将要向PERSON_INF数据表中插入一条记录，但该记录参照的主表记录还不曾保存（被参照的Address实体还处于瞬态），这时可能有如下两种情况发生。

- **系统抛出TransientObjectException异常**：object references an unsaved transient instance。因为主表记录不曾插入，所以参照该记录的从表记录无法插入；
- **系统先自动级联插入主表记录，再插入从表记录**。

因为上面的映射文件中指定了`cascade="all"`这意味着系统将先自动级联插入主表记录，也就是先持久化Address对象，再持久化Person对象。如果上面的映射文件缺少`casade="all"`，则程序运行到粗体字代码处将抛出TransientObjectException异常。总之，**在所有基于外键约束的关联关系中，要么总是先持久化主表记录对应的实体，要么设置级联操作；否则Hibernate试图插入从表记录时，如果发现该从表记录参照的主表记录不存在，就会抛出异常**。

#### 有连接表的N-1关联

底层数据库建模时可以使用连接表来建立单向N-1关联关系。Hibernate也支持通过显式使用`<join.../>`元素来强制使用连接表映射单向N-1关联，该元素用于将一个类的属性映射到多张表中。`<join.../>`元素还支持如下几个可选属性：

- table：指定连接表的表名；
- schema：指定此连接表所在的Schema，用于覆盖根元素的default-schema属性；
- catalog：指定此连接表所在的Catalog，用于覆盖根元素的default-catalog属性；
- inverse：该属性默认值是false，如果设置为true，则Hibernate不会插入或者更新此连接定义的属性；
- optional：该属性默认值是false，如果将属性设为true，则Hibernate只会在此连接定义的属性非空时插入一行数据，并且总是使用外连接来得到该属性。

使用`<join.../>`元素映射连接表时还需要外键关联，应在配置文件中增加`<key.../>`子元素来映射外键，并为`<join.../>`元素增加`<many-to-one.../>`子元素，用于映射N-1的关联实体。该`<many-to-one.../>`子元素的用法与不使用连接表的`<many-to-one.../>`子元素的用法完全相同。

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- 映射Person持久化类-->
	<class name="Person" table="person_inf">
		<!-- 映射标识属性 -->
		<id name="id" column="person_id">
			<!-- 定义主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- 使用join元素强制使用连接表 -->
		<join table="person_address" >
			<!-- 映射连接表中参照本表主键的外键列 -->
			<key column="person_id"/>
			<!-- 映射连接表中参照关联实体的外键列 -->
			<many-to-one name="address" cascade="all" class="Address" column="address_id"/>
		</join>
	</class>
</hibernate-mapping>
```

上面的映射文件完成了有连接表的N-1关联映射，至于Address类的映射文件则无须进行任何修改，主程序也无须任何修改。程序运行结束后，将看到person_inf数据表中无须增加额外的外键列，程序将会使用person_address连接表来标识person_inf表和address_inf表之间的关联关系。person_address连接表中使用person_id列和address_id列分别关联person_inf表中的person_id列和address_inf表中的address_id列，同时，person_id列作为person_address连接表的主键，从而保证每个Person实体最多关联一个Address实体。

### 单向1-1关联

**对于单向的1-1关联关系，需要在持久化类里为关联实体的引用属性增加setter和getter方法**。从持久化类上来看，单向1-1与单向N-1没有丝毫区别。因为主动的N（N-1）或1（1-1）的一端都是直接访问关联实体，只需增加关联实体属性的setter和getter方法即可。事实上，单向1-1与N-1的映射配置也非常相似。只需要原有的`<many-to-one.../>`元素增加`unique="true"`属性，用以表示N的一端必须唯一即可。既然N的一端增加了唯一约束，那么两端就成为1-1关联了。

#### 基于外键的单向1-1

将无连接表的`N-1`关联映射中的`<many-to-one.../>`元素里增加`unique="true"`属性，即可完成这种映射。实例映射文件如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- 映射Person持久化类-->
	<class name="Person" table="person_inf">
		<!-- 映射标识属性 -->
		<id name="id" column="person_id">
			<!-- 定义主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- 用于映射1-1关联实体，指定关联实体类为Address
		指定外键列名为address_id,并指定级联全部操作 -->
		<many-to-one name="address" cascade="all" unique="true" class="Address" column="address_id"/>
	</class>
</hibernate-mapping>
```

实际运行时，Hibernate会为person_inf的address_id列添加unique约束。

#### 有连接表的单向1-1

虽然这种情况很少见，但Hibernate同样允许采用连接表映射单向`1-1`关联。有连接表的单向`1-1`关联同样只需要将有连接表的单向`N-1`关联中的`<many-to-one.../>`元素增加`unique="true"`属性即可。示例映射文件如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- 映射Person持久化类-->
	<class name="Person" table="person_inf">
		<!-- 映射标识属性 -->
		<id name="id" column="person_id">
			<!-- 定义主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- 使用join元素强制使用连接表 -->
		<join table="person_address" >
			<!-- 映射连接表中参照本表主键的外键列 -->
			<key column="person_id"/>
			<!-- 映射连接表中参照关联实体的外键列 -->
			<many-to-one name="address" cascade="all" unique="true" class="Address" column="address_id"/>
		</join>
	</class>
</hibernate-mapping>
```

实际运行时，Hibernate会为person_address连接表中address_id列添加unique约束。

#### 基于主键的单向1-1

在基于主键的`1- 1`的关联中，持久化类不能拥有自己的主键生成器策略，它的主键由关联实体来负责生成。采用基于主键的`1-1`关联时，应使用`<one-to-one.../>`元素来映射关联实体。`<one-to-one.../>`元素可接受如下几个属性：

- name：该属性值为关联实体属性的属性名。必选，后面的属性都是可选的；
- class：该属性指定关联实体的全限定类名，默认是通过反射得到该属性所属类的类名；
- cascade：该属性指定哪些操作会从主表记录级联到从表记录；
- constrained：表明**该类对应的表，和被关联的对象所对应的数据表之间，通过一个外键引用对主键进行约束**。这个选项影响save()和delete()在级联执行时的先后顺序，以及决定该关联能否被委托（也在schema export tool中被使用）；
- fetch：该属性设置抓取策略，该属性接受join（外连接抓取）和select（选择抓取）两个值的其中之一；
- property-ref：指定关联类中和本类的主键相对应的一个属性。如果没有指定，默认使用对方关联类的主键和本类的主键对应；
- access：指定Hibernate访问该关联属性的访问策略，默认是property；
- lazy：指定引用关联实体的延迟加载特性，该属性只能接受false、proxy、no-proxy三个值。该属性默认值是proxy。实际上，Hibernate默认会启动单实例关联（即多对一、一对一）的代理，指定no-proxy即要求该属性应该在实例变量第一次被访问时采用延迟抓取，`lazy="false"`指定此关联实体总是被预先抓取。

实例映射文件如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- 映射Person持久化类-->
	<class name="Person" table="person_inf">
		<!-- 映射标识属性 -->
		<id name="id" column="person_id">
			<!--  基于主键关联时，主键生成策略是foreign，
			表明根据当前类的主键有关联类的主键来生成 -->
			<generator class="foreign">
				<!-- 指定引用关联实体的属性名 -->
				<param name="property">address</param>
			</generator>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- 下面映射基于主键的1－1关联 -->
		<one-to-one name="address"/>
	</class>
</hibernate-mapping>
```

### 单向1-N关联

单向`1-N`关联的持久化类里需要使用集合属性来表示N的一端。从这个意义上来看，`1-N`（实际上还包括`N-N`）和集合映射非常相似，只是将用于映射集合元素的`<element.../>`元素改为使用`<one-to-many.../>` 元素。使用`<one-to-many.../>`元素可以指定如下两个可选属性：

- class：该属性指定了关联实体的类型，默认通过反射来获取关联实体的类型，如果集合属性没有使用泛型，则必须指定该属性；
- not-found：该属性值只能是exception或ignore，指定当从表记录参照的主表记录不存在时，Hibernate如何处理这种情况。该属性值默认是exception，即抛出一个异常。如果程序希望Hibernate忽略这个异常，可以指定`not-found="ignore"`。

对于单向的1-N关联关系，只要在1的一端增加Set类型的属性，该属性记录当前实体的关联实体，当然还要为这个Set类型的属性增加sette和getter方法即可。将Person类修改为如下形式：

```java
public class Person {
	//标识属性
	private Integer id;
	//Person的name属性
	private String name;
	//保留Person的age属性
	private int age;

	//1－N关联关系，使用Set来保存关联实体
	private Set<Address> addresses = new HashSet<Address>();

	//省略id、name和age属性的setter和getter方法
	... 
	//addresses属性的setter和getter方法
	public void setAddresses(Set<Address> addresses) {
		this.addresses = addresses;
	}
	public Set<Address> getAddresses() {
		return this.addresses;
	}
}
```

由于N的一端无须访问1的一端，所以Address类无须改变。

#### 无连接表的单向1-N

对于`1-N`的单向关联，需要在1的一端增加对应的集合映射元素，例如`<set.../>`、`<bag.../>` （通常不要使用`<list.../>`元素）等元素。与映射集合属性类似，必须为`<set.../>`、`<bag.../>`等集合元素增加`<key.../>`元素，用以映射外键列。与集合属性不同的是，建立`1-N`关联时，集合中的元素使用`<one-to-many.../>`来映射关联实体，而不是使用`<element.../>`元素。示例的映射文件如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<class name="Person" table="person_inf">
		<!-- 映射标识属性 -->
		<id name="id" column="person_id">
			<!-- 定义主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- 映射集合属性，集合元素是其他持久化实体
		没有指定cascade属性 -->
		<set name="addresses">
			<!-- 指定关联的外键列 -->
			<key column="person_id"/>
			<!-- 用以映射到关联类属性 -->
			<one-to-many class="Address"/>
		</set>
	</class>
</hibernate-mapping>
```

测试代码如下：

```java
private void testPerson() {
	Session session = HibernateUtil.currentSession();
	Transaction tx = session.beginTransaction();
	//创建一个Person对象
	Person p = new Person();
	//创建一个瞬态的Address对象
	Address a = new Address("德玛西亚");
	//必须先持久化Address对象
	session.persist(a);	
	//设置Person的Name为rosydawn字符串
	p.setName("rosydawn");
	p.setAge(25);
	//设置Person和Address之间的关联关系
	p.getAddresses().add(a);
	//持久化Person对象
	session.save(p);
	//创建一个瞬态的Address对象
	Address a2 = new Address("诺克萨斯");
	//先持久化Address对象
	session.persist(a2);
	//修改持久化状态的Person对象
	p.getAddresses().add(a2);
	tx.commit();
	HibernateUtil.closeSession();
}
```

当执行到`session.save(p);`语句时，Hibernate会先执行一条`insert into person_inf...`语句来插入一条person_inf 记录，再试图执行一条`update address_inf...`语句，将当前person_inf表记录关联的address_inf表记录的外键修改为该person_inf表记录的主键值。

如果person_inf主表中被参照的记录不存在会怎样？如果程序在`<set.../>`元素中指定了`cascade="all"`，则Hibernate会按照上面的步骤执行。正如上面的程序看到的，由于配置`<set.../>`元素时没有指定`cascade="all"`，因此程序对Person实体的持久化操作不会级联到关联的Address实体，程序必须显式持久化两个Address实体。

从上面的执行过程可以看出，虽然上面程序仅仅需要为Person实体增加一个关联Address实体，但Hibernate会采用两条SQL语句来完成：一条insert语句插入一条外键为null的address_inf记录，一条update语句来修改刚刚插入的addres_inf记录，这肯定会造成系统性能不好，而且不能为address_inf的外键添加`not null`约束。造成这种现象是由于从Person到Address的关联（外键person_id）没有被当做Address对象状态的一部分（ 程序是通过把Address实体添加到Person实体的addresses集合属性中，而Address实体并不知道它所关联的Person实体），因而Hibernate无法在执行`insert into address_inf...`语句时为该记录的外键列指定值。

为了解决这个问题的思路，程序必须在持久化Address实体之前，让Address实体能“知道”它所关联的Person实体，也就是应该通过`address.setPerson(person);`方法来建立关联关系，这就需要把这个关联关系添加到Address的映射中，但这就变成1-N双向关联。因此**建议尽量少用单向的1-N关联，而是改为使用双向的1-N关联**。

对于双向的1- N父子关联，使用1的一端控制关系的性能，比使用N的一端控制关系的性能低。性能低的原因是当使用1的一端控制关联关系时，由于插入数据时无法同时插入外键列，因此会额外多出一条update语句，而且外键列还无法增加非空约束。

#### 有连接表的单向1-N

对于有连接表的1- N关联映射，映射文件不再使用`<one-to-many.../>`元素映射关联实体，而是使用`<many-to-many.../>`元素，但为了保证当前实体是1的端，因此要为元素指定`unique-="tue"`使用`<many-to-many.../>`元素时还可指定如下几个可选属性：

- class：指定关联实体的类名，默认由Hibernate通过反射来获取该类名；
- not-found：该属性值只能是exception或ignore，指定当从表记录参照的主表记录不存在时，Hibernate如何处理这种情况。该属性值默认是exception，即抛出一个异常。如果程序希望Hibernate忽略这个异常，可以指定`not-found="ignore"`；
- formula：指定一个个SQL表达式，该外键值将根据该SQL表达式来计算；
- outerjoin：指定Hibernate是否要启动外连接来抓取关联实体，该属性只能是tue、false和auto三个值之一，其中true表示启用，false表示不启用，auto表示由程序来决定；
- fetch：该属性指定Hibernate的抓取策略，该属性值只能是join（使用外连接抓取）和select（使用选择抓取）两个值的其中之一；
- lazy：指定Hibernate是否需要启动延迟加载来加载关联实体；
- unique：指定本持久化实体是否增加唯一约束，默认是false；
- where：该属性指定一个SQL表达式，指定当查询、获取关联实体时的过滤条件，只有满足该where条件的关联实体才会被加载；
- order-by：该属性用于设置数据库对集合元素排序，该属性仅对1.4或更高版本的JDK有效。该属性的值为指定表的指定字段（一个或几个）加上asc或者desc关键字，这种排序是数据库执行SQL查询时进行的排序，而不是直接在内存中排序；
- property-ref：指定关联类的一个属性，这个属性将会和本类的外键相对应（当外键参照唯一键时需指定该属性）。如果没有指定，直按使用对方关联类的主键。

实例映射文件如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- 映射Person持久化类-->
	<class name="Person" table="person_inf">
		<!-- 映射标识属性id -->
		<id name="id" column="person_id">
			<!-- 定义主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- 映射集合属性，集合元素是其他持久化实体
			指定连接表的表名-->
		<set name="addresses" table="person_address">
			<!-- 指定连接表中参照本表记录的外键列名 -->
			<key column="person_id" />
			<!-- 使用many-to-many来映射1－N关联，
				增加unique="true" -->
			<many-to-many class="Address" column="address_id" unique="true"/>
		</set>
	</class>
</hibernate-mapping>
```

当程序需要保存一个Person 对象、两个Address对象，并建立该Person对象和这两个Address 对象的关联关系时，程序依然需要5条SQL语句，只是这5条SQL语句都是insert语句——其中两条用于向连接表插入记录，从而建立PersonAddress之间的关联关系。

### 双向N-N关联

双向N-N关联需要两端都使用Set集合属性，两端都增加对集合属性的访问。双向N-N关联没有太多选择，只能采用连接表来建立两个实体之间的关联关系。

```java
public class Person {
	//标识属性
	private Integer id;
	//Person的name属性
	private String name;
	//保留Person的age属性
	private int age;

	//1－N关联关系，使用Set来保存关联实体
	private Set<Address> addresses = new HashSet<Address>();

	//省略id、name和age属性的setter和getter方法
	... 
	//addresses属性的setter和getter方法
	public void setAddresses(Set<Address> addresses) {
		this.addresses = addresses;
	}
	public Set<Address> getAddresses() {
		return this.addresses;
	}
}
```

```java
public class Address {
	//标识属性
	private int addressId;
	//地址详细信息
	private String addressDetail;
	//记录关联实体的person属性
	private Set<Person> persons = new HashSet<Person>();

	//无参数的构造器
	public Address() {
	}
	//初始化全部属性的构造器
	public Address(String addressDetail) {
		this.addressDetail = addressDetail;
	}

	//省略addressId、addressDetail属性的setter和getter方法
	...
      
	//persons属性的setter和getter方法
	public void setPersons(Set<Person> persons) {
		this.persons = persons;
	}
	public Set<Person> getPersons() {
		return this.persons;
	}
}
```

双向N-N关联的持久化类需要在两边都增加`<set.../>`元素，用于映射集合属性`<set.../>`属性，还应该增加`<key.../>`子元素用以映射外键列，`<set.../>`元素里增加`<many-to-many.../>`子元素来映射关联实体类。对应的映射文件如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- 映射Person持久化类-->
	<class name="Person" table="person_inf">
		<!-- 映射标识属性id -->
		<id name="id" column="person_id">
			<!-- 定义主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- 映射N-N关联实体，两边的table属性值要相同 -->
		<set name="addresses" table="person_address">
			<!-- 指定关联的外键列 -->
			<key column="person_id"/>
			<!-- 用以映射到关联类属性 -->
			<many-to-many class="Address" column="address_id"/>
		</set>
	</class>
</hibernate-mapping>
```

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- Address持久化类-->
	<class name="Address" table="address_inf">
		<!-- 映射标识属性addressId -->
		<id name="addressId" column="address_id">
			<!-- 指定主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 映射普通属性addressdetail -->
		<property name="addressDetail"/>
		<!-- 映射N-N关联实体，两边的table属性值要相同 -->
		<set name="persons" table="person_address">
			<!-- 指定关联的外键列 -->
			<key column="address_id"/>
			<!-- 用以映射到关联类属性 -->
			<many-to-many class="Address" column="person_id"/>
		</set>
	</class>
</hibernate-mapping>
```

双向多对多关联的两边都需指定连接表的表名、外键列的列名。所以两个`<set.../>`元素的table属性的值必须指定，而且必须相同。`<set.../>`元素的两个子元素：`<key.../>`和`<many-to-many.../>`都必须指定column属性，`<key.../>`和`<many-to-many.../>`分另是指定本持久化类、关联类在连接表中的外键列名，因此两边的`<key.../>`与`<many-to-many.../>`的column属性交叉相同，也就是说，一边的`<set.../>`元素的`<key.../>`的colomn 值为a，`<many-to-many.../>`的column为b，则另一边的`<set.../>`元素的`<key.../>`的column值为b，`<many-to-many.../>`的column值为a。

### 双向1-1关联

双向1-1关联需要两边的持久化类都增加引用关联实体类型的属性，并为该属性提供setter和getter方法。与单向1-1关联类似的是，双向1-1关联也有三种映射策略：基于主键、基于外键、使用连接表。下面分别介绍这三种映射策略。

#### 基于外键的双向1-1关联

对于基于外键的1-1关联，外键可以存放在任意一端。存放外键的一端需要增加`<many-to-one.../>`元素，正如前面介绍的，为`<many-to-one.../>`元素增加`unique="true"`属性来表示该实体实际上是1的一端。另一端需要使用`<one-to-one.../>`元素，该`<one-to-one.../>`元素需要使用name属性指定关联属性名。为了让系统不再本表增加一列，而是使用外键关联，使用property-ref属性指定引用关联类的属性。

对于1-1的关联关系，两个实体原本处于平等状态；但当我们选择任意一个表来增加外键后（增加`<many-to-one.../>`元素的实体端），该表就变成了从表，而另一个从表则成为了主表。

实例映射文件如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- 映射Person持久化类-->
	<class name="Person" table="person_inf">
		<!-- 映射标识属性id -->
		<id name="id" column="person_id">
			<!-- 定义主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- one-to-one元素映射关联属性，外键列在对方的表内，property-ref指定引用关联类的属性。
			即：在address属性所属的Address类内，必须有person属性的setter和getter方法 -->
		<one-to-one name="address" property-ref="person"/>
	</class>
</hibernate-mapping>
```

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- Address持久化类-->
	<class name="Address" table="address_inf">
		<!-- 映射标识属性addressId -->
		<id name="addressId" column="address_id">
			<!-- 指定主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 映射普通属性addressdetail -->
		<property name="addressDetail"/>
		<!-- 使用many-to-one映射1－1关联实体，unique="true"确定为1－1-->
		<many-to-one name="person" unique="true" column="person_id" not-null="true"/>
	</class>
</hibernate-mapping>
```

> 注意：上面的映射策略是可以互换的。即Person实体端使用`<many-to-one.../>`，而Address实体端使用`<one-to-one.../>`。

#### 基于主键的双向1-1关联

采用基于主键的双向1-1关联需要有一端的主键生成器需要使用foreign策略，表明该实体将根据关联一方的主键来生成自己的主键，该实体不能拥有自己的主键生成策略。当然，任意一端都可以采用foreign主键生成器策略，表明将根据对方主键来生成自己的主键。使用foreign主键生成策略的实体将不能主动指定主键，必须由关联实体的主键来生成自己的主键值。
示例的映射文件如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- 映射Person持久化类-->
	<class name="Person" table="person_inf">
		<!-- 映射标识属性id -->
		<id name="id" column="person_id">
			<!-- 定义主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- 用于映射关联实体 -->
		<one-to-one name="address"/>
	</class>
</hibernate-mapping>
```

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- Address持久化类-->
	<class name="Address" table="address_inf">
		<!-- 映射标识属性addressId -->
		<id name="addressId" column="address_id">
			<!-- 指定foreign主键生成器策略-->
			<generator class="foreign">
				<!-- 指定该主键值将根据person属性引用的关联实体的主键来生成-->
				<param name="property">person</param>
			</generator>
		</id>
		<!-- 映射普通属性addressdetail -->
		<property name="addressDetail"/>
		<!-- 用于映射关联实体 -->
		<one-to-one name="person"/>
	</class>
</hibernate-mapping>
```

#### 有连接表的双向1-1关联

采用连接表的双向1-1关联是相当罕见的情形，映射相当复杂，数据模型烦琐。通常不推荐使用这种策略。

双向1-1关联两端都需要使用`<join.../>`元素显式指定连接表，`<join.../>`元素的table属性用于指定连接表的表名，因此两端的`<join.../>`元素的table属性值应该相同。两端都增加key元素映射连接表中的外键列，还需增加`<many-to-one.../>`元素映射关联属性，两个`<many-to-one.../>`元素都应该增加`unique="true"`属性表明为1-1关联。不仅如此，为了让Hibernate在连接表的两个数据列上增加唯一约束，映射文件应该为两个`<key.../>`子元素指定`unique="true"`。

当使用连接表来建立1-1关联关系时，两个实体的地位绝对平等，不存在任何主从约束关系。Hiberate映射它们的连接表时，将会选择某一外键列作为连接表的主键。两个持久化类的映射关系声明依然不是完全相同的。映射文件必须在其中一端的`<join.../>`元素中指定`inverse="true"`，而另一端指定`optional-"true"`。

示例的映射文件如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- 映射Person持久化类-->
	<class name="Person" table="person_inf">
		<!-- 映射标识属性id -->
		<id name="id" column="person_id">
			<!-- 定义主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- 使用join元素强制使用连接表 -->
		<join table="person_address" inverse="true">
			<!-- 映射连接表中参照本实体主键的外键列 -->
			<key column="person_id" unique="true"/>
			<!-- 映射1－1关联实体 -->
			<many-to-one name="address" class="Address" column="address_id" unique="true"/>
		</join>
	</class>
</hibernate-mapping>
```

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- Address持久化类-->
	<class name="Address" table="address_inf">
		<!-- 映射标识属性addressId -->
		<id name="addressId" column="address_id">
			<!-- 指定主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 映射普通属性addressdetail -->
		<property name="addressDetail"/>
		<!-- 使用join元素强制使用连接表 -->
		<join table="person_address" optional="true">
			<!-- 映射连接表中参照本实体主键的外键列 -->
			<key column="address_id" unique="true"/>
			<!-- 映射1－1关联实体 -->
			<many-to-one name="person" class="Person" column="person_id" unique="true"/>
		</join>
	</class>
</hibernate-mapping>
```

带连接表的双向1-1关联，两端都需指定连接表的表名、外健列的列名。两个集合元素，如`<join.../>`的table属性的值必须指定，而且要相同。`<join.../>`元素的两个子元素：`<key.../>`和`<many-to-one.../>`都必须指定column属性，`<key.../>`和`<many-to-one.../>`分别是指定本持久化类、关联类在连接表中的外键列名，因此两边的`<key.../>`与`<many-to-one.../>`的column属性交叉相同，也就是说，一端的`<join.../>`元素的`<key.../>`的colomn值为a，`<many-to-one.../>`的column为b，则另一端的`<join.../>`元素的`<key.../>`的column值为b，`<many-to-one.../>`的column值为a。

### 组件属性包含的关联实体

前面已经提到过，组件里的属性不仅可以是基本类型、字符串、日期型等，也可以是值类型行为的组件，甚至可以是关联实体。看如下Person持久化类代码：

```java
public class Person {
	//标识属性
	private Integer id;
	//Person的name属性
	private String name;
	//保留Person的age属性
	private int age;
	//定义一个组件属性
	private Address address;

	//id、name、age属性的setter和getter方法
	...
	//address属性的setter和getter方法
	public void setAddress(Address address) {
		this.address = address;
	}
	public Address getAddress() {
		return this.address;
	}
}
```

该Person类有一个Address类型的属性，从持久化类代码看不出该Address是关联实体，还是普通组件属性。但如果我们不将Address映射成持久化实体，那么Address将变成组件属性；如果将Address映射成持久化实体，那就是关联实体了。
Address类里不仅包含了普通属性，还包含了一个Set属性，该Set集合里的元素是School实体。看如下Person持久化类代码：

````java
public class Address {
	//标识属性
	private int addressId;
	//地址详细信息
	private String addressDetail;
	//定义引用包含实体的属性
	private Person person;
	//定义保留关联实体的Set
	private Set<School> schools = new HashSet<School>();
	
	//无参数的构造器
	public Address() {
	}
	//初始化addressDetail属性的构造器
	public Address(String addressDetail) {
		this.addressDetail = addressDetail;
	}
	
	//addressId、person、addressDetail属性的setter和getter方法
	...	
	//schools属性的setter和getter方法
	public void setSchools(Set<School> schools) {
		this.schools = schools;
	}
	public Set<School> getSchools() {
		return this.schools;
	}
}
````

School类处一个简单的持久化类，School类里无法定义访问Address类的关联属性，因为如果想让School类和Address类建立关联，那就要求把Address类也映射成持久化类。因此此处**只是把Address当成组件属性使用，因此School无法和这个并不存在的持久化类建立关联**。

为了映射Person类中的Address组件，映射文件使用`<componen.../>`元素来映射该组件属性，然后在`<component.../>`元素里使用`<set.../>`元素来映射1-N关联实体。Person的映射文件如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<!-- 映射Person持久化类-->
	<class name="Person" table="person_inf">
		<!-- 映射标识属性 -->
		<id name="id" column="person_id">
			<!-- 定义主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 用于映射普通属性 -->
		<property name="name" type="string"/>
		<property name="age" type="int"/>
		<!-- 映射组件元素 -->
		<component name="address" class="Address">
			<!-- 映射组件的person属性指向包含实体 -->
			<parent name="person"/>
			<!-- 映射普通属性 -->
			<property name="addressDetail"/>
			<!-- 映射集合属性，集合元素是其他持久化实体
				没有指定cascade属性 -->
			<set name="schools">
				<!-- 指定关联的外键列 -->
				<key column="address_id"/>
				<!-- 用以映射到关联类属性 -->
				<one-to-many class="School"/>
			</set>
		</component>
	</class>
</hibernate-mapping>
```

因为这里是单向的1-N关联，所以映射文件无法为`<set.../>`指定`inverse="true"`。测试的示例代码如下：

```java
//保存Person和Address对象
private void testPerson(){
	Session session = HibernateUtil.currentSession();
	Transaction tx = session.beginTransaction();
	//创建一个Person对象
	Person p = new Person();
	//设置Person的Name为Yeeku字符串
	p.setName("Yeeku");
	p.setAge(29);
	session.save(p);
	//创建一个Address对象
	Address a = new Address("广州天河");
	//设置Person对象的Address属性
	p.setAddress(a);
	//创建2个School对象
	School s1 = new School("疯狂Java项目冲刺班");
	School s2 = new School("疯狂Java训练营");
	//保存2个School实体
	session.save(s1);
	session.save(s2);
	//设置Address对象和两个School的关联关系
	a.getSchools().add(s1);
	a.getSchools().add(s2);
	tx.commit();
	HibernateUtil.closeSession();
}
```

这种映射策略与前面单向的1-N关联极其相似，程序必须先主动持久化两个School对象，因为School对象没有保留对Address的引用，所以Hibernate插入school_inf记录时只能让其外键为空，这必然导致在设置关联关系时需要使用update语句。

对于上面的映射策略，从逻辑上看应该是Address和School存在1-N关联，但底层数据库将会school_inf表的外键列参照person_inf表的主键，这种主从表的约束关系看上去非常混乱。由此可见，采用这种让组件和持久化实体建立关联的策略的实用价值并不大。

**一般来说，如果需要让持久化实体和组件属性建立关联关系，程序应该将该组件映射成持久化实体，而不是组件属性，这就可以将上面的单向1-N关联改写成双向1-N关联，从而提供较好的性能**。

### 基于复合主键的关联关系

类似的，Hibernate还支持让复合主键（以组件实体充当复合主键）和持久化实体建立关联关系，这种策略也是比较怪异的。实际项目并不推荐使用复合主键，建议采用没有物理意义的逻辑主键。

复合主键的做法不仅会增加数据库建模的难度，而且增加关联关系的维护成本。但在某些特殊的情形下，或者由于某些人的特殊习惯，总有可能需要面对基于复合主键的关联，Hibernate也为这种特殊的关联提供了支持。

下面将以1-N双向关联为例来介绍基于复合主键的关联，先看如下实体类。

```java
public class Person mplements java.io.Serializable 
	//定义first属性，作为标识属性的成员
	private String first;
	//定义last属性，作为标识属性的成员
	private String last;
	//普通属性age
	private int age;
	//记录关联实体
	private Set<Address> addresses = new HashSet<Address>();
	
	//省略rst、last、age属性的setter和getter方法
	...
	//addresses属性的setter和getter方法
	public void setAddresses(Set<Address> addresses){
		this.addresses = addresses;
	}
	public Set<Address> getAddresses() {
		return this.addresses;
	}

	//重写equals方法，根据first、last进行判断
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj != null && obj.getClass() == Person.class) {
			Person target = (Person)obj;
			if (target.getFirst().equals(getFirst()) && target.getLast().equals(getLast())) {
				return true;
			}
		}
		return false;
	}

	//重写hashCode方法，根据first、last计算hashCode值
	public int hashCode() {
		return getFirst().hashCode() * 13 + getLast().hashCode();
	}
}
```

上面的Penon类中firstt、last两个属性将作为标识属性的成员，因此上面的Person类需要实现java.io.Serializable接口。不仅如此，上面的Person类还重写了equals()和hashCode()两个方法。Person类和Address类之间存在1-N双向关联。所以该Person类使了`Set<Address>`来记录该Person更所关联的全Address实体。

```java
public class Address {
	//标识属性
	private int addressId;
	//地址详细信息
	private String addressDetail;
	//记录关联实体的person属性
	private Person person;

	//无参数的构造器
	public Address() {
	}
	//初始化全部属性的构造器
	public Address(String addressDetail) {
		this.addressDetail = addressDetail;
	}

	//addressId、addressDetail属性的setter和getter方法
	...
	
	public void setPerson(Person person) {
		this.person = person;
	}
	public Person getPerson() {
		return this.person;
	}
}
```

映射单独的Person类不算太难，只要使用`<composite-id.../>`元素映射复合主键即可。但现在Person类和Address类之间存在双向的1-N关联，因此需要在Person类的映射文件中增加`<set.../>`元素来映射关联实体，`<set.../>`元素里的`<key.../>`元素映射外键列。注意，此时需要在address_inf表中定义两个外键列，因此不能通过直接在`<key.../>`元素里指定column属性来映射外键列（这样只能映射一列），而是应该在`<key.../>`子元素再添加两个`<column.../>`子元素来映射外键列。如以下映射文件所示：

```xml
<?xml version="1.0" encoding="GBK"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="org.crazyit.app.domain">
	<class name="Person" table="person_inf">
		<!-- 直接使用composite-id映射多列联合主键 -->
		<composite-id>
			<!-- 映射组件主键里的各属性 -->
			<key-property name="first" type="string"/>
			<key-property name="last" type="string"/>
		</composite-id>
		<!-- 映射普通属性 -->
		<property name="age" type="int"/>
		<!-- 映射关联实体 -->
		<set name="addresses" inverse="true"
			cascade="all">
			<key>
				<!-- 映射两个外键列 -->
				<column name="first"/>
				<column name="last"/>
			</key>
			<one-to-many class="Address"/>
		</set>
	</class>
</hibernate-mapping>
```

与此类似的是，Address实体的映射文件中也不能直接在`<many-to-one.../>`元素中增加column属性来映射外键列（这样只能映射一个外键列），而是应该在`<many-to-one.../>`元素中增加多个column子元素来映射外键列。如以下映射文件所示：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="org.crazyit.app.domain">
	<!-- Address持久化类-->
	<class name="Address" table="address_inf">
		<!-- 映射标识属性addressId -->
		<id name="addressId" column="address_id">
			<!-- 指定主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 映射普通属性addressdetail -->
		<property name="addressDetail"/>
		<!-- 映射关联实体 -->
		<many-to-one name="person" class="Person"
			not-null="true">
			<!-- 映射外键列 -->
			<column name="first"/>
			<column name="last"/>
		</many-to-one>
	</class>
</hibernate-mapping>
```

通让使用上面的映射文件，就可以在address_inf中增加两个外健列first、last，这两列正好多照主表person_inf的first、last主键列。

### 复合主键的类属性为关联实体

使用复合主键并没有带来什么特别大的好处，而且会给编程、数据库维护带额外的麻烦。下面介绍的也是复合主键，不过这里复合主键的成员是关联实体。

复合主键的成员是关联实体的示例看上去比较特殊，但在实际项目中却很受欢迎，例如我们开发一个进销管理系统，该系统涉及订单、商品、订单项三个实体，其中一个订单可以包含多个订单项，一个订单项用于订购某个商品，以及订购数量，一个商品可以多次出现在不同订单项中。

有些程序员（尤其是早期那些从PB、Delphi 转型过来的）不为订单项定义额外的逻辑主键，而是使用订单主键、商品主键、订货数量作为复合主键，这就比较特殊、需要做一些特殊的映射了。

下面是订单类的示例代码：

```java
public class Order {	
	//标识属性
	private Integer orderId;
	//订单日期
	private Date orderDate;
	//关联的的订单项
	private Set<OrderItem> items = new HashSet<OrderItem>();

	//无参数的构造器
	public Order() {
	}
	//初始化全部属性的构造器
	public Order(Date orderDate) {
		this.orderDate = orderDate;
	}

	//省略orderId、orderDate和items属性的setter和getter方法
	...
}
```

下面是商品类的示例代码：

```java
public class Product {
	//标识属性
	private Integer productId;
	//产品名
	private String name;
	
	//无参数的构造器
	public Product() {
	}
	//初始化全部属性的构造器
	public Product(String name) {
		this.name = name;
	}

	//省略productId和name属性的setter和getter方法
	...
}
```

Product和Ordertem之间只是单向的关联，Orderltem可以访问该订单项所订购的商品，但商品并不需要知道它出现在哪些订单项中了，因此Product 实体类没有什么特别的地方。

下面是订单项的示例代码：

```java
public class OrderItem implements java.io.Serializable {
	//下面3个属性将作为联合主键
	//定义关联的Order实体
	private Order order;
	//定义关联的Product实体
	private Product product;
	//该订单项订购的产品数量
	private int count;

	//无参数的构造器
	public OrderItem() {
	}
	//初始化全部属性的构造器
	public OrderItem(Order order , Product product , int count) {
		this.order = order;
		this.product = product;
		this.count = count;
	}

	//省略order、product和count属性的setter和getter方法
	...
}
```

上面的Orderltem实体将使用三个属性作为复合属性，而且其中两个属性引用关联实体。为了映射上面的Product实体，需要使用`<composite-id.../>` 元素来映射复合主键，但`<composite-id.../>`里不能使用`<key-property.../>`来映射order、product属性，因为它们并不是普通的标量属性，而是关联实体。

当复合主键的成员是关联实体时，使用`<key-many-to-one.../>`进行映射，该元素可以像`<many-to-one.../>`元素一样指定name、class、column、lazy、access等常用属性，两者的用法大致类似，而且它们都用于映射N-1关联中N的端，只是`<key-many-to-one.../>`映射的属性还作为复合主键的成员。

下面是Orderltem持久化类的映射文件。

```xml
<?xml version="1.0" encoding="GBK"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.rosydawn.model">
	<class name="OrderItem" table="order_item_inf">
		<!-- 映射复合主键 -->
		<composite-id>
			<key-many-to-one name="product" class="Product" column="product_id" />
			<key-many-to-one name="order" class="Order" column="order_id" />
			<key-property name="count" type="int"/>
		</composite-id>
	</class>
</hibernate-mapping>
```

运行上面的程序，order_item_inf表中会以product_id、order_id和count列为联合主键。

### 持久化的传播性

当程序中有两个关联实体时，程序需要主动保存、删除或重关联每个持久化实体；如果需要处理许多彼此关联的实体，则需要依次保存每个实体，这会让人感觉有点烦琐。

从数据库建模的角度来看，两个表之间的1-N关联关系总是用外键约束来表示，其中保留外键的数据表被称为从表，被从表参照的数据表被称为主表。对于这种主从表约束关系，Hibemate则有两种映射策略：

- **将从表记录映射成持久化类的组件**，这就是前面所介绍的集合属性的集合元素是组件。如果我们将从表记录映射成持久化类的组件，这些组件的生命周期总是依赖于父对象，Hibemate会默认启用的级联操作，不需要额外的动作。当父对象被保存时，这些组件子对象也将被保存，父对象被删除时，子对象也将被删除；
- **将从表记录映射成的持久化实体**。如果将从表记录映射成持久化实体，则从表实体就有了自己的生命周期，从表应该允许其他实体共享对它的引用。例如，从集合中移除一个实体，不意味着它可以被删除。所以Hiberate默认不启用实体到其他关联实体之间的级联操作。

对于关联实体而言，Hibermate默认不会启用级联操作，当父对象被保在时，它关联的实体不会被保存，父对象被删除时，它关联的子实体不会被删除。为了启用不同持久化操作的的级联行为，Hibernate定义例如如级联风格：persist、merge、save-update、delete、lock、refresh、evict、replicate，这些级联风格分别对于Hibernate Session的持久化操作，如persist()、merge()、saveOrUpdate()、delete()、lock()、refresh()、evict()、replicate()。

如果程序希望某个操作能被级联传播到关联实体，则可以在配置关联映射时通过`cascade`属性来指定。例如：

```xml
<!-- 指定perssst()操作级联到关联实体-->
<one-to-one name-"person" cascade="persist"/>
```

**级联风格是可组合的**，如下面配置所示：

```xml
<!-- 指定persist()、delete()和lock()操作关联到关联实体-->
<one-to-one nane-"person" cascade-"persist, delete, lock"/>
```

可以使用`cascade="all"`来指定所有操作都被级联到关联实体。Hibernate对关联实体默认的级联策略是`cascade="none"`，即任何操作都不会被级联到关联实体。

Hibernate有个特殊的级联策略：delete-orphan（删除孤儿），该级联策略只对`<one-to-many.../>`关联有效，表明delete()操作将被级联到所有从关联中删除的对象。

对于级联策略的设定，Hibernate有如下建议：

- `<many-to-one.../>`或`<many-to-many.../>`关系中指定级联没什么意义。级联通常在`<one-to-one.../>`和`<one-to-many.../>`关系中比较有用，因为级联操作应该是由主表记录传播到从表记录，而从表记录则不应该传播到主表记录；
- 如果从表记录完全限制在主表记录之内（当主表记录被删除后，从表记录没有存在的意义），则可以指定`cascade="all, delete-orphan"`级联策略，将从表实体的生命周期完全交给主表实体管理；
- 如果经常在某个事务中同时使用主表实体和从表实体，则可以考患指定`cascade="create, merge, save-update"`级联策略。

对于`cascade="all"`级联策略的详细：

- 如果主表实体被persist()，那么所有从表实体也会被persist()；
- 如果主表实体被merge()，那么所有从表实体也会被merge()；
- 如果主表实体被save()、update()或saveOrUpdate()，那么所有从表实体则会被saveOrUpdate()；
- 如果把持久化状态下的主表实体和瞬态或脱管的从表实体建立关联，则从表实体将被自动持久化；
- 如果主表实体被删除，那么所有从表实体也会被删除；
- 如果没有把主表实体删除，只是切断主表实体和从表实体之间的关联关系，则从表实体不会被删除。如果指定`cascade="delete-orphan"`策略，则只要一个从表实体失去关联的主表实体，不管是删除了其关联的主表实体，还是切断了与其主表实体的关联，那么该从表实体都会变成orphan（孤儿），系统将自动删除该从表实体。

所有操作都是在调用期（call time）或者写入期（flush time）中级联到关联对象上的。如果可能，Hibernate都会在操作被执行时级联到关联实体上。然而，save-update和delete-orphan操作是在Session flush时才级联到关联对象上的。

### 继承映射

Hibernate的继承映射可以理解为持久化类之间的继承关系。

看下面Person类的示例代码：

```java
public class Person {
	//标识属性
	private Integer id;
	//定义该Person实体的名字属性
	private String name;
	//定义该Person实体的性别属性
	private char gender;
	//定义该Person实体的组件属性：address
	private Address address;
	
	//省略id、name、gender和address属性的setter和getter方法
	....
}
```

上面的Person类有一个Address类型的属性。Address类的示例代码如下：

```java
public class Address {
	//定义该Address的详细信息
	private String detail;
	//定义该Address的邮编信息
	private String zip;
	//定义该Address的国家信息
	private String country;	//无参数的构造器
  
	public Address() {
	}
	//初始化全部属性的构造器
	public Address(String detail , String zip , String country) {
		this.detail = detail;
		this.zip = zip;
		this.country = country;
	}
	
	//省略detail、zip和country属性的setter和getter方法
	...
}
```

除此之外，Person类还有两个子类：Customer和Employee，而Employee又有一个Manager子类，而且它们之间还存在关联关系。这种映射关系就比较复杂了。

```java
//顾客类继承了Person类
public class Customer extends Person {
	//顾客的评论信息
	private String comments;
	//和员工保持关联关系的属性
	private Employee employee;
	//无参数的构造器
	public Customer() {
	}
  
	//初始化comments属性的构造器
	public Customer(String comments) {
		this.comments = comments;
	}
	
	//省略comments和employee属性的setter和getter方法
	...
}
```

```java
//员工类继承了Person类
public class Employee extends Person {
	//定义该员工的职位属性
	private String title;
	//定义该员工的工资属性
	private double salary;
	//和顾客保持关联关系的属性
	private Set<Customer> customers = new HashSet<Customer>();
	//和经理保持关联关系的属性
	private Manager manager;
	
	//无参数的构造器
	public Employee() {
	}
	//初始化全部属性的构造器
	public Employee(String title , double salary) {
		this.title = title;
		this.salary = salary;
	}
	
	//省略title、salary、customers和manager属性的setter和getter方法
	...
}
```

#### 采用subclass元素的继承映射

如果使用subclass元素进行继承映射，整个继承树的所有实例都将保存在同一个表内，即对于如上的Person、Employee、Customer和Manager实例都将保存在同一个表内。因为将父、子类的实例全部保存在同一个表内，因此，需要在该表中额外增加一个辨别者列（discriminator），使用该列来区分每行记录到底是哪个类的实例。

在这种映射策略下，使用`<subclass.../>`来映射子持久化类，使用`discriminator`元素来映射辨别者列。
除此之外，每个类映射中都需要指定辨别者列的值。

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的映射文件的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="org.crazyit.app.domain">
	<!-- 映射Person类 -->
	<class name="Person" table="person_inf" discriminator-value="普通人">
		<!-- 映射标识属性 -->
		<id name="id" column="person_id">
			<!-- 使用identity的主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 映射辨别者列 -->
		<discriminator column="desc_column" type="string"/>
		<!-- 如下映射两个基本属性 -->
		<property name="name" length="80"/>
		<property name="gender"/>
	   	<!-- 下面映射了一个组件属性 -->
		<component name="address">
			<!-- 映射组件属性的三个成员属性 -->
			<property name="detail"/>
			<property name="zip"/>
			<property name="country"/>
		</component>
		<!-- 使用subclass元素映射Person类的子类Employee -->
		<subclass name="Employee" discriminator-value="雇员">
			<!-- 映射两个基本属性 -->
			<property name="title" />
			<property name="salary" />
			<!-- 映射N－1的关联映射 -->
			<many-to-one name="manager" column="manager_id"/>
			<!-- 映射与Customer类之间的1－N关联 -->
			<set name="customers" inverse="true">
				<key column="empoyee_id"/>
				<one-to-many class="Customer"/>
			</set>
			<!-- 使用subclass元素映射Employee类的子类Manager -->
			<subclass name="Manager" discriminator-value="经理">
				<!-- 映射Manager类的基本属性department -->
				<property name="department"/>
				<!-- 映射Manager类的关联实体：Employee -->
				<set name="employees" inverse="true">
					<key column="manager_id"/>
					<one-to-many class="Employee"/>
				</set>
			</subclass>
		</subclass>
		<!-- 使用subclass映射Person的Customer子类 -->
		<subclass name="Customer" discriminator-value="顾客">
			<!-- 映射Customer类的comments属性 -->
			<property name="comments"/>
			<!-- 映射Customer和Employee的关联关系 -->
			<many-to-one name="employee" column="empoyee_id"/>
		</subclass>
	</class>
</hibernate-mapping>
```

每个子持久化类不再使用`<class.../>`元素进行映射，而是改为使用`<subclass.../>`元素进行映射。实际上，`<subclass.../>`元素和`<class.../>`元素的配置几乎一样，只是`<subclass.../>`元素用于映射子持久化类，而`<class.../>`元素用于映射普通持久化类。

`<subclass.../>`元素比`<class.../>`元素多了一个extends属性，该属性指定该持久化类的父类（必须是持久化类），当把`<subclass.../>`作为`<class.../>`元素或者`<subclass.../>`元素的子元素来使用时，无须指定属性，Hibernate将自动把该`<subclass.../>`的父`<class.../>`元素或者父`<subclass.../>`元素所映射的持久化类当成父类。但当映射文件把`<subclass.../>`当成`<hibernate-mapping.../>`元素的子元素使用时，必须指定extends属性。类似的，后面介绍的`<joined-subclass.../>`元素和`<union-subclass.../>`元素也有相同的extends属性，其用法与此处的extends用法完全一样。

在上面的映射文件中，指定了一个列名为`desc_column`的辨别者列，该列的值没有实际意义，仅用于区分每条记录对应哪个持久化类。其中Person类实例的`desc_column`列的值为普通人，Employee实例的`desc_column`列的值为雇员，Manager实例的`desc_column`列的值为经理，Customer实例的`desc_column`列的值为顾客。

使用`<subclass.../>`元素进行继承映射会有一些劣势：实际数据表中会存在很多NULL值（因为父类记录在子类记录对应的数据列中并没有数据），且所有子类定义的字段，不能有非空约束。如果为这些字段增加非空约束，那么父类的实例在这些列根本没有值，会导致父类的实例无法保存到数据库。但这种映射策略也有一个非常大的好处：在这种映射策略下，整棵继承树的所有数据都保存在一张表内，所有的查询都只需在一张表中进行即可，无须进行多表连接查询，也无须进行union查询，因此性能比较好。

#### 采用joined-subclass元素的继承映射

采用`<joined-subclass.../>`元素进行继承映射时，父类实例保存在父类表里，而子类实例则由父类表和子类表共同存储。因为子类实例也是一个特殊的父类实例，因此必然也包含了父类实例的属性，于是将**子类与父类共有的属性保存在父类表中，而子类增加的属性则保存在子类表中**。

在这种映射策略下，无须使用辨别者列，但需要为每个子类使用`<key.../>`元素映射共有主键，这个主键列还将参照父类表的主键列。**使用`<joined-subclass.../>`元素继承映射策略时，必须使用`	<key.../>`元素映射父子类的共有主键，`<key.../>`元素映射的数据列既是主键列，也是外键列，这些共有的主键列的列名无需相同**。

示例代码如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的映射文件的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="org.crazyit.app.domain">
	<!-- 映射Person类 -->	
	<class name="Person" table="person_inf">
		<!-- 映射标识属性 -->
		<id name="id" column="person_id">
			<!-- 使用identity的主键生成器策略 -->
			<generator class="identity"/>
		</id>
		<!-- 如下映射两个基本属性 -->
		<property name="name" length="80"/>
		<property name="gender"/>
		<!-- 下面映射了一个组件属性 -->
		<component name="address">
			<!-- 映射组件属性的三个成员属性 -->
			<property name="detail"/>
			<property name="zip"/>
			<property name="country"/>
		</component>
		<!-- 使用joined-subclass元素映射Person类的Employee子类 -->
		<joined-subclass name="Employee" table="employee_inf">
			<!-- 必须使用key元素映射父子类的共有主键 -->
			<key column="employee_id"/>
			<!-- 映射Employee类的两个普通属性 -->
			<property name="title" not-null="true"/>
			<property name="salary" not-null="true"/>
			<!-- 映射Employee类与Manager类之间的N－1关联-->
			<many-to-one name="manager" column="manager_id"/>
			<!-- 映射Employee类与Customer类之间的1－N关联-->
			<set name="customers" inverse="true">
				<key column="empoyee_id"/>
				<one-to-many class="Customer"/>
			</set>
			<!-- 使用joined-subclass元素映射Employee类的Manager子类 -->
			<joined-subclass name="Manager" table="manager_inf">
				<!-- 必须使用key元素映射父子类的共有主键 -->
				<key column="manager_id"/>
				<!-- 映射Manager类的department属性 -->
				<property name="department"/>
				<!-- 映射Employee类与Manager类之间的1－N关联-->
				<set name="employees" inverse="true">
					<key column="manager_id"/>
					<one-to-many class="Employee"/>
				</set>
			</joined-subclass>
		</joined-subclass>
		<!-- 使用joined-subclass元素映射Person类的Customer子类 -->
		<joined-subclass name="Customer" table="customer_inf">
			<!-- 必须使用key元素映射父子类的共有主键 -->
			<key column="customer_id"/>
			<property name="comments" not-null="true"/>
			<!-- 映射Employee类与Customer类之间的1－N关联-->
			<many-to-one name="employee" column="empoyee_id"
				not-null="true"/>
		</joined-subclass>
	</class>
</hibernate-mapping>
```

不仅Person的实例保存在person_inf表中，Employee、Manager和Customer的实例也保存在person_inf 表中，但仅仅保存它们作为Person实例的属性。而作为子类的属性则保存在各自的表中。employee_inf表里不仅保存了Employee实体的信息，所有Manager实体的信息也保存在该数据表中。

三个表中都有person_id、employee_id和customer_id 列，这就是它们作为父子类的共有主键，Hibernate正是通过相同的主键值来查询一个子类实例的数据的。例如，需要查询一个id为5的顾客，Hibernate将从person表中查询出id为5的数据，并查询出customer_inf表中id为5的记录，将两条记录拼接成一个实例，这种拼接是通过一个join SQL语句来完成的，所以这种映射策略称为joined-subclass。

采用joined-subclass映射策略时，只要使用无须使用辨别者列，子类增加的属性也可以拥有非空约束，是种比较理想的映射策略。只是在查询子类实例的数据时，可能需要跨越多个表来查询（跨越表的数量取决于该子类有多少层父类），所以性能略有影响。

#### 采用union-subclass元素的继承映射

**采用union-subclass元素的继承映射时，父类实例的数据仅保存在父表中，子类实例的数据仅保存在子表中**。在这种映射策略下，子类表的字段会比父类表字段要多，因为子类表的字段等于父类属性加子类增加属性的总和，这样既不需要使用辨别者列，也无须使用`<key.../>`元素来映射共有主键。如果单从数据库来看。几乎难以看出它们之间存在的继承关系。

示例代码如下：

```xml
<?xml version="1.0" encoding="GBK"?>
<!-- 指定Hibernate的映射文件的DTD信息 -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="org.crazyit.app.domain">
	<!-- 映射Person类 -->	
	<class name="Person" table="person_inf">
		<!-- 映射标识属性 -->
		<id name="id" column="person_id">
			<!-- 不能使用identity的主键生成器策略，所以使用hilo主键生成器策略-->
			<generator class="hilo"/>
		</id>
		<!-- 如下映射两个基本属性 -->
		<property name="name" length="80"/>
		<property name="gender"/>
		<!-- 下面映射了一个组件属性 -->
		<component name="address">
			<!-- 映射组件属性的三个成员属性 -->
			<property name="detail"/>
			<property name="zip"/>
			<property name="country"/>
		</component>
		<!-- 使用union-subclass元素映射Person类的Employee子类 -->
		<union-subclass name="Employee" table="employee_inf">
			<!-- 映射Employee类的两个普通属性 -->
			<property name="title" not-null="true"/>
			<property name="salary" not-null="true"/>
			<!-- 映射Employee类与Manager类之间的N－1关联-->
			<many-to-one name="manager" column="manager_id"/>
			<!-- 映射Employee类与Customer类之间的1－N关联-->
			<set name="customers" inverse="true">
				<key column="empoyee_id"/>
				<one-to-many class="Customer"/>
			</set>
			<!-- 使用union-subclass元素映射Employee类的Manager子类 -->
			<union-subclass name="Manager" table="manager_inf">
				<!-- 映射Manager类的department属性 -->
				<property name="department"/>
				<!-- 映射Employee类与Manager类之间的1－N关联-->
				<set name="employees" inverse="true">
					<key column="manager_id"/>
					<one-to-many class="Employee"/>
				</set>
			</union-subclass>
		</union-subclass>
		<!-- 使用union-subclass元素映射Person类的Customer子类 -->
		<union-subclass name="Customer" table="customer_inf">
			<property name="comments" not-null="true"/>
			<!-- 映射Employee类与Customer类之间的1－N关联-->
			<many-to-one name="employee" column="empoyee_id"
				not-null="true"/>
		</union-subclass>
	</class>
</hibernate-mapping>
```

使用union-subclass元素的继承映射时，非常简洁易懂，既不需要使用辨别者列，也不需要使用`<key.../>`子元素映射共有主键，只要使用`<union-subclass.../>`元素映射子类即可。这种策略非常方便实用，建议使用这种继承映射策略。

这种方式的局限在于**，如果一个属性在超类中做了映射，其字段名必须与所有子类表中定义的相同**（Hibernate可能在后续发布版本中放宽此限制）。除此之外，**使用union-subclass映射策略不可使用identity主键生成策略，因为同类继承层次中所有实体类必须使用同一个主键生成种子（即多个持久化实体对应的记录的主键是连续的，如果没有删除数据，继承树里所有实例的主键加起来是连续的）。受此影响，也不应该使用native主键生成策略，因为native会根据数据库来选择使用identity或sequence策略**。

采用这种方式进行多态查询时需要跨越多个表进行查询。例如，查询满足某个条件的Person实例，Hibernate将会从person_inf表中查询数据，也会从Person的所有子类对应的表中查询数据，然后对这些结果数据进行union操作，这也是这种映射策略被称为union-subclass的原因。