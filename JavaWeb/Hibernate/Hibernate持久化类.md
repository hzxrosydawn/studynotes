### 持久化类

#### 持久化类规则

Hibernate对持久化类没有太多的强制要求，但我们还是应该遵守如下规则：

- **提供一个无参数的构造器（必须）**。所有的持久化类都应该提供一个无参数的构造器，这个构造器可以不采用public访问控制符。因此提供了无参数的构造器，Hibernate就可以使用Constructor.newinstance()来创建持久化类的实例了。通常，为了方便Hibernate在运行时生成代理，构造器的访问控制修饰符至少是包可见的，即大于或等于默认的访问控制符；
- **提供一个标识属性（identifier property，可选）**。**标识属性通常映射数据库表的主键字段，这个属性可以叫任何名字，其类型可以是任何的基本类型、基本类型的包装类型、java.lang.String或者java.util.Date。如果使用了数据库表的联合主键，甚至可以用一个用户自定义的类，该类拥有这些类型的属性。当然，也可以不指定任何标识属性，而是在映射文件中直接将多个普通属性映射成一个联合主键（composite key），但通常不推荐这么做。虽然Hbernate允许使用8个基本类型作为标识属性的类型，但使用基本类型作为标识属性的类型在很多地方都不大方便，因此还是建议使用基本类型的包装类型作为标识属性的类型**。
- **虽然Hibernate可以允许持久化类没有标识属性，而是让Hibernate内部来追踪对象的识别。但这样做将导致Hibernate的许多功能（如重新获取托管对象、Session.saveOrUpdate()和Session.merge()等）无法使用**。**Hibernate建议使用可以为空的类型来作为标识属性的类型，因此应该尽最避免使基本数据类型**。
- **为持久化类的每个属性提供setter和getter方法（可选）**。Hibernate默认采用属性注入的方式来访问持久化类的属性。如果需要，也可以切换属性的访问策略；
- **使用非final类（可选）**。**在运行时生成代理是Hibernate的一个重要的功能，如果持久化类没有实现任何接口的话，Hibernate使CGLIB生成代理，该代理对象是持久化类子类的实例。如果使用了final类，则无法生成CGLIB代理，将无法进行性能优化。还有一个可选的策略，让Hibernate持久化类实现一个所有方法都声明为publc的接口，此时将使用JDK的动态代理。同时应该避免在非final类中声明public final的方法。如果非要使用一个有public final方法的类，你必须设置`lazy="false"`来明确地禁用代理**；
- **如果需要把持久化类的实例放入Set中（当需要进行关联映射时，推荐这么做），或者需要重新访问托管对象时，应该为该持久化类重写equals()和hashCode()方法**。实现equals()和hashCode()最显而易见的方法是比较两个对象标识符的值。如果值相同，则两个对象对应于数据库的同一行，因此它们是相等的（如果都被添加到Set，则在Set中只有一个元素）。遗憾的是，**对采用自动生成标识值的对象不能使用这种方法。Hibernate仅为那些持久化对象指定标识值，一个新创建的实例将不会有任何标识值。因此，如果一个实例没有被保存过，但它又确实在一个Set中，保存它将会给这个对象赋一个标识值。如果equals()和hashCode()是基于标识值实现的，则其hashCode返回值会发生改变，这将违反Set的规则**。

#### 持久化对象的状态

Hibernate持久化对象支持如下几个对象状态：

- 瞬态（ transient）：对象由new操作符创建，且尚未与Hibernate Session关联的对象被认为处于瞬态。瞬态对象不会被持久化到数据库中，也不会被赋予持久化标识。如果程序中失去了瞬态对象的引用，瞬态对级将被垃圾回收机制销毁。使用Hibernate Session可以将其变为持久化状态；
- 持久化（persistent）：持久化实例在数据库中有对应的记录，并拥有一个持久化标识（identifer）。持久化的也可以是刚刚被保存的，也可以是刚被加载的。无论哪种，持久化对象都必须与指定的Hibernate Session关联，Hibernate会检测到处于持久化状态的实例的改动，在当前操作执行完成时将对象数据写回数据库。开发者不用手动执行Update；
- 脱管（detached）：**某个实例曾经处于持久化状态，但随着与之关联的Session被关闭，该对象就变成脱管状态。脱管对象的引用依然有效，对象可继续被修改。如果重新让脱管对象与某个Session关联，这个脱管对象会重新转换为持久化状态，而脱管期间的改动也不会丢失，也可被写入数据库**。正是因为这个功能，**逻辑上的长事务成为可能，它被称为应用程序事务。即事务可以跨越用户的思考，因为当对象处于脱管状态时，对该对象的操作无须锁定数据库，不会造成性能的下降**。

#### 持久化对象的操作方法

为了让瞬态对象转换为持久化状态，Hibemate Session 提供了如下几个方法：

- Serializable save(Object obj)：将obj对象变为持久化状态，该对象的属性将被保存到数据库；
- void persist(Object obj)：将obj对象转化为持久化状态，该对象的属性将被保存到数据库；
- Serializable save(Object bj，Object pk)：将obj对象保存到数据库，保有到数据库时，指定主键值；
- void persist(Object obj,Object pk)：将obj对象转化为持久化状态，保存到数据库时，指定主键值。

当我们把一个瞬态实体变成持久化状态时，Hibernate会在底层对应地生成一条insert 语句，这条语句负责把该实体对应的数据记录插入数据表。如果持久化类的标识属性是generated （也就是说，指定了主键生成器）类型的，那么Hibernate将会在执行save()方法时自动生成标识属性值，并将该标识属性值分配给该持久化对象，并且标识属性（identifier）会在save()方法被调用时自动产生并分配给持久化对象。如果持久化类的标识属性是assigned类型的，或者是复合主（composite key），那么该标识属性值应当在调用save()方法之前手动赋给持久化对象。

Hibernate之所以提供与save()功能几乎完全类似的persist(方法，一方面是为了照顾JPA 的用法习惯。另一方面，save()和persist()方法还有一个区别：使用save()方法保存持久化对象时，该方法返回该持久化对象的标识属性值（即对应记录的主键值），但使用persist()方法来保存持久化对象时，该方法没有任何返回值。因为save()方法需要立即返回持久化对象的标识属性值，所以程序执行save()方法会立即将持久化对象对应的数据插入数据库，而persist()则保证当它在一个事务外部被调用时，并不立即转换成insert 语句，这个功能是很有用的，尤其当我们封装一个长会话流程的时候，persist()方法就显得尤为重要了。

也可以通过load()来加载一个持久化实例，这种加载就是根据持久化类的标识属性值加载持久化实例，其实质就是根据主键从数据表中加载一条新纪录：

```java
Person person = session.load(Person.class, new Integer(primaryKey);
```

如果没有匹配的数据库记录，load()方法可能抛出HibernateException异常。如果我们在类映射文件中指定了延迟加载，则load()方法会返回一个未初始化的代理对象（可以理解为持久化对象的替身），这个代理对象并没有装载数据记录，直到程序调用该代理对象的某万法时，Hibernate才会去访问数据库。

如果希望在某对象中创建一个指向另一个对象的关联，又不想在从数据库中装载该对象时同时装载相关联的所有对象，这种延迟加载的方式就韭常有用了。

与load()方法类似的是get()方法，get()方法也用于根据主键装载持久化实例，但get()方法会立刻访问数据库，如果没有对应的记录，get()方法返回null，而不是返回一个代理对象。当程序通过load()或get()方法加载实体时，Hibernate会在底层对应地生成一条select语句，这条select语句带有`where <主键列>=<标识属性值>`子句，表明将会根据主键加载。

一旦加载了该持久化实例后，该实体就处于持久化状态，在代码中对持久化实例所做的修改将被保存到数据库。程序对持久化实例所做的修改会在Session flush之前被自动保存到数据库，无须程序调用其他方法（不需要调用update()方法!）来将修改持久化。也就是说，修改对象最简单的方法就是在Session处于打开状态时load()它，然后直接修改即可。

从表面上看，这种做去有个极大的性能缺陷：当我们需要修改某条记录时，这种做法将会产生两条SQL语句，一条用于查询指定记录的select语句，另一条用于修改该记录的update语句。但实际应用中无须考虑这种性能缺陷，对于一个Java EE应用而言，Hibernate通常的处理流程是：从数据库里加载记录→将信息发送到表现层供用户修改→将所做修改重新保存到数据库。这种处理处理流程下，应用本身就需要两条SQL语句。当我们修改脱管对象的状态后，程序应该使用新的Session来保存这些修改。Hibernate提供了update()、merge()和updateOrSave()等方法来保存这此修改。

当我们用另个Session来保在这种修改后，该脱管对象再次回到Session的管理之下也就再次回到持久化状态。当需要使用update()来保存程序对持久化对象所做的修改时，如果不清楚该对象是否曾经持久化过，那么程序可以选择使用updateOrSave()方法，该方法自动判断该对象是否曾经持久化，如果曾经持久就使用update()操作，否则将使用save()操作。

与update()方法类似，merge()方法也可将程序对脱管对象所做的修改保存到数据库，但merge()方法不会持久化给定对象。举例来说，当我们执行session.updatc(a)代码后，a对象将会变成持久化状态，而执行session.merge(a)代码后，a对象依然不是持久化状态，a对象依然不会被关联到Session 上。

当程序使用merge()方法来保存程序对脱管对象所做的修改时，如果Session中存在相同持久化标识（identifier）的持久化对象，merge()方法里提供对象的状态将覆盖原有持久化实例的状态。如果Session中没有相应的持久化实例，则尝试从数据库中加载，或创建新的持久化实例，最后返回该持久化实例。

当我们使用load()或get()方法来加载持久化对象时，还可指定一个“锁模式”参数。Hibernate使用LockMode对象代表“锁模式”。LockMode 提供了READ、UPGRADE两个静态属性来代表共享、修改锁。如果需要加载某个持久化对象以供修改（相当于使用SQL的SELECT..FOR UPDATE）语句来装载对象，则可以使用以下代码：

```java
Person person = session.get(Person.class, new Integer(primaryKey), LockMode.UPGRADE);
```

lock()方法也可以将某个托管对象重新持久化，但该托管对象必须是没有修改过的！如下面的代码所示：

```java
// 简单的重新初始化
session.lock(person, LockMode.NONE);
// 先检查持久化对象的版本，然后重新初始化
session.lock(person, LockMode.READ);
// 先检查持久化对象的版本，然后使用SELECT ... FOR UPDATE重新初始化该对象
session.lock(student, LockMode.PESSIMISTIC_WRITE);
```

> lock()方法可以搭配多种LockMode，可以查看API文档中事务处理相关的内容。重新关联也不止lock()一种方式。

不仅如此，还可以通过Session的delete()方法来删除该持久化实例，一旦删除了该持久化实例，该持久化实例对应的数据记录也将删除。如下面代码所示：

```java
Person person = session.load(Person.class, new Integer(primaryKey);
session.delete(person);
```

这种做法也会生成两条SQL语句，但在实际Java EE应用中没有任何问题，因为Java EE应用需要先选出一条记录，将其输出到表现层，等用户确认利除这条记录时，系统才会真正删除这条记录。

Hibernate本身不提供直接执行update或delete语句的API，Hibernate提供的是一种面向对象的状态管理。如果确实需要直接执行DML风格的update或delete 类似语句，建议使用Hibemate的批处理功能。