## HTTP学习笔记：Web基础

### HTTP协议简介

HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。HTTP基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。它是一种可靠的数据传输协议，能够确保数据在传输的过程中不会被损坏或产生混乱。

### Web资源

#### MIME 类型

MIME类型（Multipurpose Internet Mail Extension，多用途因特网邮件扩展）是一种文本标记，用于标识Web上传输的各种对象。表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。如：

-  text/html：表示HTML文本文档；
-  text/plain：表示普通ASCII文本文档；
-  application/vnd.ms-powerpoint：表示微软的PowerPoint演示文件。

更多的MIIME类型参考[MIME百科](http://baike.baidu.com/link?url=DkM3ZI9jku3BGHYmF9fvaErwIfgHFb4H_23LHtuIBUcu7HHCijlxHsx-XDh1FSskqLPEXIjQ77fgfYqexKRyV_)或[w3schoo的MIME参考手册](http://www.w3school.com.cn/media/media_mimeref.asp)。

#### URI、URL和URN

URI（Uniform Resource Identiﬁer，统一资源标识符）用于在世界范围内唯一标识并定位Web服务器资源，有URL和URN两种形式。

URL（Uniform Resource Locator，统一资源定位符）描述了一台特定服务器上某资源的特定位置，从而定位因特网上任意资源。也就是我们平时说的网址，现在几乎所有的URI都是URL，除非特殊说明，一般URI都是指URL。

大部分URL都会遵循通用的URL语法：

```html
<scheme>://<user>:<password>@<host>:<post>/<path>;<params>?<query>#<frag>
```

不同 URL 方案的风格和语法都有不少重叠。几乎没有哪个URL中包含了所有这些组件。URL 最重要的3个部分是方案（scheme）、主机（host）和路径（path）。通用URL组件如下表所示：

| 组件           | 描述                                       |      默认值      |
| ------------ | ---------------------------------------- | :-----------: |
| 方案（scheme）   | 访问服务器以获取资源时要使用哪种协议                       |       无       |
| 用户（user）     | 某些方案访问资源时需要的用户名                          |      匿名       |
| 密码（password） | 用户名后面可能要包含的密码，中间由冒号（:）分隔                 | \<E-mail 地址 > |
| 主机（host）     | 资源宿主服务器的主机名或点分IP地址                       |       无       |
| 端口（port）     | 资源宿主服务器正在监听的端口号。很多方案都有默认端口号（HTTP 的默认端口号为 80） |    每个方案特有     |
| 路径（path）     | 服务器上资源的本地名，由一个斜杠（/）将其与前面的URL 组件分隔开来。路径组件的语法是与服务器和方案有关的 |       无       |
| 参数（params）   | 某些方案会用这个组件来指定输入参数。参数为名 / 值对。URL 中可以包含多个参数字段，它们相互之间以及与路径的其余部分之间用分号（;）分隔 |       无       |
| 查询（query）    | 某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其他因特网网关）。查询组件的内容没有通用格式。用字符“?”将其与URL的其余部分分隔开来，多个查询条件之间以“&”分隔 |       无       |
| 片段（frag）     | 一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器；这个字段是在客户端内部使用的。通过字符“#”将其与URL的其余部分分隔开来 |       无       |

**方案** ：方案组件指定了访问服务器以获取资源时要使用的哪种协议。方案名必须以一个字母符号开始，由第一个“:”符号将其与 URL 的其余部分分隔开来。方案名是大小写无关的。这部分通常是HTTP协议（http://），也可以是其他协议形式。完整的方案列表如下：

- **http** ：超文本传输协议方案，除了没有用户名和密码之外，与通用的 URL 格式相符。如果省略了端口，就默认为 80。基本格式：http://\<host>:\<port>/\<path>?\<query>#\<frag>。
- **https** ：方案 https 与方案 http 是一对。唯一的区别在于方案 https 使用了网景的 SSL，SSL 为HTTP 连接提供了端到端的加密机制。其语法与 HTTP 的语法相同，默认端口为 443。基本格式：https://\<host>:\<port>/\<path>?\<query>#\<frag>。
- **mailto** ： Mailto URL 指向的是 E-mail 地址。由于 E-mail 的行为与其他方案都有所不同（它并不指向任何可以直接访问的对象），所以 mailto URL 的格式与标准 URL 的格式也有所不同。因特网 E-mail 地址的语法记录在 RFC 822 中。基本格式：mailto:\<RFC-822-addr-spec>，如mailto:joe@joes-hardware.com。
- **ftp** ：**文件传输协议** URL 可以用来从 FTP 服务器上下载或向其上载文件，并获取 FTP 服务器上的目录结构内容的列表。
  在 Web 和 URL 出现之前 FTP 就已经存在了。Web 应用程序将 FTP 作为一种数据访问方案使用。URL 语法遵循下列通用格式。基本格式：ftp://\<user>:\<password>@\<host>:\<port>/\<path>;\<params>，示例：ftp://anonymous:joe%40joes-hardware.com@prep.ai.mit.edu:21/pub/gnu/。
- **rtsp，rtspu** ：RTSP URL 是可以通过**实时流传输协议**（Real Time Streaming Protocol）解析的音 / 视频媒体资源的标识符。方案 rtspu 中的 u 表示它是使用 UDP 协议来获取资源的。基本格式：rtsp://\<user>:\<password>@\<host>:\<port>/\<path>，rtspu://\<user>:\<password>@\<host>:\<port>/\<path>，示例：rtsp://www.joes-hardware.com:554/interview/cto_video。
- **file** ：方案 file 表示一台指定主机（通过本地磁盘、网络文件系统或其他一些文件共享系统）上可直接访问的文件。各字段都遵循通用格式。如果省略了主机名，就默认为正在使用URL 的本地主机。基本格式：file://\<host>/\<path>
  示例：file://OFFICE-FS/policies/casual-fridays.doc。
- **news**  ：根据 RFC 1036 的定义，方案 news 用来访问一些特定的文章或新闻组。它有一个很独特的性质：news URL 自身包含的信息不足以对资源进行定位。news URL 中缺乏到何处获取资源的信息——没有提供主机名或机器名称。从用户那里获取此类信息是解释程序的工作。比如，在网景浏览器的“选项”（Options）菜单中，就可以指定自己的 NNTP（news）服务器。这样，浏览器有了 news URL 的时候就知道应该使用哪个服务器了。新闻资源可以从多台服务器中获得。它们被称为位置无关的，因为对它们的访问不依赖于任何一个源服务器。news URL 中保留了字符“@”，用来区分指向新闻组的 news URL 和指向特定新闻文章的news URL。基本格式：news:\<newsgroup>，news:\<news-article-id>，示例：news:rec.arts.startrek。
- **telnet** ： 方案 telnet 用于访问交互式业务。它表示的并不是对象自身，而是可通过 telnet 协议访问的交互式应用程序（资源）。基本格式：telnet://\<user>:\<password>@\<host>:\<port>/示例：telnet://slurp:webhound@joes-hardware.com:23/。

**主机与端口** ：主机组件可以是服务器主机的IP地址或文本域名（也称为主机名，比如 www.baidu.com，比IP地址人性化）。文本域名可以通过域名服务（Domain Name Service，DNS）的机制转换成IP地址。端口组件标识了服务器正在监听的网络端口。对于HTTP来说，默认端口号为80。

**用户名和密码** ：很多服务器（如FTP 服务器）都要求输入用户名和密码才会允许用户访问数据。如：

ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu。

**路径** ：路径组件说明了资源位于服务器的什么地方。路径通常很像一个分级的文件系统路径。**每个路径段都有自己的参数（param）组件**。

**参数** ：在某些方案中，参数组件可为应用程序提供访问资源所需的所有附加信息，以便正确地与服务器进行交互。参数为名 / 值对的形式。URL 中可以包含多个参数字段，它们相互之间以及与路径的其余部分之间用分号（;）分隔。如HTTP URL的路径组件可以分成若干路径段。每段都可以有自己的参数。比如：

http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true

**查询** ：查询（query）组件通过提问题或进行查询方式来缩小某些请求资源（比如数据库服务）类型范围。用字符“?”将查询组件与其前面的URL部分分隔开来，多个查询条件之间以“&”分隔。如：

http://www.joes-hardware.com/inventory-check.cgi?item=12731&color=blue&size=large

**片段** ：为了引用部分资源或资源的一个片段，URL支持使用片段（frag）组件来表示一个资源内部的片段。比如，指向
一个带有章节的文档中的某个章节处。片段位于URL的最右边，最前面有一个字符“#”。比如：

http://www.joes-hardware.com/tools.html#drills

访问上面的链接后，服务器返回整个HTML页面，然后向下滚动，从名为drills的片段处开始显示。

**相对URL** ：相比包含了访问资源所需的全部信息的绝对URL ，相对URL表示相对于基础URL（base URL）的一个不完整的URL。相对URL使用缩略形式的语法，省去了方案、主机和其他一些组件了。比如\<a href="./hammers.html">。

相对 URL 为保持一组资源（比如一些 HTML 页面）的可移植性提供了一种便捷方式。如果使用的是相对 URL，就可以在搬移一组文档的同时，仍然保持链接的有效性，因为相对 URL 都是相对于新基础进行解释的。这样就可以实现在其他服务器上提供镜像内容之类的功能了。

将相对 URL 转换成绝对 URL的流程如下：

![相对URL](appendix/相对URL.png)

**自动扩展UR**L：有些浏览器会在用户提交URL之后，或者在用户输入的时候尝试着自动扩展URL。大大方便用户了用户的输入。一般情况下，浏览器可以通过主机名和浏览历史进行URL的自动扩展。

**URL编码**：URL是可移植的（可通过**各种不同的协议**来传送资源），同时URL传输是安全的（不会丢失信息），所以URL只能使用相对较小的、通用的ASCII 字符集。但是ASCII字符集不能用来表示其他语言的字符，故URL使用一种[“转义”编码机制](http://baike.baidu.com/link?url=bOlexnfD9D_zicGNcAbTC3J-XaU3WoAqa-iFmNG3OKf29m9t0moqgo2Hps0vaUVrvkRJGzrRfjFb17J7Z1DAPAiUnk3-ZN7T5B5Ck7hsKVa)，即使用一个带有“%”的两位十六进制数字来表示非ASCII字符。比如“\”，它的ASCII码是92，92的十六进制是5C，所以“\”的URL编码就是%5C。汉字的URL编码信息多了一些，比如“胡”的ASCII码是-17670，十六进制是BAFA，RUL编码就是“%BA%FA”。

比如在搜索引擎中输入一段汉字，就会在浏览器地址栏里看到中文部分被转义了（转义后的字符的MIME类型为application/x-www-form-urlencode）。在Web开发中提交表单的时候，form表单参数中会有一个enctype的参数。enctype指定了HTTP请求的Content-Type。默认情况下，HTML的form表单的enctype=application/x-www-form-urlencoded。application/x-www-form-urlencoded是指表单的提交，并且将提交的数据进行urlencode。默认情况下，我们所有的表单提交都是通过这种默认的方式实现的。

在URL中，有几个字符被保留起来，有着特殊的含义。有些字符不在定义的ASCII可打印字符集中。还有些字符会与某些因特网网关和协议产生混淆，因此不赞成使用。

**URN** ：即统一资源名（Uniform Resource Name ）作为特定内容的唯一名称使用的，与目前的资源所在地无关。仍处于试验阶段。

### 报文

HTTP 报文是在 HTTP 应用程序之间发送的数据块。这些数据块以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。

HTTP报文由简单的文本字符串组成，分为以下两种形式：

- 请求报文（request message）：从客户端发往服务器的HTTP报文；
- 响应报文（response message）：从服务器发往客户端的报文。

请求报文的格式：

```html
<method> <request-URL> <version>
<headers>

<entity-body>
```

响应报文的格式（注意，只有起始行的语法有所不同）：

```html
<version> <status> <reason-phrase>
<headers>

<entity-body>
```

HTTP报文包括以下三个部分：

- **起始行（start line）**：即报文的第一行。请求报文的起始行又叫**请求行**，包含了一个**方法** 参考后面的方法介绍）和一个**请求URL**，这个方法描述了服务器应该执行的操作，请求URL描述了要对哪个资源执行这个方法。请求行中还包含**HTTP版本**，用来告知服务器，客户端使用的是哪种HTTP。响应报文的起始行又叫**响应行**，包含了响应报文使用的**HTTP版本**、**数字状态码**，以及描述操作状态的文本形式的**原因短语**。所有这些字段都**由空格符分隔**；
- **首部（header）块**：起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。首部字段以一个空行结束；


- **主体（body）**：空行之后就是可选的报文主体了，其中可包含所有类型的数据。请求主体中包括了要发送给Web服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制数据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本。

HTTP 规范中说明应该用CRLF （回车换行符，carriage return/line feed）来表示起始行和首部的行终止、以及作为首部块与主体分隔符，但稳健的应用程序也应该接受单个换行符作为行的终止。有些老的，或不完整的 HTTP 应用程序并不总是既发送回车符，又发送换行符。

![http4](appendix/http4.png)

下面对各部分进行简要描述：

- **方法（method）** ：客户端希望服务器对资源执行的动作。是一个单独的词，比如 GET、HEAD 或 POST；
- **请求URL（request-URL）** ：命名了所请求资源，或者 URL 路径组件的完整 URL；
- **版本（version）** ：报文所使用的HTT 版本，其格式为：HTTP/\<major>.\<minor>，其中主要版本号（major）和次要版本号（minor）都是单独的整数。因此在比较HTTP版本时，每个数字都必须单独进行比较，以便确定哪个版本更高。比如，HTTP/2.22 就比HTTP/2.3 的版本要高，因为22比3大；
- **状态码（status-code）** ：这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描
  述状态的一般类别（“成功”、“出错”等）；
- **原因短语（reason-phrase）** ：数字状态码的简要描述；
- **首部（header）字段** ：可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个CRLF。**首部是由一个空行（CRLF）结束的**，表示了首部列表的结束和实体主体部分的开始。有些HTTP版本，比如HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部；
- **实体的主体部分（entity-body）** ：实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实
  体的主体部分，有时，报文只是以一个CRLF结束。


### 方法

HTTP支持的**请求命令被称为HTTP方法**（HTTP method）。每条HTTP请求报文都包含一个方法，这个方法会告诉服务器要执行什么动作。常见的HTTP方法如下：

- GET：从服务器向客户端发送命名资源；
- PUT：将来自客户端的数据存储到一个命名的服务器资源中去；
- DELETE 从服务器中删除命名资源；
- POST 将客户端数据发送到一个服务器网关应用程序；
- HEAD 仅发送命名资源响应中的 HTTP 首部。

并不是每个服务器都实现了所有的方法。如果一台服务器要与 HTTP 1.1 兼容，那么只要为其资源实现 GET 方法和 HEAD 方法就可以了。即使服务器实现了所有这些方法，这些方法的使用很可能也有一定的限制。

#### 安全方法

HTTP 定义了一组被称为**安全方法**的方法。GET 方法和 HEAD 方法都被认为是安全的，这就意味着使用 GET 或 HEAD 方法的 HTTP 请求一般不会产生什么动作。安全方法并不一定是什么动作都不执行的（实际上，这是由 Web 开发者决定的）。使用安全方法的目的就是当使用可能引发某一动作的不安全方法时，允许 HTTP 应用程序开发者通知用户（比如支付费用）。

#### GET

GET 是最常用的方法。**通常用于请求服务器发送某个资源**。**HTTP/1.1 要求服务器实现此方法**。一个GET方法的实例如下图所示。

![get](appendix/get.png)

#### HEAD

HEAD 方法与 GET 方法的行为很类似，但**服务器在响应中只返回首部**。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。使用 HEAD，可以：

- **在不获取资源的情况下了解资源的情况（比如，判断其类型）**；
- **通过查看响应中的状态码，看看某个对象是否存在**；
- **通过查看首部，测试资源是否被修改了**。

服务器开发者必须**确保返回的首部与GET请求所返回的首部完全相同**。 **遵循HTTP/1.1 规范，就必须实现 HEAD 方法**。下图显示了实际的 HEAD 方法。

![head](appendix/head.png)

#### PUT

与 GET 从服务器读取文档相反，PUT 方法会**向服务器写入文档**。比如，有些发布系统**可允许用户创建 Web 页面**，并用 PUT 直接将其安装到 Web 服务器上去。如下图所示。

![put](appendix/put.png)

PUT 方法就是让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用这个主体来替代它。因为 PUT 允许用户对内容进行修改，所以很多 Web 服务器都要求在执行 PUT 之前，用密码登录。

#### POST

POST 方法起初是**用来向服务器输入数据**的。实际上，通常会用它来支持 HTML 的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理）。下图显示了一个用 POST 方法发起 HTTP 请求——向服务器发送表单数据——的客户端。

![post](appendix/post.png)

> 区别： POST 用于向服务器发送数据。PUT 用于向服务器上的资源（例如文件）中存储数据。

#### TRACE

客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。

TRACE 请求会**在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文**。这样客户端就可以查看在所有中间 HTTP 应用程序组成的请求 / 响应链上，原始报文是否，以及如何被毁坏或修改过。一个TRACE请求的实例如下图所示。

![trace](appendix/trace.png)

TRACE 方法主要用于诊断；也就是说，用于验证请求是否如愿穿过了请求 / 响应链。它也是一种很好的工具，可以用来查看代理和其他应用程序对用户请求所产生效果。

尽管 TRACE 可以很方便地用于诊断，但它确实也有缺点，它假定中间应用程序对各种不同类型请求（不同的方法——GET、HEAD、POST 等）的处理是相同的。很多 HTTP 应用程序会根据方法的不同做出不同的事情——比如，代理可能会将POST 请求直接发送给服务器，而将 GET 请求发送给另一个 HTTP 应用程序（比如Web 缓存）。TRACE 并不提供区分这些方法的机制。通常，中间应用程序会自行决定对 TRACE 请求的处理方式。

TRACE 请求中不能带有实体的主体部分。TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本。

#### OPTIONS

OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）。这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源的最优方式。下图显示了一个使用 OPTIONS 方法的请求。

![option](appendix/option.png)

#### DELETE

顾名思义，DELETE 方法所做的事情就是请服务器删除请求 URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求。下图显示了一个 DELETE 方法实例。

![delete](appendix/delete.png)

#### 扩展方法

HTTP 被设计成字段可扩展的，这样新的特性就不会使老的软件失效了。**扩展方法指的就是没有在 HTTP/1.1 规范中定义的方法。服务器会为它所管理的资源实现一些 HTTP 服务，这些方法为开发者提供了一种扩展这些 HTTP 服务能力的手段**。下表列出了一些常见的扩展方法实例。这些方法就是 WebDAV HTTP 扩展（后续介绍）包含的所有方法，这些方法有助于通过 HTTP 将 Web 内容发布到 Web 服务器上去。

| 方法    | 描述                                       |
| ----- | ---------------------------------------- |
| LOCK  | 允许用户“锁定”资源。比如，可以在编辑某个资源的时候将其锁定，以防别人同时对其进行修改 |
| MKCOL | 允许用户创建资源                                 |
| COPY  | 便于在服务器上复制资源                              |
| MOVE  | 在服务器上移动资源                                |

并不是所有的扩展方法都是在正式规范中定义的。如果你定义了一个扩展方法，很可能大部分 HTTP 应用程序都无法理解。同样，你的 HTTP 应用程序也可能会遇到一些其他应用程序在用的，而它并不理解的扩展方法。

在这些情况下，最好对扩展方法宽容一些。如果能够在不破坏端到端行为的情况下将带有未知方法的报文传递给下游服务器，代理应尝试传递这些报文。如果可能破坏端到端行为则应以 501 Not Implemented（无法实现）状态码进行响应。最好按惯例“**对所发送的内容要求严一点，对所接收的内容宽容一些**”来处理扩展方法（以及一般的 HTTP 扩展）。

### 状态码

每条HTTP响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者是否需要采取其他动作。

状态码为客户端提供了一种理解事务处理结果的便捷方式。尽管并没有实际的规范对原因短语的确切文本进行说明，这里还是列出了 HTTP/1.1 规范推荐使用的原因短语。

HTTP 状态码被分成了五大类。

#### 100～199——信息性状态码

HTTP/1.1 向协议中引入了信息性状态码。这些状态码相对较新，因其复杂性和感官上存在一些争论而受到限制。下表列出了已定义的信息性状态码。

| 状态码  | 原因短语                | 含义                                       |
| ---- | ------------------- | ---------------------------------------- |
| 100  | Continue            | 说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应 |
| 101  | Switching Protocols | 说明服务器正在根据客户端的指定，将协议切换成 Update 首部所列的协议    |

100 Continue 状态码尤其让人糊涂。它的目的是对这样的情况进行优化：HTTP 客户端应用程序有一个实体的主体部分要发送给服务器，但希望在发送之前查看一下服务器是否会接受这个实体。这可能会给 HTTP 程序员带来一些困扰，因此在这里进行了比较详细（它如何与客户端、服务器和代理进行通信）的讨论。

1. **客户端与100 Continue**
   如果客户端在向服务器发送一个实体，并且愿意在发送实体之前等待 100 Continue 响应，那么，客户端就要发送一个携带了值为 100 Continue 的 Expect 请求首部。如果客户端没有发送实体，就不应该发送 100 Continue Expect 首部，因为这样会使服务器误以为客户端要发送一个实体。从很多方面来看，100 Continue 都是一种优化。客户端应用程序只有在避免向服务器发送一个服务器无法处理或使用的大实体时，才应该使用 100 Continue。由于起初对 100 Continue 状态存在一些困惑（而且以前有些实现在这里出过问题），因此发送了值为 100 Continue 的 Expect 首部的客户端不应该永远在那儿等待服务器发送 100 Continue 响应。超时一定时间之后，客户端应该直接将实体发送出去。

   实际上，客户端程序的实现者也应该做好应对非预期 100 Continue 响应的准备（这很烦人，但确实如此）。有些出错的 HTTP 应用程序会不合时宜地发送这个状态码。

2. **服务器与100 Continue**

   如果服务器收到了一条带有值为 100 Continue 的 Expect 首部的请求，它会用 100 Continue 响应或一条错误码来进行响应）。服务器永远也不应该向没有发送 100 Continue 期望的客户端发送 100 Continue 状态码。但如前所述，有些出错的服务器可能会这么做。

   如果出于某种原因，服务器在有机会发送 100 Continue 响应之前就收到了部分（或全部）的实体，就说明客户端已经决定继续发送数据了，这样，服务器就不需要发送这个状态码了。但服务器读完请求之后，还是应该为请求发送一个最终状态码（它可以跳过 100 Continue 状态）。

   最后，如果服务器收到了带有 100 Continue 期望的请求，而且它决定在读取实体的主体部分之前（比如，因为出错而）结束请求，就不应该仅仅是发送一条响应并关闭连接，因为这样会妨碍客户端接收响应。

3. **代理与100 Continue**
   如果代理从客户端收到了一条带有 100 Continue 期望的请求，它需要做几件事情。如果代理知道下一跳服务器（在第 6 章中讨论）是 HTTP/1.1 兼容的，或者并不知道下一跳服务器与哪个版本兼容，它都应该将 Expect 首部放在请求中向下   转发。如果它知道下一跳服务器只能与 HTTP/1.1 之前的版本兼容，就应该以 417 Expectation Failed 错误进行响应（还有一种合理的方法，是向客户端先返回 100 Continue，在向服务器转发请求时，删掉 Expect 首部）。

   如果代理决定代表与HTTP/1.0 或之前版本兼容的客户端，在其请求中放入 Expect首部和 100 Continue 值，那么，（如果它从服务器收到了 100 Continue 响应）它就不应该将 100 Continue 响应转发给客户端，因为客户端可能不知道该拿它怎么办。

   代理维护一些有关下一跳服务器及其所支持的 HTTP 版本的状态信息（至少要维护那些最近收到过请求的服务器的相关状态）是有好处的，这样它们就可以更好地处理收到的那些带有 100 Continue 期望的请求了。

#### 200～299——成功状态码

客户端发起请求时，这些请求通常都是成功的。服务器有一组用来表示成功的状态码，分别对应于不同类型的请求。下表列出了已定义的成功状态码。

| 状态码  | 原因短语                          | 含义                                       |
| ---- | ----------------------------- | ---------------------------------------- |
| 200  | OK                            | 请求没问题，实体的主体部分包含了所请求的资源。                  |
| 201  | Created                       | 用于创建服务器对象的请求（比如，PUT）。响应的实体主体部分中应该包含各种引用了已创建的资源的 URL，Location 首部包含的则是最具体的引用。服务器必须在发送这个状态码之前创建好对象。 |
| 202  | Accepted                      | 请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求；这只是意味着接受请求时，它看起来是有效的。服务器应该在实体的主体部分包含对请求状态的描述，或许还应该有对请求完成时间的估计（或者包含一个指针，指向可以获取此信息的位置）。 |
| 203  | Non-Authoritative Information | 实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法（或没有）对它所发送的与资源有关的元信息（首部）进行验证，就会出现这种情况。这种响应码并不是非用不可的；如果实体首部来自源端服务器，响应为 200 状态的应用程序就可以将其作为一种可选项使用。 |
| 204  | No Content                    | 响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不转为显示新文档的情况下，对其进行更新（比如刷新一个表单页面）。 |
| 205  | Reset Content                 | 另一个主要用于浏览器的代码。负责告知浏览器清除当前页面中的所有 HTML 表单元素。 |
| 206  | Partial Content               | 成功执行了一个部分或 Range（范围）请求。稍后我们会看到，客户端可以通过一些特殊的首部来获取部分或某个范围内的文档——这个状态码就说明范围请求成功了。206 响应中必须包含 Content-Range、Date 以及 ETag 或 Content-Location 首部。 |
#### 300～399——重定向状态码

重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。如果资源已被移动，可发送一个重定向状态码和一个可选的 Location 首部来告知客户端资源已被移走，以及现在可以在哪里找到它（如下图所示）。这样，浏览器就可以在不打扰使用者的情况下，透明地转入新的位置了。

![重定向](appendix/重定向.png)

可以通过某些重定向状态码对资源的应用程序本地副本与源端服务器上的资源进行验证。比如，HTTP 应用程序可以查看其资源的本地副本是否仍然是最新的，或者在源端服务器上资源是否被修改过。下图显示了一个这样的例子。客户端发送了一个特殊的 If-Modiﬁed-Since 首部，说明只读取 1997 年 10 月之后修改过的文档。这个日期之后，此文档并未被修改过，因此，服务器回送了一个 304 状态码，而不是文档的内容。 

![重定向2](appendix/重定向2.png)

总之，在对那些包含了重定向状态码的非 HEAD 请求进行响应时，最好要包含一个实体，并在实体中包含描述信息和指向（多个）重定向 URL 的链接。下表列出了已定义的重定向状态码。

| 状态码  | 原因短语               | 含义                                       |
| ---- | ------------------ | ---------------------------------------- |
| 300  | Multiple Choices   | 客户端请求一个实际指向多个资源的 URL 时会返回这个状态码，比如服务器上有某个 HTML 文档的英语和法语版本。返回这个代码时会带有一个选项列表；这样用户就可以选择他希望使用的那一项了。有多个版本可用时，客户端需要沟通解决。服务器可以在 Location 首部包含首选 URL。 |
| 301  | Moved Permanently  | 在请求的 URL 已被移除时使用。响应的 Location 首部中应该包含资源现在所处的 URL。 |
| 302  | Found              | 与 301 状态码类似；但客户端应该使用 Location 首部给出的 URL 来临时定位资源。将来的请求仍应使用老的 URL。 |
| 303  | See Other          | 告知客户端应该用另一个 URL 来获取资源。新的 URL 位于响应报文的 Location 首部。其主要目的是允许 POST 请求的响应将客户端定向到某个资源上去。 |
| 304  | Not Modified       | 客户端可以通过所包含的请求首部，使其请求变成有条件的。如果客户端发起了一个条件 GET请求，而最近资源未被修改的话，就可以用这个状态码来说明资源未被修改。带有这个状态码的响应不应该包含实体的主体部分。 |
| 305  | Use Proxy          | 用来说明必须通过一个代理来访问资源；代理的位置由 Location 首部给出。很重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞 |
| 306  | （未使用）              | 当前未使用                                    |
| 307  | Temporary Redirect | 与 301 状态码类似；但客户端应该使用 Location 首部给出的 URL 来临时定位资源。将来的请求应该使用老的 URL |

你可能已经注意到 302、303 和 307 状态码之间存在一些交叉。这些状态码的用法有着细微的差别，大部分差别都源于 HTTP/1.0 和 HTTP/1.1 应用程序对这些状态码处理方式的不同。

当 HTTP/1.0 客户端发起一个 POST 请求，并在响应中收到 302 重定向状态码时，它会接受 Location 首部的重定向 URL，并向那个 URL 发起一个 GET 请求（而不会像原始请求中那样发起 POST 请求）。

HTTP/1.0 服务器希望 HTTP/1.0 客户端这么做——如果 HTTP/1.0 服务器收到来自HTTP/1.0 客户端的 POST 请求之后发送了 302 状态码，服务器就期望客户端能够接受重定向 URL，并向重定向的 URL 发送一个 GET 请求。

问题出在 HTTP/1.1。HTTP/1.1 规范使用 303 状态码来实现同样的行为（服务器发送 303 状态码来重定向客户端的 POST 请求，在它后面跟上一个 GET 请求）。

为了避开这个问题，HTTP/1.1 规范指出，对于 HTTP/1.1 客户端，用 307 状态码取代 302 状态码来进行临时重定向。这样服务器就可以将 302 状态码保留起来，为HTTP/1.0 客户端使用了。

这样一来，服务器要选择适当的重定向状态码放入重定向响应中发送，就需要查看客户端的 HTTP 版本了。

#### 400～499——客户端错误状态码

有时客户端会发送一些服务器无法处理的东西，比如格式错误的请求报文，或者最常见的是，请求一个不存在的 URL。
浏览网页时，我们都看到过臭名昭著的 404 Not Found 错误码——这只是服务器在告诉我们，它对我们请求的资源一无所知。

很多客户端错误都是由浏览器来处理的，甚至不会打扰到你。只有少量错误，比如404，还是会穿过浏览器来到用户面前。下表显示了各种客户端的错误状态码。

| 状态码  | 原因短语                            | 含义                                       |
| ---- | ------------------------------- | ---------------------------------------- |
| 400  | Bad Request                     | 用于告知客户端它发送了一个错误的请求。                      |
| 401  | Unauthorized                    | 与适当的首部一同返回，在这些首部中请求客户端在获取对资源。            |
| 402  | Payment Required                | 现在这个状态码还未使用，但已经被保留，以作未来之用。               |
| 403  | Forbidden                       | 用于说明请求被服务器拒绝了。如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态码通常是在服务器不想说明拒绝原因的时候使用的。 |
| 404  | Not Found                       | 用于说明服务器无法找到所请求的 URL。通常会包含一个实体，以便客户端应用程序显示给用户看。 |
| 405  | Method Not Allowed              | 发起的请求中带有所请求的 URL 不支持的方法时，使用此状态码。应该在响应中包含 Allow 首部，以告知客户端对所请求的资源可以使用哪些方法。 |
| 406  | Not Acceptable                  | 客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的 URL 相匹配的资源时，使用此代码。通常，服务器会包含一些首部，以便客户端弄清楚为什么请求无法满足。 |
| 407  | Proxy Authentication Required   | 与 401 状态码类似，但用于要求对资源进行认证的代理服务器.          |
| 408  | Request Timeout                 | 如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。超时时长随服务器的不同有所不同，但通常对所有的合法请求来说，都是够长的。 |
| 409  | Conflict                        | 用于说明请求可能在资源上引发的一些冲突。服务器担心请求会引发冲突时，可以发送此状态码。响应中应该包含描述冲突的主体。 |
| 410  | Gone                            | 与 404 类似，只是服务器曾经拥有过此资源。主要用于 Web 站点的维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了 |
| 411  | Length Required                 | 服务器要求在请求报文中包含 Content-Length 首部时使用。      |
| 412  | Precondition Failed             | 客户端发起了条件请求，且其中一个条件失败了的时候使用。客户端包含了 Expect 首部时发起的就是条件请求。 |
| 413  | Request Entity Too Large        | 客户端发送的实体主体部分比服务器能够或者希望处理的要大时，使用此状态码。     |
| 414  | Request URI Too Long            | 客户端所发请求中的请求 URL 比服务器能够或者希望处理的要长时，使用此状态码。 |
| 415  | Unsupported Media Type          | 服务器无法理解或无法支持客户端所发实体的内容类型时，使用此状态码。        |
| 416  | Requested Range Not Satisfiable | 请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时，使用此状态码。  |
| 417  | Expectation Failed              | 请求的 Expect 请求首部包含了一个期望，但服务器无法满足此期望时，就使用此状态码。如果代理或其他中间应用程序有确切证据说明源端服务器会为某请求产生一个失败的期望，就可以发送这个响应状态码。 |

#### 500～599——服务器错误状态码

有时客户端发送了一条有效请求，服务器自身却出错了。这可能是客户端碰上了服务器的缺陷，或者服务器上的子元素，比如某个网关资源，出了错。

代理尝试着代表客户端与服务器进行交流时，经常会出现问题。代理会发布 5XX 服务器错误状态码来描述所遇到的问题。下表列出了已定义的服务器错误状态码。

| 状态码  | 原因短语                       | 含义                                       |
| ---- | -------------------------- | ---------------------------------------- |
| 500  | Internal Server Error      | 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码             |
| 501  | Not Implemented            | 客户端发起的请求超出服务器的能力范围（比如，使用了服务器不支持的请求方法）时，使用此状态码 |
| 502  | Bad Gateway                | 作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（比如，它无法连接到其父网关）时，使用此状态码 |
| 503  | Service Unavailable        | 用来说明服务器现在无法为请求提供服务，但将来可以。如果服务器知道什么时候资源会变为可用的，可以在响应中包含一个 Retry-After 首部。 |
| 504  | Gateway Timeout            | 与状态码 408 类似，只是这里的响应来自一个网关或代理，它们在等待另一服务器对其请求进行响应时超时了 |
| 505  | HTTP Version Not Supported | 服务器收到的请求使用了它无法或不愿支持的协议版本时，使用此状态码。有些服务器应用程序会选择不支持协议的早期版本 |

### 首部

首部和方法配合工作，共同决定了客户端和服务器能做什么事情。在请求和响应报文中都可以用首部来提供信息，有些首部是某种报文专用的，有些首部则更通用一些。可以将首部分为五个主要的类型。

#### 通用首部

通用首部是客户端和服务器都可以使用的首部。这些首部提供了与报文相关的最基本的信息，不论报文是何类型，都为其提供一些有用信息。下表列出了通用的信息性首部。

| 通用首部              | 含义                                       |
| ----------------- | ---------------------------------------- |
| Connection        | 允许客户端和服务器指定与请求 / 响应连接有关的选项               |
| Date              | 提供日期和时间标志，说明报文是什么时间创建的。同时列出了 Date 首部可接受的日期格式 |
| MIME-Version      | 给出了发送端使用的 MIME 版本                        |
| Trailer           | 如果报文采用了分块传输编码（chunked transfer encoding）方式，就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合 |
| Transfer-Encoding | 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式            |
| Update            | 给出了发送端可能想要“升级”使用的新版本或协议                  |
| Via               | 显示了报文经过的中间节点（代理、网关）                      |

HTTP/1.0 引入了第一个允许 HTTP 应用程序缓存对象本地副本的首部，这样就不需要总是直接从源端服务器获取了。最新的 HTTP 版本有非常丰富的缓存参数集。下表列出了基本的缓存首部。

| 首部            | 描述                     |
| ------------- | ---------------------- |
| Cache-Control | 用于随报文传送缓存指示            |
| Pragma        | 另一种随报文传送指示的方式，但并不专用于缓存 |

#### 请求首部

请求首部是**只在请求报文中有意义的首部**。用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力。服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应。下表列出了请求的**信息性首部**。

| 信息性首部      | 描述                     |
| ---------- | ---------------------- |
| Client-IP  | 提供了运行客户端的机器的 IP 地址     |
| From       | 提供了客户端用户的 E-mail 地址    |
| Host       | 给出了接收请求的服务器的主机名和端口号    |
| Referer    | 提供了包含当前请求 URI 的文档的 URL |
| UA-Color   | 提供了与客户端显示器的显示颜色有关的信息   |
| UA-CPU     | 给出了客户端 CPU 的类型或制造商     |
| UA-Disp    | 提供了与客户端显示器（屏幕）能力有关的信息  |
| UA-OS      | 给出了运行在客户端机器上的操作系统名称及版本 |
| UA-Pixels  | 提供了客户端显示器的像素信息         |
| User-Agent | 将发起请求的应用程序名称告知服务器      |

##### Accept首部

Accept 首部为客户端提供了一种将其喜好和能力告知服务器的方式，包括它们想要什么，可以使用什么，以及最重要的，它们不想要什么。这样，服务器就可以根据这些额外信息，对要发送的内容做出更明智的决定。Accept 首部会使连接的两端都受益。客户端会得到它们想要的内容，服务器则不会浪费其时间和带宽来发送客户端无法使用的东西。下表列出了各种 Accept 首部。

| Accept首部        | 描述                |
| --------------- | ----------------- |
| Accept          | 告诉服务器能够发送哪些媒体类型   |
| Accept-Charset  | 告诉服务器能够发送哪些字符集    |
| Accept-Encoding | 告诉服务器能够发送哪些编码方式   |
| Accept-Language | 告诉服务器能够发送哪些语言     |
| TE              | 告诉服务器可以使用哪些扩展传输编码 |

##### 条件请求首部

有时客户端希望为请求加上某些限制。比如，如果客户端已经有了一份文档副本，就希望只在服务器上的文档与客户端拥有的副本有所区别时，才请求服务器传输文档。通过条件请求首部，客户端就可以为请求加上这种限制，要求服务器在对请求进行响应之前，确保某个条件为真。表 3-15 列出了各种条件请求首部。

| 条件请求首部              | 描述                            |
| ------------------- | ----------------------------- |
| Expect              | 允许客户端列出某请求所要求的服务器行为           |
| If-Match            | 如果实体标记与文档当前的实体标记相匹配，就获取这份文档   |
| If-Modified-Since   | 除非在某个指定的日期之后资源被修改过，否则就限制这个请求  |
| If-None-Match       | 如果提供的实体标记与当前文档的实体标记不相符，就获取文档  |
| If-Range            | 允许对文档的某个范围进行条件请求              |
| If-Unmodified-Since | 除非在某个指定日期之后资源没有被修改过，否则就限制这个请求 |
| Range               | 如果服务器支持范围请求，就请求资源的指定范围        |

##### 安全请求首部

HTTP 本身就支持一种简单的机制，可以对请求进行质询 / 响应认证。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务稍微安全一些。我们会在第 14 章讨论这种质询 / 响应机制，同时还会对在 HTTP 之上实现的其他安全机制进行讨论。下表列出了一些安全请求首部。

| 安全请求首部        | 描述                                      |
| ------------- | --------------------------------------- |
| Authorization | 包含了客户端提供给服务器，以便对其自身进行认证的数据              |
| Cookie        | 客户端用它向服务器传送一个令牌——它并不是真正的安全首部，但确实隐含了安全功能 |
| Cookie2       | 用来说明请求端支持的 cookie 版本                    |

##### 代理请求首部

随着因特网上代理的普遍应用，人们定义了几个首部来协助其更好地工作。下表列出了一些代理请求首部。

| 代理请求首部              | 描述                                       |
| ------------------- | ---------------------------------------- |
| Max-Forward         | 在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数——与 TRACE 方法一同使用 |
| Proxy-Authorization | 与 Authorization 首部相同，但这个首部是在与代理进行认证时使用的  |
| Proxy-Connection    | 与 Connection 首部相同，但这个首部是在与代理建立连接时使用的     |

#### 响应首部

响应报文有自己的响应首部集。响应首部为客户端提供了一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些首部有助于客户端处理响应，并在将来发起更好的请求。下表列出了一些响应的**信息性首部**。

| 响应的信息性首部    | 描述                             |
| ----------- | ------------------------------ |
| Age         | （从最初创建开始）响应持续时间                |
| Public      | 服务器为其资源支持的请求方法列表               |
| Retry-After | 如果资源不可用的话，在此日期或时间重试            |
| Server      | 服务器应用程序软件的名称和版本                |
| Title       | 对 HTML 文档来说，就是 HTML 文档的源端给出的标题 |
| Warning     | 比原因短语中更详细一些的警告报文               |

##### 协商首部

如果资源有多种表示方法——比如，如果服务器上有某文档的法语和德语译稿，HTTP/1.1 可以为服务器和客户端提供对资源进行协商的能力。这里列出了几个首部，服务器可以用它们来传递与可协商资源有关的信息。下表列出了**协商首部**。

| 协商首部          | 描述                                       |
| ------------- | ---------------------------------------- |
| Accept-Ranges | 对此资源来说，服务器可接受的范围类型                       |
| Vary          | 服务器查看的其他首部的列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端 |

##### 安全响应首部

我们已经看到过安全请求首部了，本质上这里说的就是 HTTP 的质询 / 响应认证机制的响应侧。下表列出了安全响应首部。

| 安全响应首部             | 描述                                       |
| ------------------ | ---------------------------------------- |
| Proxy-Authenticate | 来自代理的对客户端的质询列表                           |
| Set-Cookie         | 不是真正的安全首部，但隐含有安全功能；可以在客户端设置一个令牌，以便服务器对客户端进行标识 |
| Set-Cookie2        | 与 Set-Cookie 类似，RFC 2965 Cookie 定义       |
| WWW-Authenticate   | 来自服务器的对客户端的质询列表                          |

#### 实体首部

实体首部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体首部可以告知报文的接收者它在对什么进行处理。由于请求和响应报文中都可能包含实体部分，所以在这两种类型的报文中都可能出现这些首部。表下列出了实体的**信息性首部**。

| 信息性首部    | 描述                                       |
| -------- | ---------------------------------------- |
| Allow    | 列出了可以对此实体执行的请求方法                         |
| Location | 告知客户端实体实际上位于何处；用于将接收端定向到资源的（可能是新的）位置（URL）上去 |

##### 内容首部

内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息。比如，Web 浏览器可以通过查看返回的内容类型，得知如何显示对象。下表列出了各种内容首部。

| 内容首部             | 描述                      |
| ---------------- | ----------------------- |
| Content-Base     | 解析主体中的相对 URL 时使用的基础 URL |
| Content-Encoding | 对主体执行的任意编码方式            |
| Content-Language | 理解主体时最适宜使用的自然语言         |
| Content-Length   | 主体的长度或尺寸                |
| Content-Location | 资源实际所处的位置               |
| Content-MD5      | 主体的 MD5 校验和             |
| Content-Range    | 在整个资源中此实体表示的字节范围        |
| Content-Type     | 这个主体的对象类型               |

##### 实体缓存首部

通用的缓存首部说明了如何或什么时候进行缓存。实体的缓存首部提供了与被缓存实体有关的信息——比如，验证已缓存的资源副本是否仍然有效所需的信息，以及更好地估计已缓存资源何时失效所需的线索。 下表列出了一些实体缓存首部。

| 实体缓存首部        | 描述                          |
| ------------- | --------------------------- |
| ETag          | 与此实体相关的实体标记                 |
| Expires       | 实体不再有效，要从原始的源端再次获取此实体的日期和时间 |
| Last-Modified | 这个实体最后一次被修改的日期和时间           |

### 连接管理

#### TCP连接

HTTP是个应用层协议。它不用去关系网络通信的具体细节，而是把联网的细节都交给了通用、可靠的因特网传输协议 TCP/IP协议。世界上几乎所有的 HTTP 通信都是由 TCP/IP 承载的，TCP/IP 是全球计算机及网络设备都在使用的一种常用的**分组交换网络分层协议集**。客户端应用程序可以打开一条 TCP/IP 连接，连接到可能运行在世界任何地方的服务器应用程序。一旦连接建立起来了，在客户端和服务器的计算机之间交换的报文就永远不会丢失、受损或失序（ 尽管报文不会丢失或受损，但如果计算机或网络崩溃了，客户端和服务器之间的通信仍然会被断开。在这种情况下，会通知客户端和服务器通信中断了）。

TCP提供了：

- 无差错的数据传输。保证了数据传输的完整性；
- 按序传输。数据总是会按照发送的顺序到达；
- 未分段的数据流。可以在任意时刻以任意尺寸将数据发送出去；
- 无视网络设备差异。任何计算机和网络都能够进行可靠地通信。

在HTTP客户端向服务器发送报文之前，需要用IP（Internet Protocol，网际协议）地址和端口号在客户端和服务器之间建立一条可靠的 TCP/IP 比特传输管道。从一端以原有的顺序、正确地传送出来基本的浏览器连接处理如下图所示。

![TCP1](C:\Users\Administrator\Desktop\TCP1.png)

##### TCP流的分段和分组传送

TCP 的数据是通过名为 IP 分组（或 IP 数据报）的小数据块来发送的。这样的话，
如下图中的HTTP网络协议栈所示，HTTP 就是“HTTP over TCP over IP”这个“协议栈”中的最顶层了。其安全版本 HTTPS 就是在 HTTP 和 TCP 之间插入了一个（称为 TLS 或 SSL 的）密码加密层（如下图中的HTTPS网络协议栈所示）。

![TCP2](appendix/TCP2.png)

HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在 IP 分组中，通过因特网进行传输（参见图 4-4）。所有这些工作都是由 TCP/IP 软件来处理的，HTTP 程序员什么都看不到。每个 TCP 段都是由 IP 分组承载，从一个 IP 地址发送到另一个 IP 地址的。每个 IP 分组中都包括：

- 一个 IP 分组首部（通常为 20 字节）；
- 一个 TCP 段首部（通常为 20 字节）；
- 一个 TCP 数据块（0 个或多个字节）。

IP 首部包含了源和目的 IP 地址、长度和其他一些标记。TCP 段的首部包含了 TCP 端口号、TCP 控制标记，以及用于数据排序和完整性检查的一些数字值。

##### 保持TCP连接持续不断地运行

TCP 是通过端口号来保持多条TCP连接持续不断地运行。IP 地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序上去。TCP 连接是通过 4 个值来识别的：

```html
< 源IP地址、源端口号、目的IP地址、目的端口号 >
```

这 4 个值一起唯一地定义了一条连接。两条不同的 TCP 连接不能拥有 4 个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值）。

![TCP3](appendix/TCP3.png)

如下图所示，有四条TCP连接：A、B、C 和 D。

![TCP4](appendix/TCP4.png)

> 注意，有些连接共享了相同的目的端口号（C 和 D 都使用目的端口号 80）。有些连接使用了相同的源 IP 地址（B 和 C）。有些使用了相同的目的 IP 地址（A 和 B，C 和 D）。但没有两个不同连接所有的 4 个值都一样。

##### 用TCP套接字编程

操作系统提供了一些操纵其 TCP 连接的工具。下表显示了套接字 API 提供的一些主要接口。这个套接字 API 向 HTTP 程序员隐藏了 TCP 和 IP 的所有细节。套接字 API 最初是为 Unix 操作系统开发的，但现在几乎所有的操作系统和语言中都有其变体存在。

| 套接字API调用                      | 描述                     |
| ----------------------------- | ---------------------- |
| s = socket(\<parameters>)     | 创建一个新的、未命名、未关联的套接字     |
| bind(s,\<local IP:port>)      | 向套接字赋一个本地端口号和接口        |
| connect(s, \<remote IP:port>) | 创建一条连接本地套接字与远程主机及端口的连接 |
| listen(s,...)                 | 标识一个本地套接字，使其可以合法接受连接   |
| s2 = accept(s)                | 等待某人建立一条到本地端口的连接       |
| n = read(s, buffer, n)        | 尝试从套接字向缓冲区读取 n 个字节     |
| n = write(s, buffer, n)       | 尝试从缓冲区中向套接字写入 n 个字节    |
| close(s)                      | 完全关闭 TCP 连接            |
| shutdown(s,\<side>)           | 只关闭 TCP 连接的输入或输出端      |
| getsockopt(s,...)             | 读取某个内部套接字配置选项的值        |
| setsockopt(s,...)             | 修改某个内部套接字配置选项的值        |

套接字 API 允许用户创建 TCP 的端点数据结构，将这些端点与远程服务器的 TCP 端点进行连接，并对数据流进行读写。TCP API 隐藏了所有底层网络协议的握手细节，以及 TCP 数据流与 IP 分组之间的分段和重装细节。下图显示了TCP 客户端和服务器是如何通过 TCP 套接字接口进行通信的。

![TCP5](appendix/TCP5.png)






